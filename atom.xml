<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>geekhoon</title>
  <subtitle>善待自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://geekhoon.github.io/"/>
  <updated>2017-01-12T03:10:30.831Z</updated>
  <id>https://geekhoon.github.io/</id>
  
  <author>
    <name>geekhoon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>07.数组</title>
    <link href="https://geekhoon.github.io/2017/01/11/07-%E6%95%B0%E7%BB%84/"/>
    <id>https://geekhoon.github.io/2017/01/11/07-数组/</id>
    <published>2017-01-11T10:03:28.000Z</published>
    <updated>2017-01-12T03:10:30.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1. 数组概述"></a>1. 数组概述</h3><pre><code>* 数组是指一组数据的集合，数组中的每个数据被称作元素。
* 特点:
    (1)在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。
    (2)长度固定
</code></pre><a id="more"></a>
<h3 id="2-数组的定义"><a href="#2-数组的定义" class="headerlink" title="2. 数组的定义"></a>2. 数组的定义</h3><pre><code>* 格式:
    数据类型[] 数组名 = new 数据类型[元素个数或数组长度];

    * 举例:
        int[] x = new int[100];
* 要点说明
      1)数据类型: 数组中存储元素的数据类型
    2) [] 表示数组的意思
    3) 变量名  自定义标识符  
    4) new  创建容器关键字
    5)数据类型: 数组中存储元素的数据类型
    6)[]  表示数组的意思
    7)元素个数,就是数组中,可以存储多少个数据 (恒定, 定长)
* 索引(index)      
    数组是一个容器: 存储到数组中的每个元素,都有自己的自动编号,叫作索引(index), 下标, 角标
    数组的最小索引是0, 最大索引数组.length-1
* 初始化默认值
    //int     0
    //double  0.0
    //char    \u0000(16进制)
</code></pre><h3 id="3-JVM内存划分"><a href="#3-JVM内存划分" class="headerlink" title="3. JVM内存划分"></a>3. JVM内存划分</h3><pre><code>* JVM对自己的内存划分为5个区域
      * 寄存器:内存和CUP之间
      * 本地方法栈: JVM调用了系统中的功能
      * 方法区(方法和数据共享区): 运行时期class文件进入的地方
      * 方法栈:所有的方法运行的时候进入内存,进入的就是栈内存
          * main方法,压栈运行,第一个进栈,在栈最底部,最后释放
      * 堆内存:存储的是容器和对象 
</code></pre><h3 id="4-数组的内存"><a href="#4-数组的内存" class="headerlink" title="4. 数组的内存"></a>4. 数组的内存</h3><pre><code>*   int[] x;                // 声明一个int[]类型的变量
*    x = new int[100];        // 创建一个长度为100的数组
*    arr引用类型,保存的不是数据,是内存的地址,通常是十六进制保存.每次分配的内存地址不一定一样
    *    [:一维数组
    *    I:数据类型 int
    *    @:分隔符
    *    60e218:十六进制地址
</code></pre><p>数组在创建过程中内存的分配情况:</p>
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170112/081737153.bmp" alt=""></p>
<pre><code>1.程序运行时,.class文件进入方法区  
2.找到程序入口main方法,进入方法栈,main方法压栈运行
3.执行int[] arr = new int[3];在堆内存中,开辟一段连续空间,长度为3.
4.arr中保存开辟空间的首地址
</code></pre><h3 id="5-数组初始化"><a href="#5-数组初始化" class="headerlink" title="5. 数组初始化"></a>5. 数组初始化</h3><pre><code>* 动态初始化 : 在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式
        (1) 类型[] 数组名 = new 类型[长度];
        int[] arr = new int[4];
* 静态初始化 : 在定义数组的同时就为数组的每个元素赋值。
        (1) 类型[] 数组名 = new 类型[]{元素1，元素2，……};
        int[] arr = new int[]{1,2,3,4};
        //new int[],这个中括号中不能有任何内容,不要指明数组长度
        可以改写成:
            数组的声明: 类型[] 数组名;
            数组的赋值: 数组名 = new 类型[]{元素1，元素2，……};
        (2) 类型[] 数组名 = {元素1，元素2，元素3，……};     
        int[] arr = { 1, 2, 3, 4 };
        //这种形式不能改成声明+赋值分开写的形式
</code></pre><h3 id="6-遍历数组"><a href="#6-遍历数组" class="headerlink" title="6. 遍历数组"></a>6. 遍历数组</h3><pre><code>* 依次访问数组中的每个元素
* 举例
    public class ArrayDemo04 {
        public static void main(String[] args) {
            int[] arr = { 1, 2, 3, 4, 5 }; // 定义数组
            // 使用for循环遍历数组的元素
            for (int i = 0; i &lt; arr.length; i++) {
                System.out.println(arr[i]); // 通过索引访问元素
            }
        }
    }         
</code></pre><h3 id="7-数组中常见的异常"><a href="#7-数组中常见的异常" class="headerlink" title="7. 数组中常见的异常"></a>7. 数组中常见的异常</h3><pre><code>* 数组操作中,常见的两个异常
     数组的索引越界异常(ArrayIndexOutOfBoundsException)
      空指针异常(NullPointerException)

* 练习
    public class ArrayDemo_4{
        public static void main(String[] args){

        //(1)数组的索引越界异常: 访问了数组中不存在的元素
            //int[] arr = {5,2,1};
            //数组中3个元素,索引 0,1,2
            //System.out.println(arr[3]);
            //编译不报错,运行出错
            //java.lang.ArrayIndexOutOfBoundsException: 3

        //(2)空指针异常
            int[] arr2 = {1,5,8};
            System.out.println(arr2[2]);
            arr2 = null; // arr2 不在保存数组的地址了
            System.out.println(arr2[2]);
            //编译不报错,运行出错
            //java.lang.NullPointerException
        }
    }
</code></pre><h3 id="8-数组获取最值代码实现"><a href="#8-数组获取最值代码实现" class="headerlink" title="8. 数组获取最值代码实现"></a>8. 数组获取最值代码实现</h3><pre><code>* 数组获取最值的原理思想
    * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素
    * 为什么选择数组中的一个元素作为最大值,因为如果自己定义的一个数据比数组所有数据都大,那比较完,得不出数组最大值
* 代码实现
    public class ArrayDemo05 {
        public static void main(String[] args) {
            int[] arr = { 4, 1, 6, 3, 9, 8 };     // 定义一个数组
            int max = arr[0];                     // 定义变量max用于记住最大数，首先假设第一个元素为最大值
            // 下面通过一个for循环遍历数组中的元素
            for (int x = 1; x &lt; arr.length; x++) {
                if (arr[x] &gt; max) {             // 比较 arr[x]的值是否大于max
                    max = arr[x];                 // 条件成立，将arr[x]的值赋给max
                }
            }
            System.out.println(&quot;max=&quot; + max);     // 打印最大值
        }
    }
</code></pre><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="1-二维数组的定义"><a href="#1-二维数组的定义" class="headerlink" title="1. 二维数组的定义"></a>1. 二维数组的定义</h3><pre><code>* 作用
    * 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？
    * 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。
* 格式
    * 第一种定义格式:
        *  int[][] arr = new int[3][4];
        *  上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组
    * 第二种定义格式
        *  int[][] arr = new int[3][];
        *  第二种方式和第一种类似，只是一维数组中每个元素的长度不确定
    * 第三种定义格式
        *      int[][] arr = {{1,2},{3,4,5,6},{7,8,9}};
        *      每个一维数组用大括号,不是小括号,别忽视了
        *      二维数组中定义了三个元素，这三个元素都是数组，分别为{1,2}、{3,4,5,6}、{7,8,9}
</code></pre><h3 id="2-二维数组元素的访问"><a href="#2-二维数组元素的访问" class="headerlink" title="2. 二维数组元素的访问"></a>2. 二维数组元素的访问</h3><pre><code> * 案例:
  class ArrayDemo08 {
    public static void main(String[] args){

        //定义二维数组的方式
        int[][] arr = new int[3][4];
        System.out.println( arr );
        System.out.println(&quot;二维数组的长度: &quot; + arr.length);
        //获取二维数组的3个元素
        System.out.println( arr[0] );
        System.out.println( arr[1] );
        System.out.println( arr[2] );

        System.out.println(&quot;打印第一个一维数组的元素值&quot;);
        System.out.println( arr[0][0] );
        System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素
        System.out.println( arr[0][2] );
        System.out.println( arr[0][3] );

        System.out.println(&quot;打印第二个一维数组的元素值&quot;);
        System.out.println( arr[1][0] );
        System.out.println( arr[1][1] );
        System.out.println( arr[1][2] );
        System.out.println( arr[1][3] );

        System.out.println(&quot;打印第三个一维数组的元素值&quot;);
        System.out.println( arr[2][0] );
        System.out.println( arr[2][1] );
        System.out.println( arr[2][2] );
        System.out.println( arr[2][3] );
    }
}
</code></pre><h3 id="3-二维数组内存图"><a href="#3-二维数组内存图" class="headerlink" title="3. 二维数组内存图"></a>3. 二维数组内存图</h3><pre><code>* 举例:int[][] arr = new int[3][2];
* 外层数组在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值
* 每一个大内存空间里又开辟连续的两个小的内存空间.
</code></pre><p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170112/095418411.png" alt=""></p>
<h3 id="4-二维数组的定义和访问"><a href="#4-二维数组的定义和访问" class="headerlink" title="4. 二维数组的定义和访问"></a>4. 二维数组的定义和访问</h3><pre><code>* 定义
    * 格式1: 
         int[][] arr = new int[3][]; 不推荐
    * 格式2
      int[][] arr = {{1,2,4},{4,7},{0,9,3}};       
* 访问
      举例:int[][] arr = {{1,2,4},{5,8,7},{0,9,3}};  
     想要打印数组中7这个元素需要先找到大的元素索引{5,8,7} 索引为1 ,在找7在{5,8,7}中的索引2
     那么结果为 arr[1][2]  [1]代表大数组中{5,8,7}这个元素索引,[2]代表{5,8,7}中7元素的索引
</code></pre><h3 id="5-二维数组的遍历"><a href="#5-二维数组的遍历" class="headerlink" title="5. 二维数组的遍历"></a>5. 二维数组的遍历</h3><pre><code>* 二维数组遍历
   int[][] arr = {{1,2,4},{4,7},{0,9,3}};
     先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组
   再外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素

*    举例
  public class ArrayArrayDemo_2{
      public static void main(String[] args){
          int[][] arr = { {1,2,3},{4,5},{6,7,8,9},{0} };

          //外循环,遍历二维数组
          for(int i = 0 ; i &lt; arr.length ;i++){
              //内循环,遍历每个一维数组 arr[0] arr[1] arr[i]
              //注意内层for的条件是,j&lt; 每个一维数组的长度
              for(int j = 0 ; j &lt; arr[i].length; j++){
                  System.out.print(arr[i][j]);
              }
              System.out.println();
          }
      }

* 累加求和
 class ArrayDemo09 {
      public static void main(String[] args){
            int[][] arr2 = { {1,2},{3,4,5},{6,7,8,9,10} };
          int sum2 = 0;
          for (int i=0; i&lt;arr2.length; i++) {
              for (int j=0; j&lt;arr2[i].length; j++) {
                   //System.out.println(arr2[i][j])
                  sum2 += arr2[i][j];
              }
          }
          System.out.println(&quot;sum2= &quot;+ sum2);
      }
  }
</code></pre><h3 id="6-二维数组的求和练习"><a href="#6-二维数组的求和练习" class="headerlink" title="6. 二维数组的求和练习"></a>6. 二维数组的求和练习</h3><pre><code>* 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示
   * 第一小组销售额为{11, 12}万元
   * 第二小组销售额为{21, 22, 23}万元
   * 第三小组销售额为{31, 32, 33, 34}万元。

* 代码实现
      public class ArrayDemo10 {
        public static void main(String[] args) {
            int[][] arr = new int[3][];             // 定义一个长度为3的二维数组
           arr[0] = new int[] { 11, 12 };             // 为数组的元素赋值
            arr[1] = new int[] { 21, 22, 23 };
            arr[2] = new int[] { 31, 32, 33, 34 };        
            int sum = 0;                             // 定义变量记录总销售额
            for (int i = 0; i &lt; arr.length; i++) { // 遍历数组元素
                int groupSum = 0; // 定义变量记录小组销售总额
                for (int j = 0; j &lt; arr[i].length; j++) { // 遍历小组内每个人的销售额
                    groupSum = groupSum + arr[i][j];
                }
                sum = sum + groupSum;             // 累加小组销售额
                System.out.println(&quot;第&quot; + (i + 1) + &quot;小组销售额为：&quot; + groupSum + &quot; 万元&quot;);
            }
            System.out.println(&quot;总销售额为: &quot; + sum + &quot; 万元&quot;);
        }
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一维数组&quot;&gt;&lt;a href=&quot;#一维数组&quot; class=&quot;headerlink&quot; title=&quot;一维数组&quot;&gt;&lt;/a&gt;一维数组&lt;/h2&gt;&lt;h3 id=&quot;1-数组概述&quot;&gt;&lt;a href=&quot;#1-数组概述&quot; class=&quot;headerlink&quot; title=&quot;1. 数组概述&quot;&gt;&lt;/a&gt;1. 数组概述&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* 数组是指一组数据的集合，数组中的每个数据被称作元素。
* 特点:
    (1)在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。
    (2)长度固定
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础语法" scheme="https://geekhoon.github.io/tags/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>06.流程控制语句</title>
    <link href="https://geekhoon.github.io/2017/01/10/06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>https://geekhoon.github.io/2017/01/10/06-流程控制语句/</id>
    <published>2017-01-10T02:29:14.000Z</published>
    <updated>2017-01-11T10:46:01.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-选择结构if"><a href="#一-选择结构if" class="headerlink" title="一. 选择结构if"></a>一. 选择结构if</h2><h3 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1. if语句"></a>1. if语句</h3><pre><code>* 书写格式
    if(比较表达式) {
        语句体;
    }
* 执行流程
    * 先计算比较表达式的值，看其返回值是true还是false。
    * 如果是true，就执行语句体；
    * 如果是false，就不执行语句体；
* 注意:如果写成这样:
    if(比较表达式); {
        语句体;
    }
    加上分号&quot;;&quot; ,则代表if语句已经结束,大括号内的内容不管if的比较表达式true或false都会执行
</code></pre><a id="more"></a>
<h3 id="2-if…else语句"><a href="#2-if…else语句" class="headerlink" title="2. if…else语句"></a>2. if…else语句</h3><pre><code>* 书写格式
    if(比较表达式) {
        语句体1;
    }else {
        语句体2;
    }
* 执行流程
    * 首先计算比较表达式的值，看其返回值是true还是false。
    * 如果是true，就执行语句体1；
    * 如果是false，就执行语句体2；
</code></pre><h3 id="3-if…else-if…else语句"><a href="#3-if…else-if…else语句" class="headerlink" title="3. if…else if…else语句"></a>3. if…else if…else语句</h3><pre><code>* 适合在程序中,实现多条件的判断
* 书写格式 
    if(比较表达式1) {
        语句体1;
    }else if(比较表达式2) {
        语句体2;
    }else if(比较表达式3) {
        语句体3;
    }
    ...
    else {
        语句体n+1;
    }
* 执行流程
    * 首先计算比较表达式1看其返回值是true还是false，
    * 如果是true，就执行语句体1，if语句结束。
    * 如果是false，接着计算比较表达式2看其返回值是true还是false，
    * 如果是true，就执行语句体2，if语句结束。
    * 如果是false，接着计算比较表达式3看其返回值是true还是false，
    * 如果都是false，就执行语句体n+1。
* 案例代码
    public class IfElseIfDemo{
        public static void main(String[] args){
            //成绩判断要求 ,成绩&gt;80  成绩&gt;70  成绩&gt;60  不及格
            //定义变量,保存成绩
            int grade = 75;
            //使用if else if 语句对成绩判断
            if( grade &gt; 80 ){
                System.out.println(grade+&quot; 成绩是优&quot;);
            }else if ( grade &gt; 70){
                System.out.println(grade+&quot; 成绩是良&quot;);
            }else if ( grade &gt; 60){
                System.out.println(grade+&quot; 成绩是中&quot;);
            }else{
                System.out.println(grade+&quot; 成绩是差&quot;);
            }

        }
    }
* 注意: 只要有1个if的条件是true,其他的代码,不再执行
</code></pre><h3 id="4-if语句和三元运算符的互换"><a href="#4-if语句和三元运算符的互换" class="headerlink" title="4. if语句和三元运算符的互换"></a>4. if语句和三元运算符的互换</h3><pre><code>* 使用if语句还是三元表达式
    * 判断条件多,使用if
     * 三元,必须有结果的, if 可以没有结果的
* 三元运算符可以转换为if,但if不一定能转换为三元
* 案例代码
    public class IfElseDemo_1{
        public static void main(String[] args){
            int i = 15;
            int j = 6;
            //使用if语句,判断出最大值
            if(i&gt;j){
                System.out.println(i+&quot; 是最大值&quot;);
            }else{
                System.out.println(j+&quot; 是最大值&quot;);
            }

            //使用三元运算实现
            int k = i&gt;j ? i : j;
            System.out.println(k+&quot; 是最大值&quot;);
        }
    }
</code></pre><h2 id="二-循环结构"><a href="#二-循环结构" class="headerlink" title="二. 循环结构"></a>二. 循环结构</h2><h3 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1. while循环"></a>1. while循环</h3><pre><code>* 使用格式
     初始化表达式；
     while(条件){
        循环体
     }
* 执行顺序     
    当条件是true,就执行循环体,执行完循环体后
    程序再次执行while中的条件,如果条件还是true,继续执行循环体
    直到条件是false的时候,循环就结束        
</code></pre><h3 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h3><pre><code>* 使用格式
    for(初始化表达式 ; 条件表达式 ; 循环后操作表达式){
            循环体;
    }

* 执行流程
    for（① ; ② ; ③）{
        ④
    }
    第一步，执行①,①终身只执行一次
    第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步
    第三步，执行④
    第四步，执行③，然后重复执行第二步
    第五步，退出循环

* for与while循环:
    1.for与while循环可以相互转换,但不建议转换
    2.for循环中的初始化表达式中变量的作用范围只在for语句中有效
    3.while初始化表达式是在while循环上变定义,作用范围大
</code></pre><h3 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3. do_while循环"></a>3. do_while循环</h3><pre><code>* 使用格式
    do{
         循环体;
      }while(条件);//别丢了这个分号
* 执行顺序
    先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体，
    如果条件为false，循环结束。
* 特点
    无条件先执行一次
</code></pre><h3 id="4-死循环"><a href="#4-死循环" class="headerlink" title="4. 死循环"></a>4. 死循环</h3><pre><code>* 概述
    * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环
* 格式
    * while(true){}
    * for(;;){}
    * for(;true;){}
* 注意:无限循环语句后面不允许再写代码,会编译失败.
    * 但不是没有机会执行,当程序满足一定条件(break),可以控制,让死循环停止,执行后面的代码
</code></pre><h3 id="5-嵌套for循环"><a href="#5-嵌套for循环" class="headerlink" title="5. 嵌套for循环"></a>5. 嵌套for循环</h3><pre><code>* 概述
    * 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。
    * while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的,在for循环中嵌套for循环。
* 嵌套循环的格式
    for(初始化表达式; 循环条件; 操作表达式) {
        ………
        for(初始化表达式; 循环条件; 操作表达式) {
            执行语句
            ………
        }
        ………
    }
* 执行顺序:
      1.外循环执行一次,
      2.内循环全部执行完,
      3.回到外循环,外循环继续执行一次
      4.内循环再全部执行完
      5.再回到外循环,重复1到5,直到外循环结束
* 各模块解释
    * 总的循环次数 =  内循环次数 * 外循环的次数
    * 内循环,是外循环的循环体

    * 外循环,控制的是行数
    * 内循环,控制的是每行的个数

* 案例
    *  打印正三角形
    public class ForForDemo{
        public static void main(String[] args){
            for(int i = 0 ; i &lt; 9 ; i++){
                for(int j = 0; j &lt; i+1 ;j++){  //++i
                    System.out.print(&quot;* &quot;);
                }
                System.out.println();
            }
        }
    }
</code></pre><h3 id="6-break语句"><a href="#6-break语句" class="headerlink" title="6. break语句"></a>6. break语句</h3><pre><code>* 作用
    * 跳出当前所在的循环体
* 应用环境
    * 只能应用在循环语句和switch语句中
 * 注意
    * 如果写在循环嵌套的内循环,结束的是内循环.除非在外循环前面加上循环标号,然后break 循环标号;
* 举例
        {
            for(int i=0; i&lt;10; i++) {
                if(i&gt;5) {
                break;
                }
            System.out.println(“我爱Java”+i);
            }
        }
        //会从0-5输出6次“我爱Java”
* break详细解释
    * a: 作用
        * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中，
            可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码，
            这些关键字一旦出现就可以跳转语句执行顺序。
    * b: 使用方式
        * 无法单独使用，必须将break关键字置于switch或循环语句中
    * c: 运行规律
        * 不需要判断任何条件，只要遇到break便直接跳出执行后续代码。会完全跳出选择或者循环结构
        * 只能跳出最近的代码块，不能跨越多级代码块

* 循环标号
    * a: 为什么使用循环标号
        * 当在双层循环或者循环内有switch选择语句时，我们发现，使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了.
    * b: 使用方式
        * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。
          使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可
    * c: 运行规律
        * 当外层循环外定义了标号
          内层使用break，终止内外双层循环。
          内层使用continue，终止内层循环，继续外层循环。
</code></pre><h3 id="6-continue语句"><a href="#6-continue语句" class="headerlink" title="6. continue语句"></a>6. continue语句</h3><pre><code>* 作用
    * 提前结束本次循环，继续进行下次循环
* 应用环境
    * 无法单独使用，只能应用于循环中
* 运行规律
    * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环
* 案例代码
        public class ContinueDemo{
            public static void main(String[] args){
                for(int i = 0 ; i &lt; 10 ; i++){
                    if(i%2==0){
                        continue;
                    }
                    System.out.println(i);
                }
            }
        }
        //会把0-9之间所有的奇数打印到控制台上
</code></pre><h3 id="7-switch语句"><a href="#7-switch语句" class="headerlink" title="7. switch语句"></a>7. switch语句</h3><pre><code>* switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。    
* 格式:
          swtich(表达式){
              case 常量1 :
                要执行的语句;
              break;

              case 常量2 :
                要执行的语句;
              break;

              case 常量3 :
                要执行的语句;
              break;

              default:
                要执行的语句;
              break;
          }
* 执行流程:  表达式,和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,遇到break,就全结束.若都不匹配,执行default 
* 关键字: switch case default break
* 特别注意:
    1. case后,必须是常量
    2. 常量后,有冒号
    3. 要执行的语句可以是多条语句,包括循环都可以写
</code></pre><h3 id="8-switch语句接收的数据类型"><a href="#8-switch语句接收的数据类型" class="headerlink" title="8. switch语句接收的数据类型"></a>8. switch语句接收的数据类型</h3><pre><code>* switch语句中的表达式的数据类型,是有要求的

        JDK1.0 - 1.4  数据类型接受 byte short int char
        JDK1.5   数据类型接受 byte short int char enum(枚举)
        JDK1.7   数据类型接受 byte short int char enum(枚举), String    
</code></pre><h3 id="9-case穿透"><a href="#9-case穿透" class="headerlink" title="9. case穿透"></a>9. case穿透</h3><pre><code>* case穿透
    * a: 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。
    * b: 例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。
* 举例:
    * public class SwitchDemo{
            public static void main(String[] args){
                int week = 2;
                    switch(week){
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            System.out.println(&quot;工作日&quot;);
                        break; //(1)
                        case 6:
                        case 7:
                            System.out.println(&quot;休息日&quot;);
                        break;
                    }
            }
        }
        //因为week=2,从case 2开始穿透,直到碰到break或switch的右大括号,
        //如果(1)处没有break,继续穿透
        //穿透期间,不会再判断case后面的值,还会执行case中的执行语句,即使default在中间,只要没有break,就继续穿透
    *int x = 2;
     int y = 3;
    switch(x){
        default:
            y++;
        break;
        case 3:
            y++;
        case 4:
            y++;
        }
    System.out.println(&quot;y=&quot;+y);
    //执行顺序: x=2先到case 3,不成立,到case 4,不成立,到了default,执行y++,break结束,输出y=4
    //把default中的break删掉,执行顺序:case 3不成立,case 4不成立,default,执行y++,y=4了,穿透case3,执行y++,又穿透case 4,执行y++
    //最后y=6

* 注意:
    1. default中一定要有break吗?
        //不一定,程序只要遇到break或者switch的右大括号,都结束
    2. 多个case后的常量可否相同?
        //不可以
    3. default一定要放在case之后吗?
        //不一定.不管放在哪,switch执行次序不变,都是从第一个case开始
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-选择结构if&quot;&gt;&lt;a href=&quot;#一-选择结构if&quot; class=&quot;headerlink&quot; title=&quot;一. 选择结构if&quot;&gt;&lt;/a&gt;一. 选择结构if&lt;/h2&gt;&lt;h3 id=&quot;1-if语句&quot;&gt;&lt;a href=&quot;#1-if语句&quot; class=&quot;headerlink&quot; title=&quot;1. if语句&quot;&gt;&lt;/a&gt;1. if语句&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* 书写格式
    if(比较表达式) {
        语句体;
    }
* 执行流程
    * 先计算比较表达式的值，看其返回值是true还是false。
    * 如果是true，就执行语句体；
    * 如果是false，就不执行语句体；
* 注意:如果写成这样:
    if(比较表达式); {
        语句体;
    }
    加上分号&amp;quot;;&amp;quot; ,则代表if语句已经结束,大括号内的内容不管if的比较表达式true或false都会执行
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础语法" scheme="https://geekhoon.github.io/tags/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>05.引用数据类型</title>
    <link href="https://geekhoon.github.io/2017/01/10/05-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://geekhoon.github.io/2017/01/10/05-引用数据类型/</id>
    <published>2017-01-10T02:28:36.000Z</published>
    <updated>2017-01-10T04:00:22.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-创建引用类型变量公式"><a href="#1-创建引用类型变量公式" class="headerlink" title="1.创建引用类型变量公式"></a>1.创建引用类型变量公式</h3><pre><code>* 引用数据类型的定义格式:
    数据类型  变量名  =  new 数据类型();
* 引用数据类型的使用:
    * 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。
    * 变量名.方法名();
</code></pre><a id="more"></a>
<h3 id="2-Scanner类的使用"><a href="#2-Scanner类的使用" class="headerlink" title="2.Scanner类的使用"></a>2.Scanner类的使用</h3><pre><code>* 作用: 在命令行中,接收键盘的输入
* 使用:
    (1) 导包   import java.util.Scanner;
    (2) 创建Scanner对象的变量 Scanner sc = new Scanner(System.in);
    (3) 读取键盘录入的一个整数
          int enterNumber = sc.nextInt();
    (4) 读取键盘录入的字符串,注意字符串不能有空格或tab
          String enterString = sc.next();
* 案例代码
    import java.util.Scanner;//特别注意:后面有分号,别丢掉
    public class Demo05Scanner{
        public static void main(String[] args) 
        {
            Scanner sc = new Scanner(System.in);

            int enterNumber = sc.nextInt();
            System.out.println(&quot;用户输入的整数为&quot;+enterNumber);

            String enterString = sc.next();
            System.out.println(&quot;用户输入的字符串为&quot;+enterString);
        }
    }            
</code></pre><h3 id="3-Random随机数类的使用"><a href="#3-Random随机数类的使用" class="headerlink" title="3.Random随机数类的使用"></a>3.Random随机数类的使用</h3><pre><code>* 作用: 生成随机数
* 使用:
    (1) import导包：所属包java.util. Random
    (2) 创建Random对象的变量：Random  random = new Random ();
    (3) 调用方法:
        * nextInt(int maxValue)    产生[0,maxValue)范围的随机数,包含0不包含maxValue
        * nextDouble()  //产生0.0-1.0之间的数(包括0.0不包括1.0)
        如：
            Random  random = new Random ();
            int  myNumber = random.nextInt(100);//结果为0-99的一个数
* 随机数,也叫伪随机数,它是JVM根据人写好的算法,生成的
* 案例代码
    import java.util.Random;
    public class RandomDemo{
        public static void main(String[] args){
           Random ran = new Random();
           // Random类中的,产生随机数的功能
           int i = ran.nextInt(100);
           System.out.println(i);  
           //问题? 产生随机数,范围 1-100之间
           // nextInt(100) 0-99 + 1
        }
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建引用类型变量公式&quot;&gt;&lt;a href=&quot;#1-创建引用类型变量公式&quot; class=&quot;headerlink&quot; title=&quot;1.创建引用类型变量公式&quot;&gt;&lt;/a&gt;1.创建引用类型变量公式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* 引用数据类型的定义格式:
    数据类型  变量名  =  new 数据类型();
* 引用数据类型的使用:
    * 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。
    * 变量名.方法名();
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础语法" scheme="https://geekhoon.github.io/tags/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础题目答案</title>
    <link href="https://geekhoon.github.io/2017/01/09/%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE%E7%AD%94%E6%A1%88/"/>
    <id>https://geekhoon.github.io/2017/01/09/基础题目答案/</id>
    <published>2017-01-09T12:40:31.000Z</published>
    <updated>2017-01-12T07:35:16.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><pre><code>1. JAVA语言中的字符char可以存储一个中文汉字吗?原因?
   *可以.因为Java中字符占两个字节.一个中文汉字也占两个字节
   *Java采用的是Unicode编码
</code></pre><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><pre><code>1. 请写出该输出语句的结果     

* hello98
   *因为括号的优先级,(&apos;a&apos;+1)中的&quot;+&quot;依然执行加法,所以字符型根据Ascii转成97,第一个&quot;+&quot;为连接
*若本题改成System.out.println(&quot;hello&quot;+&apos;a&apos;+1);
   *输出helloa1,两个+都是连接,有误区会输出hello&apos;a&apos;1,这是不对的,因为单引号只是证明a为字符型,输出还是要输出字符的值

 2. 请分别计算出a,b,c的值?  
      16  16  15

 3. 分析以下需求，并用代码实现： 
     public class Test{
            public static void main(String[] args){
                int num = 123;
                int ge = num % 10;
                int shi = num / 10 % 10;
                int bai = num / 100 % 10;
                System.out.println(&quot;数字&quot;+num+&quot;的个位数是 &quot;+ge+&quot;,十位数是 &quot;+shi+&quot;,百位数是 &quot;+bai);        
            }
     } 
</code></pre><h3 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3.流程控制语句"></a>3.流程控制语句</h3><pre><code>1.(1)质数解法一:
public class Prime{
     public static void main(String[] args){
    //定义一个计数变量
    int count = 0;
    //遍历1-100之间的整数
    for(int i = 1;i &lt;= 100;i++){
        //分别让i % (2-----i-1),如果==0,就不是质数
        int j = 2;
        for( ;j &lt; i;j++){
            if(i % j == 0){
    //当%j == 0,立刻跳出循环,判断j的值,如果i==j的值,说明i是质数
    //如果不等,说明i % (比i小的数)== 0,则i不是质数
                break;
            }
        }
        if(i == j){
            System.out.print(i+&quot; &quot;);
            count++;
            if(count % 5 == 0){
                System.out.println();    
            }
        }
    }
    System.out.println(&quot;质数总数是: &quot;+count);
    }
}

1.(2)质数解法二:

public class Prime{
    public static void main(String[] args){
    //定义一个计数变量
    int count = 0;
    //遍历2-100之间的整数,不从1遍历的原因是定义flag为true,默认都是质数,1不经过内层for,所以依然被认为是质数,所以要从2开始
    for(int i = 2;i &lt;= 100;i++){
        //默认都是质数
        //思考?把boolean flag = true;放在for外边,会怎样?
        boolean flag = true;
        for(int j = 2;j &lt; i;j++){
            if(i % j == 0){
        //不满足质数条件,break 
        //会有疑问?为什解法一在判断i==j,这里i==j,i % j==0,不就把质数整成false
        //其实,当j==i时,内层for条件已经不成立了,直接执行if(flag)了
                flag = false;
                break;
            }    
        }
        //flag为true,就是质数
        if(flag){
            System.out.print(i+&quot; &quot;);
            count++;
            if(count % 5 == 0){
                System.out.println();    
            }
        }

    }
    System.out.println(&quot;质数总数是: &quot;+count);
    }
}
2. 珠峰
public class ZhuFeng{
    public static void main(String[] args){
        int high = 8848;
        double hou = 0.01;
        int count = 0;
        while(hou &lt; high){
            hou *= 2;
            count++;
        }
        System.out.println(&quot;折叠&quot;+count+&quot;次&quot;);
    }    
} 
3.  打印非9    
       解法一:
public class DaYin9{
    public static void main(String[] args){
        int count = 0;
        for(int i = 1;i &lt;= 100;i++){
            if(i/10==9 || i%10==9){
                continue;
            }
            System.out.print(i+&quot; &quot;);
            count++;
            if(count % 5==0){
            System.out.println();
            }
        }
    }
}

       解法二:
public class Test3{
    public static void main(String[] args){
        // 1. 定义四个变量
        int ge, shi, bai, count=0;
        // 2.获取数据1-100 for循环
        for(int num=1; num&lt;=100; num++){
        // 3. 获取数据中的所有位数(个位、十位、百位)
            ge = num % 10;
            shi = num / 10 % 10;
            bai = num / 100;
        // 判断每个位数上边的数字是否与7相等
            if(ge==7 || shi==7 || bai==7){
                continue;
            }
                count++;
            System.out.print(num + &quot; &quot;);
            if(count % 5 == 0){
                System.out.println();
            }
        }
    }
}

4. 九九乘法表
public class JiuJiu{
    public static void main(String[] args){
        for(int i = 1;i &lt;= 9;i++){
            for(int j = 1;j &lt;= i;j++){
                int ji = j * j;
                System.out.print(j+&quot;*&quot;+j+&quot;=&quot;+ji+&quot;  &quot;);
            }
            System.out.println();
        }
    }
}
</code></pre><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h3><pre><code>1. 
public class Change{
    public static void main(String[] args){
        int[] arr = {6,2,9,15,1,5,20,7,18};
    //本题的关键是找到最大,最小元素的索引位置,而不是找到最大最小值,只要知道位置了,就可以进行交换了
        //定义max,min,记录最大元素和最小元素的索引位置
        int max = 0,min = 0;
        for(int i = 0;i &lt; arr.length;i++){
            if(arr[max] &lt; arr[i]){
                max = i;
            }
            if(arr[min] &gt; arr[i]){
                min = i;
            }
        }
        for(int i = 0; i &lt;arr.length;i++){
            System.out.print(arr[i]+&quot; &quot;);
        }
        System.out.println();
        //通过arr[max]和arr[min]可以取到了最大,最小值,定义一个第三方变量,用于交换
        int temp = arr[max];
        arr[max] = arr[arr.length-1];
        arr[arr.length-1] = temp;
        //
        temp = arr[min];
        arr[min] = arr[0];
        arr[0] = temp;
        //
        for(int i = 0; i &lt;arr.length;i++){
            System.out.print(arr[i]+&quot; &quot;);
        }    
    }    
}

2. 
import java.util.Scanner;
public class Test01{
    public static void main(String[] args){
    //1.利用一个for循环,录入用户输入的6个数据,置于数组中
        Scanner sc = new Scanner(System.in);
        int[] arr = new int[6];
        for(int i = 0;i &lt; 6;i++){
            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个整数:&quot;);
            arr[i] = sc.nextInt() ;
        }
    //2.实现反转
        for(int start = 0,end = arr.length-1;start &lt; end;start++,end--){
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
        }
    //3.将翻转后的数组角标为奇数的互相交换 1和3换, 3和5换,以此类推
        for(int i = 1,j =3;i &lt; arr.length &amp;&amp; j &lt; arr.length;i+=2,j+=2){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    //4.最后将数组最后一个角标为奇数的元素 和数组中第一个角标为奇数的元素交换
    //判断最后一个角标为奇数,需要先知道数组长度,根据数组长度的奇偶性,最后一个角标为奇数的索引不同
        int lastIndex = (arr.length % 2 == 0 ? arr.length-1 : arr.length-2);
        int temp = arr[1];
        arr[1] = arr[lastIndex];
        arr[lastIndex] = temp;
    //
        for(int i = 0;i &lt; arr.length;i++ ){
            System.out.print(arr[i]+&quot; &quot;);
        }
        System.out.println();    
    }
}
</code></pre><p>图解反转:</p>
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170111/233540781.bmp" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1.数据类型&quot;&gt;&lt;/a&gt;1.数据类型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. JAVA语言中的字符char可以存储一个中文汉字吗?原因?
   *可以.因为Java
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="题目" scheme="https://geekhoon.github.io/tags/%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>基础题目</title>
    <link href="https://geekhoon.github.io/2017/01/09/%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/"/>
    <id>https://geekhoon.github.io/2017/01/09/基础题目/</id>
    <published>2017-01-09T12:40:20.000Z</published>
    <updated>2017-01-11T15:42:00.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><pre><code>1. JAVA语言中的字符char可以存储一个中文汉字吗?原因?
</code></pre><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><pre><code>1. 请写出该输出语句的结果

System.out.println(&quot;hello&quot;+(&apos;a&apos;+1));

2. 请分别计算出a,b,c的值?  
        int a = 15;
        int b = 15;
        int c = 15;

        a = ++b;        
        c = a--;            
        b = ++a;        
        a = c--;
3. 分析以下需求，并用代码实现：  
    (1)已知一个三位数，请分别获取该三位数上每一位的数值
    (2)例如：123的个位、十位、百位，分别是3、2、1
    (3)打印格式&quot;数字123的个位是 3, 十位是 2, 百位是 1&quot;
</code></pre><h3 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3.流程控制语句"></a>3.流程控制语句</h3><pre><code>1. 计算1-100之间的质数有多少个？将质数以及质数总数打印在控制台。每5个数换行

2. 我国最高山峰是珠穆朗玛峰，8848米。现在我有一张足够大的纸，它的厚度是0.01米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度。

3. 分析以下需求，并用代码实现：
    打印1到100之内的整数，但数字中包含9的要跳过
    每行输出5个满足条件的数，之间用空格分隔。如：1 2 3 4 5 

4. 利用嵌套循环，在控制台打印九九乘法表
</code></pre><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h3><pre><code>1. 分析以下需求，并用代码实现：
    (1)定义一个int类型的一维数组，内容为{6,2,9,15,1,5,20,7,18}
    (2)将数组最大元素与最后一位元素进行交换,最小元素与第一位元素进行交换，并打印数组

2. 分析以下需求，并用代码实现：
    (1)键盘录入6个int类型的数据存数数组arr中
    (2)将arr数组中的内容反转
    (3)将翻转后的数组角标为奇数的互相交换 1和3换, 3和5换,以此类推
    (4)最后将数组最后一个角标为奇数的元素 和数组中第一个角标为奇数的元素交换
    (5)打印最终的数组(实现了1-4步之后的数组)
    (6)如：用户输入的6个int数字为[1,2,3,4,5,6],最后输出的结果为[6, 5, 4, 1, 2, 3]
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1.数据类型&quot;&gt;&lt;/a&gt;1.数据类型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. JAVA语言中的字符char可以存储一个中文汉字吗?原因?
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="题目" scheme="https://geekhoon.github.io/tags/%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>常用快捷键</title>
    <link href="https://geekhoon.github.io/2017/01/09/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://geekhoon.github.io/2017/01/09/常用快捷键/</id>
    <published>2017-01-09T09:50:28.000Z</published>
    <updated>2017-01-10T14:54:04.737Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Dos"><a href="#1-Dos" class="headerlink" title="1.Dos"></a>1.Dos</h3><pre><code>* Shift + 右键    : 当前文件夹下打开dos
* Tab             : 注意dos下,&quot;Tab键&quot;的使用,可方便输入
* 标记 + 右键/回车 : dos下复制
* &quot;↑&quot;和&quot;↓&quot;        : dos未关闭前提下,使用之前的命令
* 复制路径后,dos下右键,可以粘贴
* Ctrl + c        :强行停止命令行
</code></pre><a id="more"></a>
<h3 id="2-notepad"><a href="#2-notepad" class="headerlink" title="2.notepad++"></a>2.notepad++</h3><pre><code>* Ctrl + D           : 复制该行
* Ctrl + Shift + ↑/↓ :移动该行
* Ctrl + L           : 删除该行
* shift + Tab        :选中部分整体左移
* tab                 :选中部分整体右移
</code></pre><h3 id="3-xmind"><a href="#3-xmind" class="headerlink" title="3.xmind"></a>3.xmind</h3><pre><code>* Tab : 新建分支
*  F4 : 添加备注
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Dos&quot;&gt;&lt;a href=&quot;#1-Dos&quot; class=&quot;headerlink&quot; title=&quot;1.Dos&quot;&gt;&lt;/a&gt;1.Dos&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* Shift + 右键    : 当前文件夹下打开dos
* Tab             : 注意dos下,&amp;quot;Tab键&amp;quot;的使用,可方便输入
* 标记 + 右键/回车 : dos下复制
* &amp;quot;↑&amp;quot;和&amp;quot;↓&amp;quot;        : dos未关闭前提下,使用之前的命令
* 复制路径后,dos下右键,可以粘贴
* Ctrl + c        :强行停止命令行
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技巧" scheme="https://geekhoon.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://geekhoon.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>04.运算符</title>
    <link href="https://geekhoon.github.io/2017/01/08/04-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://geekhoon.github.io/2017/01/08/04-运算符/</id>
    <published>2017-01-08T01:58:55.000Z</published>
    <updated>2017-01-09T16:12:51.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h3><pre><code>* 注意事项
    1.&quot;+&quot;加法运算符,在连接字符串时要注意，只有直接与字符串相加才会转成字符串.字符串后面的&quot;+&quot;为&quot;连接&quot;,字符串前面的&quot;+&quot;还是加法
        如:
            System.out.println(5+5+&quot;=&quot;+5+5);这个输出的是10=55
    2.&quot;/&quot;除法运算符,整数与整数除,结果为整数;整数与小数除,结果是小数类型
    3.&quot;%&quot;取模,取余运算符
              -5  % 5 = 0;
              -10 % 5 = 0;
              -7  % 5 = -2;
               10 % 5 = 0;
               2  % 5 = 2;
              -2  % 5 = -2;
        结论:
        (1)正负符号位取得是左边,与右边无关
        (2)如果左边的绝对值是右边绝对值的整数倍,结果为0
        (3)如果左边的绝对值大于右边的绝对值,结果为余数(正常取余就行,注意正负号)
        (4)如果左边的绝对值小于右边的绝对值,结果为左边
        (5)任何一个整数%2,结果不是0就是1,可以用来当作切换条件

* ++和--放前放后区别:
    *符号放前放后,在变量自己独立计算时,没有区别
    *在与其他运算符同时计算时会有区别             
     如：
                int  i = 5;
                int  j = i++;
                System.out.println(i);
                System.out.println(j);
                //结果为i=6,j=5.
                //因为int  j = i++;相当于(1)int j = i;
                                        (2)i++;
     如：
                int  m = 5;
                int  n = ++m;
                System.out.println(m);
                System.out.println(n);
                //结果为m=6,n=6.
                //因为int  n = ++m;相当于(1)++m;

     如：
            public class Test1 {
                public static void main(String[] args) {
                     int x = 4;
                     int y = (--x)+(x--)+(x*10);
                     System.out.println(&quot;x = &quot; + x + &quot;,y = &quot; + y);
                }
            }
            思维误区:不要以为(--x)+(x--)+(x*10),都有各自括号,就互不影响,执行完(--x),x为3,再执行(x--)后,x为2,(x*10)为20,所以输出x为2,但是y=3+3+20=26,第二个3是因为先赋值,再自减
    如：
            public class Test2{
                public static void main(String[] args){
                    int a = 1;
                    if(a++ &gt; 1){
                        System.out.println(&quot;用2在判断&quot;);
                    }else{
                        System.out.println(&quot;用1在判断&quot;);
                    }
                    System.out.println(&quot;a=&quot;+a);
                }
            }
            本题证明了(a++ &gt; 1)是用a=1与1做大小判断,而不是2,说明a先比较,再自增.但最终输出a的大小都是2
</code></pre><a id="more"></a>
<h3 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h3><pre><code>* 有 =  +=  -=  *=  /=  %=  
* 注意:
     如：
                byte  b = 1;               (1)
                b = b + 1;                 (2)
                System.out.println(b);     (3)
                编译会报错,因为(1)中b为byte型,占1个字节,(2)中1为int类型,占4个字节,它们相加之后,是4字节.然后赋值给1字节大小的b,会损失精度.
                将(2)改成b =(byte) (b + 1);或者b += 1;都对.这两句等价
</code></pre><h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3.比较运算符"></a>3.比较运算符</h3><pre><code>* 也叫关系运算符
* 有 ==  !=  &gt;  &lt;  &gt;=  &lt;=  
* 注意:
     如：
                int  i = 3;
                int  j = 4;
                System.out.println(i=j);
                System.out.println(i==j);
                结果分别为4和true,因为程序自上而下执行,第一句输出语句执行完之后,i变为4.别忽视了输出语句中,赋值语句对变量在整个作用区间内也起作用.
</code></pre><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h3><pre><code>* 对两个布尔数据进行计算,结果也是布尔类型
* 有 &amp;与  |或  !非  ^异或  &amp;&amp;短路与  ||短路或
    *^异或: 两边相同为false,不同为true
     如：
                true^flase 为    true 
                true^true  为   false
    *&amp;&amp;短路与: 左边结果为false,右边不执行
     如：
                int  i = 3;
                int  j = 4;
                System.out.println(i == j &amp;&amp; ++i &gt; 3);
                System.out.println(i);
                System.out.println(j);
                结果为3和4.   i == j 为flase, 所以++i &gt; 3并没有执行
    *||短路或: 左边结果为true,右边不执行
* 短路与 和 短路或 可以提高程序运行效率
</code></pre><h3 id="5-三元-目-运算符"><a href="#5-三元-目-运算符" class="headerlink" title="5.三元(目)运算符"></a>5.三元(目)运算符</h3><pre><code>* 公式:    布尔表达式 ? 结果1 : 结果2
*注意:这里的结果1和2,不能是输出语句,必须是确定的结果
</code></pre><h3 id="6-运算符优先级"><a href="#6-运算符优先级" class="headerlink" title="6.运算符优先级"></a>6.运算符优先级</h3><pre><code>优先级    描述          运算符
1    括号           ()、[]
2    正负号           +、-
3    自增自减，非     ++、--、!
4    乘除，取余      *、/、%
5    加减            +、-
6    移位运算       &lt;&lt;、&gt;&gt;、&gt;&gt;&gt;
7    大小关系       &gt;、&gt;=、&lt;、&lt;=
8    相等关系       ==、!=
9    按位与            &amp;
10    按位异或       ^
11    按位或            |
12    逻辑与            &amp;&amp;
13    逻辑或            ||
14    条件运算        ?:
15    赋值运算        =、+=、-=、*=、/=、%=
16    位赋值运算       &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-算数运算符&quot;&gt;&lt;a href=&quot;#1-算数运算符&quot; class=&quot;headerlink&quot; title=&quot;1.算数运算符&quot;&gt;&lt;/a&gt;1.算数运算符&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* 注意事项
    1.&amp;quot;+&amp;quot;加法运算符,在连接字符串时要注意，只有直接与字符串相加才会转成字符串.字符串后面的&amp;quot;+&amp;quot;为&amp;quot;连接&amp;quot;,字符串前面的&amp;quot;+&amp;quot;还是加法
        如:
            System.out.println(5+5+&amp;quot;=&amp;quot;+5+5);这个输出的是10=55
    2.&amp;quot;/&amp;quot;除法运算符,整数与整数除,结果为整数;整数与小数除,结果是小数类型
    3.&amp;quot;%&amp;quot;取模,取余运算符
              -5  % 5 = 0;
              -10 % 5 = 0;
              -7  % 5 = -2;
               10 % 5 = 0;
               2  % 5 = 2;
              -2  % 5 = -2;
        结论:
        (1)正负符号位取得是左边,与右边无关
        (2)如果左边的绝对值是右边绝对值的整数倍,结果为0
        (3)如果左边的绝对值大于右边的绝对值,结果为余数(正常取余就行,注意正负号)
        (4)如果左边的绝对值小于右边的绝对值,结果为左边
        (5)任何一个整数%2,结果不是0就是1,可以用来当作切换条件

* ++和--放前放后区别:
    *符号放前放后,在变量自己独立计算时,没有区别
    *在与其他运算符同时计算时会有区别             
     如：
                int  i = 5;
                int  j = i++;
                System.out.println(i);
                System.out.println(j);
                //结果为i=6,j=5.
                //因为int  j = i++;相当于(1)int j = i;
                                        (2)i++;
     如：
                int  m = 5;
                int  n = ++m;
                System.out.println(m);
                System.out.println(n);
                //结果为m=6,n=6.
                //因为int  n = ++m;相当于(1)++m;

     如：
            public class Test1 {
                public static void main(String[] args) {
                     int x = 4;
                     int y = (--x)+(x--)+(x*10);
                     System.out.println(&amp;quot;x = &amp;quot; + x + &amp;quot;,y = &amp;quot; + y);
                }
            }
            思维误区:不要以为(--x)+(x--)+(x*10),都有各自括号,就互不影响,执行完(--x),x为3,再执行(x--)后,x为2,(x*10)为20,所以输出x为2,但是y=3+3+20=26,第二个3是因为先赋值,再自减
    如：
            public class Test2{
                public static void main(String[] args){
                    int a = 1;
                    if(a++ &amp;gt; 1){
                        System.out.println(&amp;quot;用2在判断&amp;quot;);
                    }else{
                        System.out.println(&amp;quot;用1在判断&amp;quot;);
                    }
                    System.out.println(&amp;quot;a=&amp;quot;+a);
                }
            }
            本题证明了(a++ &amp;gt; 1)是用a=1与1做大小判断,而不是2,说明a先比较,再自增.但最终输出a的大小都是2
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础语法" scheme="https://geekhoon.github.io/tags/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>03.数据</title>
    <link href="https://geekhoon.github.io/2017/01/08/03-%E6%95%B0%E6%8D%AE/"/>
    <id>https://geekhoon.github.io/2017/01/08/03-数据/</id>
    <published>2017-01-08T01:56:31.000Z</published>
    <updated>2017-01-09T15:55:08.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-数据"><a href="#一-数据" class="headerlink" title="一.数据"></a>一.数据</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><pre><code>* 程序=数据+逻辑
* 数据类型包括 
    * 1.基本数据类型:整数、小数、字符、布尔 
    * 2.引用数据类型:数组、类、接口
</code></pre><h3 id="2-常量"><a href="#2-常量" class="headerlink" title="2.常量"></a>2.常量</h3><pre><code>* 整数类型 
    * 十进制
    * 二进制:以0b(0B)开头,只有0和1  
    * 十六进制:以0x(0X)开头,0-9和A-F,F表示15 
    * 八进制:以0开头,最大数为7
* 小数类型(浮点类型)
* 布尔类型:true和flase为关键字
* 字符类型:单引号中仅能包含一个字符,不能不写字符,可以用一个空格
* 字符串类型:可以写0-n个字符  
</code></pre><a id="more"></a>
<h2 id="二-变量"><a href="#二-变量" class="headerlink" title="二.变量"></a>二.变量</h2><h3 id="1-变量概述"><a href="#1-变量概述" class="headerlink" title="1.变量概述"></a>1.变量概述</h3><pre><code>* 什么是变量?
    * 变量是内存中装载数据的小盒子，你只能用它来存数据和取数据
    * 在程序运行过程中,其值可以发生改变的量
</code></pre><h3 id="2-计算机存储单元"><a href="#2-计算机存储单元" class="headerlink" title="2.计算机存储单元"></a>2.计算机存储单元</h3><pre><code>* 计算机中最小信息单元是?
    * 位(bit),也叫比特位.用b表示
    * 8个位,表示一个数据
* 计算机中储存和运算的最小单位是?
    * 一个字节,也就是一个byte.用B表示            
    * 常用储存单位
        *1B（字节） = 8bit
        *1KB = 1024B
        *1MB = 1024KB
        *1GB = 1024MB
        *1TB = 1024GB
        *1PB = 1024TB
</code></pre><h3 id="3-Java中数据类型四类八种"><a href="#3-Java中数据类型四类八种" class="headerlink" title="3.Java中数据类型四类八种"></a>3.Java中数据类型四类八种</h3><pre><code>* 数据类型四类八种
    * 四类    八种    字节数    数据表示范围
    * 整型    byte    1    -128～127
            short     2    
             int     4    
             long     8    
    * 浮点型    float    4    
              double   8    
    * 字符型    char    2    表示一个字符，如(&apos;a&apos;，&apos;A&apos;，&apos;0&apos;，&apos;家&apos;)
    * 布尔型    boolean    1    只有两个值true与false,默认是false
</code></pre><h3 id="4-常量和数据类型"><a href="#4-常量和数据类型" class="headerlink" title="4.常量和数据类型"></a>4.常量和数据类型</h3><pre><code>* 常量
    * 常量是程序在运行过程中,其值不会发生改变的量
    * 整型常量默认是int类型.
    * 定义长整型数据如果值超过int取值范围后面要+&quot;L&quot;,凡添加了&quot;L&quot;,都是long类型
    * 浮点常量默认是double类型,没有后缀或以&quot;D&quot;为后缀,都是double型
    * 定义float类型的数据后面要+&quot;F&quot; 否则默认是double
* 写法:
    * long l = 1000; 对
    * long l = 12345678901; 错
    * long l = 12345678901L; 对 
    * float f = 1.0; 错
    * float f = 1.0F; 对
</code></pre><h3 id="5-定义变量"><a href="#5-定义变量" class="headerlink" title="5.定义变量"></a>5.定义变量</h3><pre><code>* 语法格式：
    数据类型  变量名  =  变量值;
     int        a    =  100;        
* 代码:
    public class Variable {
        public static void main(String[] args) {
            int a = 10;
            double b = 3.14;
            char c = &apos;z&apos;;
            String s = &quot;i love java&quot;;
            System.out.println(a);
        }
    }    
* 注意:
    a.字符串String属于引用类型(类),不属于基本类型,
    b.变量定义后,不赋值,能编译通过,但运行时会报错.不赋值不能使用。
    c.变量使用时有作用域的限制。(所在的大括号范围内)
    如：
    (1)public class Variable {
           public static void main(String[] args) {
                {
                    int j = 10;
                }
                int j = 10;
       }这是对的,因为第一个j声明的作用区间为它所在的大括号,第二个j再声明,和它就不冲突
    (2)public class Variable {
           public static void main(String[] args) {
                int j = 10;  
                {
                    int j = 10;
                }
     }这是错的,因为第一个j声明的作用区间为它所在的大括号,即整个main方法,第二个j再在main方法中声明,就产生了冲突
    d.变量不允许重复定义
</code></pre><h3 id="6-数据类型转换"><a href="#6-数据类型转换" class="headerlink" title="6.数据类型转换"></a>6.数据类型转换</h3><pre><code>* 自动类型转换：(也叫自动类型提升,或叫隐式转换)
    *取值范围小的与取值范围大的数据数据类型做运算时,取值范围小的类型会自动提升为取值范围大的数据类型
    *表示范围小的数据类型转换成范围大的数据类型,如byte转成int
    *自动类型转换格式：
        范围大的数据类型 变量 = 范围小的数据类型值；
        如：
                double d = 1000;
        或
                int i = 100;
                double d2 = i;
* 强制类型转换：
    * 表示范围大的数据类型转换成范围小的数据类型
     *强制类型转换格式：
        范围小的数据类型  变量 = (范围小的数据类型) 范围大的数据类型值;
        如：
                int  i = (int)6.718;   //i的值为6
        或
                double  d = 3.14;
                int  i2 = (int)d;     //i2的值为3
* 注意：
    *布尔类型不参与类型转换
    *byte &lt; short &lt; int &lt; long &lt; float &lt; double
    *
                byte b = (byte)200;
                System.out.println(b);注意输出结果不是127,因为会损失精度
    *
                byte b = 10;这是对的.不要以为10为int类型,赋值给byte就需要强制转换.只要需要赋值的数据值,在byte范围(-128-127)内,就是对的,不需要强制转换.因为java中常量优化机制,只要在范围内自己转换
    *
                byte b1=3,b2=4;
                byte b = b1+b2;// 错,因为b1和b2都是byte类型变量,在参加运算时要先转成int类型,所以b1+b2的结果为int类型,把int类型的数据赋值给byte类型的b,就会损失精度,导致编译报错
                byte b = 3+4;//对 
                解释一:3和4都是int类型的常量,java虚拟机有常量优化机制,编译时就能确实3+4的结果为7,然后把7赋值给byte类型的b,7正好在byte数据范围内,会有一个隐式类型转换,可以赋值成功
                解释er:给出了固定值,和不超过范围.由java底层常量优化机制,即可自动转换.如果是byte b = 300+4;那就错了
    *
                char c = 98;这是对的,不要以为没加&apos;&apos;,就不是字符.由Ascii码表,只要数字范围i在(0-65535),就可以Ascii为单个字符
    *
                long可以自动类型变换至float的原因: 
                       (1)它们底层的存储结构不同
                       (2)遵循IEEE-754格式标准,float类型的指数可从-126到128.float表示的数据范围比long型的范围要大
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-数据&quot;&gt;&lt;a href=&quot;#一-数据&quot; class=&quot;headerlink&quot; title=&quot;一.数据&quot;&gt;&lt;/a&gt;一.数据&lt;/h2&gt;&lt;h3 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1.数据类型&quot;&gt;&lt;/a&gt;1.数据类型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* 程序=数据+逻辑
* 数据类型包括 
    * 1.基本数据类型:整数、小数、字符、布尔 
    * 2.引用数据类型:数组、类、接口
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-常量&quot;&gt;&lt;a href=&quot;#2-常量&quot; class=&quot;headerlink&quot; title=&quot;2.常量&quot;&gt;&lt;/a&gt;2.常量&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* 整数类型 
    * 十进制
    * 二进制:以0b(0B)开头,只有0和1  
    * 十六进制:以0x(0X)开头,0-9和A-F,F表示15 
    * 八进制:以0开头,最大数为7
* 小数类型(浮点类型)
* 布尔类型:true和flase为关键字
* 字符类型:单引号中仅能包含一个字符,不能不写字符,可以用一个空格
* 字符串类型:可以写0-n个字符  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础语法" scheme="https://geekhoon.github.io/tags/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>02.注释、关键字、标识符</title>
    <link href="https://geekhoon.github.io/2017/01/08/02-%E6%B3%A8%E9%87%8A%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
    <id>https://geekhoon.github.io/2017/01/08/02-注释、关键字、标识符/</id>
    <published>2017-01-08T01:53:26.000Z</published>
    <updated>2017-01-08T02:04:09.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><pre><code>* 编译时,编译器会忽略注释
* 包含
    * 单行注释:// 
    * 多行注释:/*....*/ 
    * 文档注释:/**...*/ 
* 多行注释不能嵌套多行注释
</code></pre><h3 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h3><pre><code>* 被JAVA赋予特殊含义,具有专门用途的单词
* JAVA中关键字均为小写
* main不是关键字
</code></pre><h3 id="3-标识符"><a href="#3-标识符" class="headerlink" title="3.标识符"></a>3.标识符</h3><pre><code>* JAVA中,程序员自己定义的内容
* 规则: 
    * 1.组成:字母52个(a-z,A-Z)、数字(0-9)、下划线_、美元符$
    * 2.注意:不能以数字开头、不能是关键字、标识符不能有空格、严格区分大小写
    * 3.类的名字:首字母大写,第二个单词开始首字母大写
    * 4.方法名字与变量名一样:首字母小写,第二个单词开始首字母大写 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-注释&quot;&gt;&lt;a href=&quot;#1-注释&quot; class=&quot;headerlink&quot; title=&quot;1.注释&quot;&gt;&lt;/a&gt;1.注释&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* 编译时,编译器会忽略注释
* 包含
    * 单行注释:// 
    * 多行注释:/*....*/
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础语法" scheme="https://geekhoon.github.io/tags/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>01.JAVA开发概述及HelloWorld</title>
    <link href="https://geekhoon.github.io/2017/01/08/01-JAVA%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0%E5%8F%8AHelloWorld/"/>
    <id>https://geekhoon.github.io/2017/01/08/01-JAVA开发概述及HelloWorld/</id>
    <published>2017-01-08T01:50:26.000Z</published>
    <updated>2017-01-08T01:51:20.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-JAVA环境搭建"><a href="#一-JAVA环境搭建" class="headerlink" title="一.JAVA环境搭建"></a>一.JAVA环境搭建</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><pre><code>* 创始团队:詹姆斯-高斯林
* sun开发,已被oracle收购.
* 版本(平台)
    * JAVASE(标准版):开发简单桌面应用,不能开发大型项目.也叫J2SE 
    * JAVAEE(企业版或Web版):可做电商、企业级应用(如ERP、CRM、BOS、OA等)，也叫J2EE
    * JAVAME（嵌入式开发）：也叫J2ME
</code></pre><a id="more"></a>
<h3 id="2-常用DOS命令"><a href="#2-常用DOS命令" class="headerlink" title="2.常用DOS命令"></a>2.常用DOS命令</h3><pre><code>* 清屏：cls(clear screen)
* 切换盘符：盘符:
* 进入指定目录：cd（change directory）
* 返回上一级目录：cd..
* 返回盘符根目录：cd\
* 进入其他盘符文件夹：cd 盘符:\文件夹名
* 显示当前目录下的文件和子目录信息：dir
</code></pre><h3 id="3-开发环境"><a href="#3-开发环境" class="headerlink" title="3.开发环境"></a>3.开发环境</h3><pre><code>* JDK(JAVA Development Kit):java开发工具包
* JDK包含
    * JRE(JAVA Runtime Environment):JAVA运行环境
    * JAVA开发工具
</code></pre><h3 id="4-跨平台特性"><a href="#4-跨平台特性" class="headerlink" title="4.跨平台特性"></a>4.跨平台特性</h3><pre><code>* 平台指操作系统(Windows/Linux/mac)
* 一次编写,到处运行
* 跨平台特性依赖于JVM(JAVA Virtual Machine)
* JRE包含
    * JVM 
    * 类库  
</code></pre><h2 id="二-HelloWorld"><a href="#二-HelloWorld" class="headerlink" title="二.HelloWorld"></a>二.HelloWorld</h2><pre><code>* 源文件:  .java 
* 编译(编译器):    .java   →    .class(字节码文件)
* 运行(解释器):    运行.class

public class HelloWorld{
    public static void main(String[] args){
        System.out.println(&quot;HelloWorld&quot;);
    }
}
</code></pre><p><strong>注意:</strong><br><strong>1.class前加上public,类名(HelloWorld)要与文件名(HelloWorld.java)一致,不加public,类名可换成其他</strong><br><strong>2.主方法是程序的入口,被虚拟机调用,它能保证程序的独立运行</strong><br>编译:<code>javac HelloWorld.java</code><br>编译时HelloWorld.java可以写成helloworld.java,因为对源文件来说HellWorld.java和helloworld.java所指的源文件是唯一的<br>运行:<code>java HelloWorld</code><br>运行时HelloWorxld是类名,不能写成helloworld</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-JAVA环境搭建&quot;&gt;&lt;a href=&quot;#一-JAVA环境搭建&quot; class=&quot;headerlink&quot; title=&quot;一.JAVA环境搭建&quot;&gt;&lt;/a&gt;一.JAVA环境搭建&lt;/h2&gt;&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;* 创始团队:詹姆斯-高斯林
* sun开发,已被oracle收购.
* 版本(平台)
    * JAVASE(标准版):开发简单桌面应用,不能开发大型项目.也叫J2SE 
    * JAVAEE(企业版或Web版):可做电商、企业级应用(如ERP、CRM、BOS、OA等)，也叫J2EE
    * JAVAME（嵌入式开发）：也叫J2ME
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础语法" scheme="https://geekhoon.github.io/tags/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础题</title>
    <link href="https://geekhoon.github.io/2017/01/05/JAVA%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>https://geekhoon.github.io/2017/01/05/JAVA基础题/</id>
    <published>2017-01-05T12:51:09.000Z</published>
    <updated>2017-01-05T14:05:16.669Z</updated>
    
    <content type="html"><![CDATA[<p>1.Java注释有3种，单行注释、多行注释和文档注释，下列有关注释的说法，不正确的是（）</p>
<p>A. 注释指的是用来对程序的某个功能或者某行代码进行解释说明<br>B. 注释只在Java源文件中有效<br>C. 在多行注释中，能够嵌套多行注释<br>D. 注释不会被编译到class字节码文</p>
<p>2.下面哪种类型的文件可以在Java虚拟机中运行？（）</p>
<p>A. .java<br>B. .jre<br>C. .exe<br>D. .class<br><a id="more"></a><br>3.下列关于变量和常量的说法正确的是（）</p>
<p>A. 常量表示不能被改变的值，例如1、2、“abc”都是常量<br>B. 常量表示常见的变量<br>C. int x = 0;代码中，x表示常量，0表示变量<br>D. 在同一个大括号｛｝内，定义的变量不能够重名</p>
<p>4.下列定义变量格式，错误的是（）</p>
<p>A. float x,y=0;<br>B. float f = 1999.99F;<br>C. String str = 字符串;<br>D. char x = ‘0’;</p>
<p>5.下列各种符号的定义格式，那种在java语言中是错误的变量定义（）</p>
<p>A. int myVal =1;<br>B. char $myVal =1;<br>C. byte _myVal =1;<br>D.float 3.14myVal=1;</p>
<p>6.Java语言中的int及char数据类型的长度分别为（）</p>
<p>A. 16位和8位<br>B. 8位和16位<br>C. 32位和16位<br>D. 32位和8位</p>
<p>7.语句System.out.println(1+2+”java”+3+4)输出的结果是（）</p>
<p>A. 3java34<br>B. 12java34<br>C. 3java7<br>D. 12java7</p>
<p>8.下列关于Java函数的说法不正确的是（）</p>
<p>A.函数也叫方法，函数就是定义在类中，具有特定功能的一段小程序<br>B.方法体中不能有任何代码（抽象函数除外）<br>C.函数必须先定义，才能被调用<br>D.函数（构造函数除外）要有返回值类型</p>
<p>9.以下关于函数重载的说法正确的有（）</p>
<p>A. 方法名必须一样<br>B. 与返回值类型无关<br>C. 参数个数或者顺序不一样<br>D. 参数类型不一样</p>
<p>10.关于数组的说法，正确的是（）</p>
<p>A. 数组里面存放的是相同类型的数据<br>B. 获取数组的长度使用length属性<br>C. 获取数组的大小使用size方法<br>D. 数组的长度是可变的</p>
<p>11.想要结果输出为0，则可以做哪些修改？（）</p>
<pre><code>int [] arr = new int[1];
arr[0] = 3;               
System.out.println( arr[1] )
</code></pre><p>A. 2修改为<code>arr[3] = 0;</code><br>B. 3修改为<code>System.out.println(0)</code><br>C. 1修改为<code>int [ ] arr = new int[2];</code><br>D. 不用修改了，结果就是0会报错</p>
<p>12.下列二维数组定义错误的是（）</p>
<pre><code>A.int[][] arr = new int[3][2];
B.int arr[][] = new int[3][]; 
C.int[][] arr = {{1,2,3},{4,5},{6,7,8,9}};
D.int arr[][] ={{2,3},{6},9};
</code></pre><p>13.下面代码的运行结果是（）</p>
<pre><code>public static void main(String[] args){
int x = 80;
x ++;
switch(x){
case 80:
System.out.println(80);
case 81:
System.out.println(81);
default:
System.out.println(82);
}
}
</code></pre><p>A. 80<br>B. 80 81<br>C. 81<br>D. 81 82</p>
<p>14.下面程序运行的结果是（）</p>
<pre><code>public static void main(String[] args){
    int a = 1;
    if(a++&gt;1){
        System.out.println(a);
    }else{
        System.out.println(a);
    }
}
</code></pre><p>A.1<br>B.2<br>C.0<br>D.编译报错</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>答案:1~5:C,D,AD,C,D 6~10:C,A,B,ABCD,AB 11~14:BC,D,D,B</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.Java注释有3种，单行注释、多行注释和文档注释，下列有关注释的说法，不正确的是（）&lt;/p&gt;
&lt;p&gt;A. 注释指的是用来对程序的某个功能或者某行代码进行解释说明&lt;br&gt;B. 注释只在Java源文件中有效&lt;br&gt;C. 在多行注释中，能够嵌套多行注释&lt;br&gt;D. 注释不会被编译到class字节码文&lt;/p&gt;
&lt;p&gt;2.下面哪种类型的文件可以在Java虚拟机中运行？（）&lt;/p&gt;
&lt;p&gt;A. .java&lt;br&gt;B. .jre&lt;br&gt;C. .exe&lt;br&gt;D. .class&lt;br&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="https://geekhoon.github.io/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="题目" scheme="https://geekhoon.github.io/tags/%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>写在最前面</title>
    <link href="https://geekhoon.github.io/2017/01/01/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/"/>
    <id>https://geekhoon.github.io/2017/01/01/写在最前面/</id>
    <published>2017-01-01T15:09:33.000Z</published>
    <updated>2017-01-01T15:14:41.840Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一生中总会遇到这样的时候，你的内心已经兵荒马乱天翻地覆了，可是在别人看来你只是比平时沉默了一点，没人会觉得奇怪。这种战争，注定单枪匹马。           ———白岩松 《痛并快乐着》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一生中总会遇到这样的时候，你的内心已经兵荒马乱天翻地覆了，可是在别人看来你只是比平时沉默了一点，没人会觉得奇怪。这种战争，注定单枪匹马。           ———白岩松 《痛并快乐着》&lt;/p&gt;
&lt;/blockquote&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
