<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[20.反射]]></title>
      <url>https://geekhoon.github.io/2017/03/06/20-%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><pre><code>* 要使用某个类时,如果该类还未被加载到内存中,
  则系统会通过加载,连接,初始化三步来实现对这个类进行初始化。
</code></pre><a id="more"></a>    
<pre><code>1. 类的加载
    * 将class文件读入内存,类的加载器创建一个编译后的class文件的对象(字节码对象)
    * 任何类在使用时,系统都会建立一个class对象
2. 连接
    * 验证: 检查内部结构
    * 准备: 为类的静态成员分配内存,并默认初始化值
    * 解析: 将类的二进制数据中的符号引用替换为直接引用
3. 初始化
    * 创建对象,赋值
</code></pre><h4 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h4><pre><code>* 创建类的实例
* 类的静态变量，或者为静态变量赋值
* 类的静态方法
* 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
* 初始化某个类的子类
* 直接使用java.exe命令来运行某个主类
</code></pre><h4 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h4><pre><code>* 负责将.class文件加载到内存中,并为之生成对应的Class对象
* 组成:
    1. 根类加载器Bootstrap ClassLoader
        负责Java核心类的加载,比如System,String等
        在JDK中JRE的lib目录下rt.jar文件中
    2. 扩展类加载器Extension ClassLoader
        负责JRE的扩展目录中jar包的加载。
        在JDK中JRE的lib目录下ext目录
    3. 系统类加载器System ClassLoader
        在JVM启动时加载来自java命令的class文件以及classpath环境变量所指定的jar包和类路径
</code></pre><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><pre><code>* JAVA反射机制是在运行状态中，
    对于任意一个类,都能够知道这个类的所有属性和方法；
    对于任意一个对象,都能够调用它的任意一个方法和属性；
* 条件：运行状态
  已知：一个类或一个对象(根本是已知.class文件)
  结果：得到这个类或对象的所有方法和属性
</code></pre><h4 id="class文件的产生过程"><a href="#class文件的产生过程" class="headerlink" title="class文件的产生过程"></a>class文件的产生过程</h4><pre><code>* Class对象是在加载类时由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的
</code></pre><h4 id="class文件对象的获得"><a href="#class文件对象的获得" class="headerlink" title="class文件对象的获得"></a>class文件对象的获得</h4><pre><code>1. 对象获取(通过Object类中的getClass()方法)
2. 类名获取(任意数据类型都具备一个class静态属性)
3. Class类的静态方法获取(通过Class类中的方法)
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.对象获取</div><div class="line">Person p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//调用父类方法getClass()</span></div><div class="line">Class c1 =  p.getClass();</div><div class="line">System.out.println(c1);</div><div class="line"></div><div class="line"><span class="number">2</span>.类名获取</div><div class="line"><span class="comment">//每个类型,包括基本和引用,都会赋予这个类型一个静态的属性,属性名字就叫class</span></div><div class="line">Class c2 = Peron.class;</div><div class="line">Class d1 = <span class="keyword">double</span>.class;</div><div class="line">System.out.println(c2);</div><div class="line">System.out.println(d1);<span class="comment">//打印结果是double</span></div><div class="line"></div><div class="line"><span class="number">3</span>.静态方法获取Class.forName(String classname)</div><div class="line"><span class="comment">//字符串的类名:要加上包名</span></div><div class="line">Class c3 = Class.forName(<span class="string">"com.geekhoon.demo1.Person"</span>);</div><div class="line">System.out.println(c3);</div><div class="line"></div><div class="line">打印结果都是:<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">geekhoon</span>.<span class="title">demo01</span>.<span class="title">Person</span></span></div></pre></td></tr></table></figure>
<h3 id="通过反射获取无参构造方法并使用"><a href="#通过反射获取无参构造方法并使用" class="headerlink" title="通过反射获取无参构造方法并使用"></a>通过反射获取无参构造方法并使用</h3><pre><code>* Class中方法:
    1. public Constructor&lt;?&gt;[] getConstructors(): 获取所有的public修饰的构造方法
    2. public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) :
        获取public修饰, 指定参数类型所对应的构造方法
        不传参数得到无参构造方法
* Constructor类中方法:
    1. public T newInstance(Object... initargs) :
        使用此Constructor对象表示的构造方法来创建该构造方法的声明类的新实例
        并用指定的初始化参数初始化该实例
        因为是无参构造,所以不传参数
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	Class c = Class.forName(<span class="string">"com.geekhoon.demo01.Person"</span>);</div><div class="line"><span class="comment">//1.获取class文件对象中所有公共的构造方法: Constructor[] getConstructors()</span></div><div class="line"><span class="comment">//返回值是Constructor类型数组</span></div><div class="line">	Constructor[] cons = c.getConstructors();</div><div class="line">	<span class="keyword">for</span> (Constructor con : cons) &#123;</div><div class="line">		System.out.println(con);<span class="comment">//打印的是所有公共构造方法名</span></div><div class="line">	&#125;</div><div class="line"><span class="comment">//2.获取指定的构造方法  ----&gt; 获取空参数构造方法: Constructor getConstructor()</span></div><div class="line">	Constructor con = c.getConstructor();</div><div class="line">	System.out.println(con);<span class="comment">//打印空参构造方法名</span></div><div class="line"><span class="comment">//运行空参构造方法,使用的是Constructor类方法newInstance()</span></div><div class="line"><span class="comment">//创建该构造方法的声明类的新实例,new了一个Person对象</span></div><div class="line"><span class="comment">//运行获取到的构造方法,返回值是Object类型对象</span></div><div class="line">	<span class="comment">//相当于Object obj = new Person();</span></div><div class="line">	Object obj = con.newInstance();</div><div class="line"><span class="comment">//要调用Person类的方法,需要进行向下转型</span></div><div class="line">	Person p = (Person) obj;</div><div class="line">	p.eat();</div><div class="line">	System.out.println(obj);</div><div class="line"><span class="comment">//因为重写了toString(),打印结果是Person [name=null, age=0]</span></div><div class="line"><span class="comment">//没有重写的话,打印的则是p的地址</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通过反射获取有参构造方法并使用"><a href="#通过反射获取有参构造方法并使用" class="headerlink" title="通过反射获取有参构造方法并使用"></a>通过反射获取有参构造方法并使用</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
    Class c = Class.forName(<span class="string">"com.geekhoon.demo01.Person"</span>);
<span class="comment">//getConstructor(),参数列表中传递的是构造方法对应的类型</span>
<span class="comment">//不可以直接写String,int,因为参数是字节码文件对象类型,加上.class</span>
    Constructor con = c.getConstructor(String.class,<span class="keyword">int</span>.class);
<span class="comment">//运行构造方法newInstance(),参数列表中传递的是实际参数,进行赋值    </span>
    Object obj = con.newInstance(<span class="string">"张三"</span>,<span class="number">20</span>);
    System.out.println(obj);
}
</code></pre>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[19.JDBC&DBUtils]]></title>
      <url>https://geekhoon.github.io/2017/03/01/19-JDBC-DBUtils/</url>
      <content type="html"><![CDATA[<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>* Java Data Base Connectivity
* 一种用于执行SQL语句的Java API,可以为多种关系数据库提供统一访问,它由一组用Java语言
  编写的类和接口组成.是Java访问数据库的规范.
* 原理: 
    * Java提供访问数据库规范称为JDBC,JDBC需要连接驱动,驱动是生产厂商提供规范的实现类
    * JDBC是接口,驱动是接口的实现,没有驱动将无法完成数据库连接
    * 每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库
* 导入驱动jar包
    * 建lib目录，用于存放当前项目需要的所有jar包
    * 选择jar包，右键执行build path / Add to Build Path
</code></pre><a id="more"></a>    
<h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><pre><code>1.注册驱动
    告知JVM使用的是哪一个数据库的驱动
2.获取数据库的连接对象
    使用JDBC中的类,完成对MySQL数据库的连接
3.获得执行者对象
    通过连接对象获取对SQL语句的执行者对象
4.执行sql语句
    使用执行者对象,向数据库执行SQL语句
    获取到数据库的执行后的结果
5.处理结果
6.释放资源
    close()
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</div><div class="line"><span class="keyword">import</span> java.sql.ResultSet;</div><div class="line"><span class="keyword">import</span> java.sql.SQLException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 1.注册驱动</div><div class="line"> *   Driver是一个接口: 每个驱动程序类必须实现的接口</div><div class="line"> *   方式一: 使用java.sql.DriverManager类的静态方法registerDriver(Driver driver)</div><div class="line"> *   	         参数是MySQL驱动程序的Driver实现类,这种方式会new两个Driver对象,不推荐使用</div><div class="line"> *   方式二: 使用反射技术, 将驱动类加入到内容,如下: </div><div class="line"> */</div><div class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 2.获取数据库的连接对象</div><div class="line"> * 	 使用DriverManager类中静态方法static Collection getConnection()</div><div class="line"> */</div><div class="line">		String url = <span class="string">"jdbc:mysql://localhost:3306/mybase"</span>;</div><div class="line">		String user = <span class="string">"root"</span>;</div><div class="line">		String password = <span class="string">"264329"</span>;</div><div class="line">		Connection con = DriverManager.getConnection(url, user, password);</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 3.获得执行者对象</div><div class="line"> */</div><div class="line"><span class="comment">//Statement stat = con.createStatement();这种接口对象有安全隐患(SQL注入攻击)</span></div><div class="line">		String sql = <span class="string">"INSERT INTO sort(sname,sprice,sdesc) VALUES(?,?,?)"</span>;</div><div class="line"><span class="comment">//使用Statement的子类接口prepareStatement可有效避免安全隐患,但注意sql语句的编写</span></div><div class="line"><span class="comment">//要赋值的列如上或者判断条件中要用值,不要直接写出值,而要用?占位,如select * from sort where sid = 1</span></div><div class="line"><span class="comment">//这里就不能写1, 要写成select * from sort where sid =?</span></div><div class="line"><span class="comment">//如果是select * from sort,不需要值,那不用写setObject()</span></div><div class="line"><span class="comment">//通过PreparedStatement对象的setObject()进行赋值</span></div><div class="line"><span class="comment">//第一个参数是占位符的位置,从1开始,第二个是值</span></div><div class="line"><span class="comment">//使用的是Connection数据库连接对象的方法,获取的是PreparedStatement接口的实现类,</span></div><div class="line"><span class="comment">//也叫sql语句的预编译对象</span></div><div class="line"><span class="comment">//PreparedStatement prepareStatement(String sql)</span></div><div class="line">		<span class="comment">//PrepareStatement接口预编译SQL语句</span></div><div class="line">		PreparedStatement pds = con.prepareStatement(sql);</div><div class="line">		pds.setObject(<span class="number">1</span>, <span class="string">"汽车用品"</span>);</div><div class="line">		pds.setObject(<span class="number">2</span>, <span class="number">3220</span>);</div><div class="line">		pds.setObject(<span class="number">3</span>, <span class="string">"涨价"</span>);</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 4.执行sql语句</div><div class="line"> *   有两点:</div><div class="line"> *   	1.是增删改语句:调用执行者对象的executeUpdate(),返回值是受影响行数:</div><div class="line"> *   	  int row = pds.executeUpdate();</div><div class="line"> *   	     也可以不用接收返回值,直接写成pds.executeUpdate()</div><div class="line"> *   	2.是查询语句:调用执行者对象的executeQuery(),返回值是结果集</div><div class="line"> */</div><div class="line">		ResultSet rs = pds.executeQuery();</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 5.处理结果集</div><div class="line"> *   ResultSet接口方法 boolean next() 返回true,有结果集,返回false没有结果集</div><div class="line"> */</div><div class="line"><span class="comment">//特别注意:　rs.next()判断的是结果集,不是数据表,是根据select条件查询出的内容,可能一条或多条</span></div><div class="line">		<span class="keyword">while</span>(rs.next())&#123;</div><div class="line">			<span class="comment">//获取每列数据,使用是ResultSet接口的方法 getXX方法参数中,建议写String列名</span></div><div class="line">			System.out.println(rs.getInt(<span class="string">"sid"</span>) + <span class="string">"  "</span> + rs.getString(<span class="string">"sname"</span>) </div><div class="line">				+ <span class="string">"  "</span> + rs.getDouble(<span class="string">"sprice"</span>) + <span class="string">"  "</span> + rs.getString(<span class="string">"sdesc"</span>));</div><div class="line">		&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 6.释放资源</div><div class="line"> */</div><div class="line">		rs.close();</div><div class="line">		pds.close();</div><div class="line">		con.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><pre><code>* 由用户输入用户名,密码来查询数据库中是否存在该用户的sql语句如下:
SELECT * FROM 用户表 WHERE NAME = 用户输入的用户名 AND PASSWORD = 用户输的密码; 
* 不管输入的用户名是XXXX,密码是XXX,只要密码格式为 XXX&apos; OR &apos;1&apos;=&apos;1 或 XXX&apos; OR &apos;1 = 1 
* 真正执行的代码变为:
SELECT * FROM 用户表 WHERE NAME = &apos;XXXX&apos; AND PASSWORD =&apos;XXX&apos; OR &apos;1&apos;=&apos;1&apos;;或
SELECT * FROM 用户表 WHERE NAME = &apos;XXXX&apos; AND PASSWORD =&apos;XXX&apos; OR &apos;1 = 1&apos;;
where条件都为true, 永远都可以查询出结果,那么用户就直接登录成功了,这就是SQL注入攻击问题
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">		String url = <span class="string">"jdbc:mysql://localhost:3306/mybase"</span>;</div><div class="line">		String username = <span class="string">"root"</span>;</div><div class="line">		String password = <span class="string">"264329"</span>;</div><div class="line">		Connection con = DriverManager.getConnection(url, username, password);</div><div class="line">		Statement stat = con.createStatement();</div><div class="line">		</div><div class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">		String user = sc.nextLine();</div><div class="line">		String pass = sc.nextLine();</div><div class="line">		</div><div class="line">		<span class="comment">//执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败</span></div><div class="line">		String sql = <span class="string">"SELECT * FROM users WHERE username='"</span>+user+<span class="string">"' AND PASSWORD='"</span>+pass+<span class="string">"'"</span>;</div><div class="line">		System.out.println(sql);</div><div class="line">		ResultSet rs = stat.executeQuery(sql);</div><div class="line">		<span class="keyword">while</span>(rs.next())&#123;</div><div class="line">			<span class="comment">//进入while循环意味着根据用户名密码查询到信息了,说明登录成功了</span></div><div class="line">			<span class="comment">//任意用户名,只要密码格式如:  任意密码'or'1=1</span></div><div class="line">			<span class="comment">//都可以登录成功</span></div><div class="line">			System.out.println(rs.getString(<span class="string">"username"</span>)+<span class="string">"   "</span>+rs.getString(<span class="string">"password"</span>));</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		rs.close();</div><div class="line">		stat.close();</div><div class="line">		con.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//数据表中正确的用户名密码有:</span></div><div class="line">  用户名 密码</div><div class="line">	a	  <span class="number">1</span></div><div class="line">	b	  <span class="number">2</span></div><div class="line">用户名输入c,密码输入c<span class="string">' or '</span><span class="number">1</span>=<span class="number">1</span> ,就可以打印出所有用户信息了</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">防止SQL注入问题,解决方案:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//1.注册驱动</span></div><div class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">		<span class="comment">//2.获取连接</span></div><div class="line">		String url = <span class="string">"jdbc:mysql://localhost:3306/mybase"</span>;</div><div class="line">		String user = <span class="string">"root"</span>;</div><div class="line">		String password = <span class="string">"264329"</span>;</div><div class="line">		Connection con = DriverManager.getConnection(url, user, password);</div><div class="line">		</div><div class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">		String username = sc.nextLine();</div><div class="line">		String pass = sc.nextLine();</div><div class="line">		</div><div class="line">		<span class="comment">//执行sql语句</span></div><div class="line">		String sql = <span class="string">"select * from users where username = ? and password = ?"</span>;</div><div class="line">		</div><div class="line">		<span class="comment">//3.获取执行者对象</span></div><div class="line">		PreparedStatement pds = con.prepareStatement(sql);</div><div class="line">		pds.setObject(<span class="number">1</span>, username);</div><div class="line">		pds.setObject(<span class="number">2</span>, pass);</div><div class="line">		</div><div class="line">		ResultSet rs = pds.executeQuery();</div><div class="line">		<span class="keyword">while</span>(rs.next())&#123;</div><div class="line">			System.out.println(rs.getString(<span class="string">"username"</span>)+<span class="string">"  "</span>+rs.getString(<span class="string">"password"</span>)+<span class="string">"  "</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		rs.close();</div><div class="line">		pds.close();</div><div class="line">		con.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="JDBC工具类"><a href="#JDBC工具类" class="headerlink" title="JDBC工具类"></a>JDBC工具类</h3><h4 id="普通工具类-普通的测试"><a href="#普通工具类-普通的测试" class="headerlink" title="普通工具类+普通的测试"></a>普通工具类+普通的测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * JDBC工具类</div><div class="line"> * 内容:</div><div class="line"> * 1.私有化构造方法. 不允许在其他类中创建对象！直接类名点调用方法即可</div><div class="line"> * 2.声明一个Connection对象</div><div class="line"> * 3.静态代码块</div><div class="line"> * 4.公共方法返回Connection对象</div><div class="line"> * 5.释放资源方法</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">JDBCUtils</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Connection con;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//1.注册驱动</span></div><div class="line">			Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">			<span class="comment">//2.获得数据库连接</span></div><div class="line">			String url = <span class="string">"jdbc:mysql://localhost:3306/mybase"</span>;</div><div class="line">			String user = <span class="string">"root"</span>;</div><div class="line">			String password = <span class="string">"264329"</span>;</div><div class="line">		    con = DriverManager.getConnection(url, user, password);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e+<span class="string">"数据库连接失败"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> con;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement state,ResultSet rs)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				rs.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				state.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				con.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement state)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				state.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				con.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 对JDBC工具类进行测试</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//调用JDBCUtils工具类中的静态方法，获取数据库连接</span></div><div class="line">		Connection con = JDBCUtils.getConncetion();</div><div class="line">		<span class="comment">//3.获取执行者对象</span></div><div class="line">		String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line">		PreparedStatement pst = con.prepareStatement(sql);</div><div class="line">		<span class="comment">//4.执行sql语句</span></div><div class="line">		ResultSet rs = pst.executeQuery();</div><div class="line">		<span class="comment">//5.处理结果集</span></div><div class="line">		<span class="keyword">while</span>(rs.next()) &#123;</div><div class="line">			System.out.println(rs.getInt(<span class="string">"sid"</span>) + <span class="string">"  "</span> + rs.getString(<span class="string">"sname"</span>) </div><div class="line">				+ <span class="string">"  "</span> + rs.getDouble(<span class="string">"sprice"</span>) + <span class="string">"  "</span> + rs.getString(<span class="string">"sdesc"</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//6.释放资源</span></div><div class="line">		JDBCUtils.close(con, pst, rs);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="读取配置文件工具类-普通的测试"><a href="#读取配置文件工具类-普通的测试" class="headerlink" title="读取配置文件工具类+普通的测试"></a>读取配置文件工具类+普通的测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">开发中获得连接的<span class="number">4</span>个参数(驱动,URL,用户名,密码)通常都存在配置文件中</div><div class="line">方便后期维护,程序如果需要更换数据库,只需要修改配置文件即可</div><div class="line"><span class="number">1</span>.配置文件database.properties中的内容:</div><div class="line">driverClass=com.mysql.jdbc.Driver</div><div class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/mybase</span></div><div class="line">user=root</div><div class="line">password=<span class="number">264329</span></div><div class="line"></div><div class="line"><span class="number">2</span>.读取配置文件工具类:</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.ResultSet;</div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * JDBC读取配置文件工具类</div><div class="line"> * 1.私有化构造方法</div><div class="line"> * 2.声明所需的连接信息</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtilsConfig</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Connection con;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String url;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String user;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String password;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">JDBCUtilsConfig</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			readConfig();</div><div class="line">			Class.forName(driverClass);</div><div class="line">			con = DriverManager.getConnection(url, user, password);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据库连接失败!"</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readConfig</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//使用类的加载器, 加载配置文件,</span></div><div class="line">		<span class="comment">//配置文件一般放在src文件夹下</span></div><div class="line">		InputStream in = JDBCUtilsConfig.class.getClassLoader()</div><div class="line">					.getResourceAsStream(<span class="string">"database.properties"</span>);</div><div class="line">		<span class="comment">//创建Properties集合</span></div><div class="line">		Properties pro = <span class="keyword">new</span> Properties();</div><div class="line">		pro.load(in);</div><div class="line">		<span class="comment">//获取集合中的键值对</span></div><div class="line">		driverClass = pro.getProperty(<span class="string">"driverClass"</span>);</div><div class="line">		url = pro.getProperty(<span class="string">"url"</span>);</div><div class="line">		user = pro.getProperty(<span class="string">"user"</span>);</div><div class="line">		password = pro.getProperty(<span class="string">"password"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> con;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement state,ResultSet rs)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				rs.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				state.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				con.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con, Statement state)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				state.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				con.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="number">3</span>.测试类:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 对读取配置文件的工具类进行普通测试</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		Connection con = JDBCUtilsConfig.getConnection();</div><div class="line">		<span class="comment">//获取执行者对象</span></div><div class="line">		String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line">		PreparedStatement pst = con.prepareStatement(sql);</div><div class="line">		<span class="comment">//执行sql语句</span></div><div class="line">		ResultSet rs = pst.executeQuery();</div><div class="line">		<span class="comment">//处理结果集</span></div><div class="line">		<span class="keyword">while</span>(rs.next()) &#123;</div><div class="line">			System.out.println(rs.getInt(<span class="string">"sid"</span>) + <span class="string">"  "</span> + rs.getString(<span class="string">"sname"</span>) </div><div class="line">			+ <span class="string">"  "</span> + rs.getDouble(<span class="string">"sprice"</span>) + <span class="string">"  "</span> + rs.getString(<span class="string">"sdesc"</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//释放资源</span></div><div class="line">		JDBCUtilsConfig.close(con, pst, rs);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="读取配置文件工具类-自定义对象存储测试"><a href="#读取配置文件工具类-自定义对象存储测试" class="headerlink" title="读取配置文件工具类+自定义对象存储测试"></a>读取配置文件工具类+自定义对象存储测试</h4><pre><code>* JDBC读取数据表sort,每行数据封装到Sort类的对象中
  将多个Sort类对象,存储到List集合中
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.Sort类</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> sid;</div><div class="line">	<span class="keyword">private</span> String sname;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> sprice;</div><div class="line">	<span class="keyword">private</span> String sdesc;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span> sid, String sname, <span class="keyword">double</span> sprice, String sdesc)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.sid = sid;</div><div class="line">		<span class="keyword">this</span>.sname = sname;</div><div class="line">		<span class="keyword">this</span>.sprice = sprice;</div><div class="line">		<span class="keyword">this</span>.sdesc = sdesc;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sort</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSid</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> sid;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSid</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.sid = sid;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> sname;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.sname = sname;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSprice</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> sprice;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSprice</span><span class="params">(<span class="keyword">double</span> sprice)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.sprice = sprice;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSdesc</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> sdesc;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSdesc</span><span class="params">(String sdesc)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.sdesc = sdesc;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"Sort [sid="</span> + sid + <span class="string">", sname="</span> + sname + <span class="string">", sprice="</span> + sprice</div><div class="line">				+ <span class="string">", sdesc="</span> + sdesc + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2</span>.读取配置文件工具类同上</div><div class="line"><span class="number">3</span>.自定义对象存储测试</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 对读取配置文件的工具类进行测试。使用自定义对象存储</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		Connection con = JDBCUtilsConfig.getConnection();</div><div class="line">		<span class="comment">//获取执行者对象</span></div><div class="line">		String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line">		PreparedStatement pst = con.prepareStatement(sql);</div><div class="line">		<span class="comment">//执行sql语句</span></div><div class="line">		ResultSet rs = pst.executeQuery();</div><div class="line">		<span class="comment">//创建list集合</span></div><div class="line">		ArrayList&lt;Sort&gt; list = <span class="keyword">new</span> ArrayList&lt;Sort&gt;();</div><div class="line">		<span class="comment">//处理结果集</span></div><div class="line">		<span class="keyword">while</span>(rs.next()) &#123;</div><div class="line">			list.add(<span class="keyword">new</span> Sort(rs.getInt(<span class="string">"sid"</span>), rs.getString(<span class="string">"sname"</span>), </div><div class="line">				rs.getDouble(<span class="string">"sprice"</span>), rs.getString(<span class="string">"sdesc"</span>)));</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//释放资源</span></div><div class="line">		JDBCUtilsConfig.close(con, pst, rs);</div><div class="line">		<span class="comment">//遍历集合</span></div><div class="line">		<span class="keyword">for</span> (Sort sort : list) &#123;</div><div class="line">			System.out.println(sort);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><pre><code>* 是JDBC的简化开发工具包
* 需要导入jar包: commons-dbutils-1.6.jar
* 3个核心功能:
    1. QueryRunner
    2. ResultSetHandler&lt;T&gt;接口
    3. DbUtils类
* 事务
    * 一套操作
    * 在数据库中应用事务处理案例:转账案例
    * 成功: 提交事务 commit
    * 失败: 回滚事务 rollback
</code></pre><h4 id="QueryRunner核心类"><a href="#QueryRunner核心类" class="headerlink" title="QueryRunner核心类"></a>QueryRunner核心类</h4><pre><code>* 方法:
    update(Connection conn,String sql,Object...params): 执行增删改
    Object...params: 可变参数,Object类型,当SQL语句中出现?占位符时使用
</code></pre><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="comment">//获取数据库连接</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">		insert();</div><div class="line">		<span class="comment">//update();</span></div><div class="line">		<span class="comment">//delete();</span></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">		<span class="comment">//创建QueryRunner类对象</span></div><div class="line">		QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">		String sql = <span class="string">"INSERT INTO sort (sname,sprice,sdesc) VALUES (?,?,?)"</span>;</div><div class="line">		<span class="comment">//将三个占位符的实际参数, 写在数组中</span></div><div class="line">		Object[] params = &#123;<span class="string">"体育用品"</span>,<span class="number">289.32</span>,<span class="string">"购买体育用品"</span>&#125;;</div><div class="line">		<span class="comment">//调用QueryRunner类的方法update执行sql语句</span></div><div class="line">		<span class="keyword">int</span> row = qr.update(con, sql, params);</div><div class="line">		System.out.println(row);</div><div class="line">		<span class="comment">//调用DBUtils释放资源</span></div><div class="line">		DbUtils.closeQuietly(con);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	<span class="comment">//创建QueryRunner类对象</span></div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"UPDATE sort SET sname = ?,sprice = ?,sdesc = ? WHERE sid = ?"</span>;</div><div class="line">	<span class="comment">//定于Object数组,存取实际参数</span></div><div class="line">	Object[] params = &#123;<span class="string">"花卉"</span>,<span class="number">100.88</span>,<span class="string">"情人节玫瑰"</span>,<span class="number">4</span>&#125;;</div><div class="line">	<span class="keyword">int</span> row = qr.update(con, sql, params);</div><div class="line">	System.out.println(row);</div><div class="line">	<span class="comment">//调用DBUtils释放资源</span></div><div class="line">	DbUtils.closeQuietly(con);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</div><div class="line">	<span class="comment">//创建QueryRunner对象</span></div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"DELETE FROM sort WHERE sid = ?"</span>;</div><div class="line">	<span class="keyword">int</span> row = qr.update(con, sql, <span class="number">9</span>);</div><div class="line">	System.out.println(row);</div><div class="line">	DbUtils.closeQuietly(con);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="QueryRunner实现查询"><a href="#QueryRunner实现查询" class="headerlink" title="QueryRunner实现查询"></a>QueryRunner实现查询</h4><pre><code>* query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params): 
  用来完成表数据的查询操作
* ResultSetHandler&lt;T&gt; rsh: 结果集的处理方式,传递的是ResultSetHandler接口的实现类
* 注意: query()的返回值是泛型类型T
</code></pre><h5 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h5><pre><code>* 是一个类,在开发中常用封装数据
* 特性:
    1. 需要实现接口
    2. 提供私有字段
    3. 提供getter/setter方法
    4. 提供无参构造 
</code></pre><h5 id="ResultSetHandler结果集处理类"><a href="#ResultSetHandler结果集处理类" class="headerlink" title="ResultSetHandler结果集处理类"></a>ResultSetHandler结果集处理类</h5><pre><code>* 8种结果集的处理方式:
    1. ArrayHandler
    2. ArrayListHandler
    3. BeanHandler
    4. BeanListHandler
    5. ColumnListHandler
    6. ScalarHandler
    7. MapHandler
    8. MapListHandler
</code></pre><h5 id="ArrayHandler与ArrayListHandler查询"><a href="#ArrayHandler与ArrayListHandler查询" class="headerlink" title="ArrayHandler与ArrayListHandler查询"></a>ArrayHandler与ArrayListHandler查询</h5><pre><code>1. ArrayHandler: 将结果集的第一行存储到对象数组中Object[]
    * 不管查询到几行,只存储第一行
    * 数组长度不等于0,代表查询到内容了 
2. ArrayListHandler: 将结果集的每一行封装到对象数组中,出现很多对象数组,将对象数组存储到list集合
    * 返回值: 存储很多对象数组的List集合
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="comment">//获取数据库连接</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">		arrayHandler();</div><div class="line">		<span class="comment">//arrayListHandler();</span></div><div class="line">		<span class="comment">//调用DBUtils释放资源</span></div><div class="line">		DbUtils.closeQuietly(con);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">ArrayHandler:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayHandler</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line"><span class="comment">//query方法传递的参数有:</span></div><div class="line"><span class="comment">//连接对象,sql语句,结果集处理方式的实现类,有占位符的话还有加上实际参数</span></div><div class="line">	Object[] result = qr.query(con, sql, <span class="keyword">new</span> ArrayHandler());</div><div class="line">	<span class="keyword">if</span> (result.length != <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">for</span> (Object obj : result) &#123;</div><div class="line">			System.out.print(obj+<span class="string">"\t"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		System.out.println(<span class="string">"没有查询到数据"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ArrayListHandler:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayListHandler</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line"><span class="comment">//query方法传递的参数有:</span></div><div class="line"><span class="comment">//连接对象,sql语句,结果集处理方式的实现类,有占位符的话还有加上实际参数</span></div><div class="line">	List&lt;Object[]&gt; result = qr.query(con, sql, <span class="keyword">new</span> ArrayListHandler());</div><div class="line">	<span class="keyword">if</span> (result.size() != <span class="number">0</span>) &#123;</div><div class="line">	<span class="comment">//遍历集合</span></div><div class="line">		<span class="keyword">for</span> (Object[] objs : result) &#123;</div><div class="line">			<span class="comment">//遍历对象数组</span></div><div class="line">			<span class="keyword">for</span> (Object obj : objs) &#123;</div><div class="line">				System.out.print(obj+<span class="string">"\t"</span>);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		System.out.println(<span class="string">"没有查询到数据"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="BeanHandler与BeanListHandler查询"><a href="#BeanHandler与BeanListHandler查询" class="headerlink" title="BeanHandler与BeanListHandler查询"></a>BeanHandler与BeanListHandler查询</h5><pre><code>1. BeanHandler: 将结果集的第一行数据,封装成JavaBean对象
    注意: 将数据封装到JavaBean对象, Sort类必须有空参构造
2. BeanListHandler: 将结果集的每一行数据,封装成JavaBean对象
    多个JavaBean对象,封装到List集合
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">BeanHandler:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beanHandler</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line">	<span class="comment">//调用方法,传递结果实现类BeanHandler</span></div><div class="line">	<span class="comment">//BeanHandler(Class&lt;T&gt; type)</span></div><div class="line">	Sort s = qr.query(con, sql, <span class="keyword">new</span> BeanHandler&lt;Sort&gt;(Sort.class));</div><div class="line">	System.out.println(s);</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">BeanListHandler:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beanListHandler</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line">	<span class="comment">//调用方法传递结果集的实现类BeanListHandler</span></div><div class="line">	List&lt;Sort&gt; list = qr.query(con, sql, <span class="keyword">new</span> BeanListHandler&lt;Sort&gt;(Sort.class));</div><div class="line">	<span class="keyword">for</span> (Sort s : list) &#123;</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ColumnListHandler与ScalarHandler查询"><a href="#ColumnListHandler与ScalarHandler查询" class="headerlink" title="ColumnListHandler与ScalarHandler查询"></a>ColumnListHandler与ScalarHandler查询</h5><pre><code>1. ColumnListHandler: 将结果集指定列的数据存储到List集合
    List&lt;Object&gt;: 集合泛型是Object
2. ScalarHandler: 适用于查询后只有一个结果(聚合函数的结果)
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ColumnListHandler:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">columnListHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line">	<span class="comment">//调用方法query,传递结果集实现类ColumnListHandler</span></div><div class="line">	<span class="comment">//实现类构造方法中,使用字符串的列名</span></div><div class="line">	List&lt;Object&gt; list = qr.query(con, sql, <span class="keyword">new</span> ColumnListHandler&lt;Object&gt;(<span class="string">"sname"</span>));</div><div class="line">	<span class="keyword">for</span> (Object obj : list) &#123;</div><div class="line">		System.out.println(obj);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ScalarHandler:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalarHandler</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"SELECT COUNT(*) FROM sort"</span>;</div><div class="line">	<span class="comment">//qr.query(con, sql, new ScalarHandler&lt;Object&gt;());</span></div><div class="line">	<span class="comment">//如果已知结果为int, 泛型直接写成long, 不知道的话使用Object</span></div><div class="line">	Long count = qr.query(con, sql, <span class="keyword">new</span> ScalarHandler&lt;Long&gt;());</div><div class="line">	System.out.println(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="MapHandler与MapListHandler查询"><a href="#MapHandler与MapListHandler查询" class="headerlink" title="MapHandler与MapListHandler查询"></a>MapHandler与MapListHandler查询</h5><pre><code>1. MapHandler: 将结果集的第一行数据,封装到map集合
    键: 查询的列名
    值: 对应列的数据
2. MapListHandler: 将结果集每一行存储到Map集合,键:列名,值:数据
    Map集合过多,存储到List集合
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">MapHandler:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapHandler</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line">	<span class="comment">//返回值是一个Map集合</span></div><div class="line">	Map&lt;String, Object&gt; map = qr.query(con, sql, <span class="keyword">new</span> MapHandler());</div><div class="line">	<span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">		System.out.println(key+<span class="string">" "</span>+map.get(key));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">MapListHandler:</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapListHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">	QueryRunner qr = <span class="keyword">new</span> QueryRunner();</div><div class="line">	String sql = <span class="string">"SELECT *  FROM sort"</span>;</div><div class="line">	<span class="comment">//返回值是List集合, 存储的是Map集合</span></div><div class="line">	List&lt;Map&lt;String, Object&gt;&gt; list = qr.query(con, sql, <span class="keyword">new</span> MapListHandler());</div><div class="line">	<span class="keyword">for</span> (Map&lt;String, Object&gt; map : list) &#123;</div><div class="line">		<span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">			System.out.print(<span class="string">"\t"</span>+key+<span class="string">"\t"</span>+map.get(key)+<span class="string">"\t"</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><pre><code>* 存放连接的容器
* 频繁地获得连接和释放资源,非常消耗资源,通过连接池,共享连接,解决此类问题
* 需要数据库连接时,通过池来获取Connection对象,用完后,调用Connection的close()回收对象,
  对象回到连接池中,并没有真正关闭.
</code></pre><h4 id="DataSource接口"><a href="#DataSource接口" class="headerlink" title="DataSource接口"></a>DataSource接口</h4><pre><code>* Java为数据库连接提供了公共的接口,数据库厂商需要让自己的连接池实现这个接口
</code></pre><h4 id="DBCP连接池"><a href="#DBCP连接池" class="headerlink" title="DBCP连接池"></a>DBCP连接池</h4><pre><code>* 开源的连接池
* Tomcat内置的连接池
* Tomcat: 
    * JavaWeb服务器,把写好的class文件放在Tomcat中,开启后监听端口8080
    * 浏览器通过端口访问
</code></pre><h4 id="BasicDataSource类"><a href="#BasicDataSource类" class="headerlink" title="BasicDataSource类"></a>BasicDataSource类</h4><pre><code>* 数据源的规范接口javax.sql.DataSource的实现类
* 在org.apache.commons.dbcp中
* 方法: 
    * setXXX(参数): 设置驱动类,url,username,password基本信息
    * getConnection(): 获取数据库连接
* 常见配置项
    * 必须项
    * 基本项:
        * maxActive: 最大连接数量
        * minidle: 最小空闲连接
        * maxidle: 最大空闲连接
        * initialSize: 初始化连接
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//创建DataSource接口的实现类对象</span></div><div class="line">	BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</div><div class="line">	<span class="comment">//设置连接数据库的四个基本信息</span></div><div class="line">	dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">	dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/mybase"</span>);</div><div class="line">	dataSource.setUsername(<span class="string">"root"</span>);</div><div class="line">	dataSource.setPassword(<span class="string">"264329"</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">//调用getConnection()获取连接</span></div><div class="line">		Connection con = dataSource.getConnection();</div><div class="line">		System.out.println(con);</div><div class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据库连接失败"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用DBCP实现数据库的连接池"><a href="#使用DBCP实现数据库的连接池" class="headerlink" title="使用DBCP实现数据库的连接池"></a>使用DBCP实现数据库的连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">工具类:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</div><div class="line">	<span class="comment">//创建BasicDataSource类对象</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource datasource = <span class="keyword">new</span> BasicDataSource();</div><div class="line">	</div><div class="line">	<span class="comment">//静态代码块,对BasicDataSource对象进行配置</span></div><div class="line">	<span class="keyword">static</span>&#123;</div><div class="line">		<span class="comment">//必须项</span></div><div class="line">		datasource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">		datasource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/mybase"</span>);</div><div class="line">		datasource.setUsername(<span class="string">"root"</span>);</div><div class="line">		datasource.setPassword(<span class="string">"264329"</span>);</div><div class="line">		<span class="comment">//自定义基本项,可选配置</span></div><div class="line">		datasource.setInitialSize(<span class="number">10</span>);<span class="comment">//初始化的连接数</span></div><div class="line">		datasource.setMaxActive(<span class="number">8</span>);<span class="comment">//最大连接数量</span></div><div class="line">		datasource.setMaxIdle(<span class="number">5</span>);<span class="comment">//最大空闲数</span></div><div class="line">		datasource.setMinIdle(<span class="number">1</span>);<span class="comment">//最小空闲数</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//定义静态方法,返回BasicDataSource类的对象</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> datasource;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">测试工具类:</div><div class="line"><span class="number">1</span>.工具类返回的是一个DataSource接口的数据源</div><div class="line"><span class="number">2</span>.QueryRunner类的构造方法中可以直接接收DataSource接口的实现类</div><div class="line"><span class="keyword">import</span> java.sql.SQLException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</div><div class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ArrayListHandler;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">	<span class="comment">//QueryRunner类对象,写在类成员位置</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtils.getDataSource());</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//insert();</span></div><div class="line">		select();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//定义方法,实现数据的查询</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</div><div class="line">		String sql = <span class="string">"SELECT * FROM sort"</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			List&lt;Object[]&gt; list = qr.query(sql, <span class="keyword">new</span> ArrayListHandler());</div><div class="line">			<span class="keyword">for</span> (Object[] objs : list) &#123;</div><div class="line">				<span class="keyword">for</span> (Object obj : objs) &#123;</div><div class="line">					System.out.print(obj+<span class="string">"\t"</span>);</div><div class="line">				&#125;</div><div class="line">				System.out.println();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"查询数据失败"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//定义方法,实现数据的添加</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</div><div class="line">		String sql = <span class="string">"INSERT INTO sort (sname,sprice,sdesc) VALUES (?,?,?)"</span>;</div><div class="line">		Object[] params = &#123;<span class="string">"水果"</span>,<span class="number">100.00</span>,<span class="string">"香蕉	"</span>&#125;;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">int</span> row = qr.update(sql, params);</div><div class="line">			System.out.println(row);</div><div class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"添加数据失败"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">读取配置文件DBCP连接池工具类:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtilsConfig</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String url;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String username;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String password;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			readConfig();</div><div class="line">			dataSource.setDriverClassName(driverClass);</div><div class="line">			dataSource.setUrl(url);</div><div class="line">			dataSource.setUsername(username);</div><div class="line">			dataSource.setPassword(password);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="comment">//e.printStackTrace();</span></div><div class="line">			System.out.println(e);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据库连接失败"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readConfig</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		InputStream in = JDBCUtilsConfig.class.getClassLoader().getResourceAsStream(<span class="string">"database.properties"</span>);</div><div class="line">		Properties pro = <span class="keyword">new</span> Properties();</div><div class="line">		pro.load(in);</div><div class="line">		</div><div class="line">		driverClass = pro.getProperty(<span class="string">"driverClass"</span>);</div><div class="line">		url = pro.getProperty(<span class="string">"url"</span>);</div><div class="line">		username = pro.getProperty(<span class="string">"username"</span>);</div><div class="line">		password = pro.getProperty(<span class="string">"password"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> dataSource;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[18.MySQL数据库]]></title>
      <url>https://geekhoon.github.io/2017/02/28/18-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><pre><code>* 存储数据的仓库
* 数据库管理系统DBMS(DataBase Management System): 操作和管理数据库的大型软件
* 常用数据库: 
    1. MySQL: 开源免费.被Oracle收购.MySQL6.x后开始收费
    2. Oracle: 收费的大型数据库
    3. DB2: IBM公司的收费数据库,常用于银行系统
    4. SQLServer: 微软,收费的中型数据库
    5. SyBase: 淡出历史舞台了
    6. SQLite: 嵌入式的小型数据库,应用于手机端
</code></pre><a id="more"></a>    
<pre><code>* dos窗口开关MySQL服务:
    开: net start mysql
    关: net stop mysql
* dos窗口登录MySQL:
    mysql -u用户名 -p密码
</code></pre><h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><pre><code>* 结构化查询语言
* 分类:
    1. DDL:数据定义语言,用来定义数据库对象: create,alter,drop
    2. DML:数据操作语言,用来对数据库中表的数据进行更新: insert,delete,update
    3. DCL:数据控制语言,用来定义数据库的访问权限和安全级别，及创建用户 
    4. DQL:数据查询语言,用来查询数据库中表的数据: select,from,where
* 语法:
    1. 可以单行或多行书写, 分号结尾
    2. 不区分大小写. 但关键字一般大写
* 注释：
    * 单行: --
    * 多行: /* ... */
* 数据类型
    * int: 整型
    * double: 浮点
    * varchar(M): 字符,M为0-65535之间的整数
    * date: 日期,只有年月日,没有时分秒: yyyy-MM-dd
    * datetime: 日期时间都有
</code></pre><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><pre><code>1. 创建数据库: create database geekhoon;
   创建数据库,并指定数据库中数据的编码: create database geekhoon character set utf8;
2. 查看MySQL服务器中所有数据库: show databases;
   查看某个数据库的定义的信息: show create database geekhoon;
3. 删除数据库: drop database geekhoon;
4. 切换数据库: use geekhoon;
5. 查看正在使用的数据库: select database();
</code></pre><h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><pre><code>1. 创建数据表: create table 表名(
                列名1 数据类型 约束,
                列名2 数据类型 约束,
                ...
                列名n 数据类型 约束
              );
* 约束: 限制每一列能写什么数据,不能写什么数据
    分类:    
        1. 主键约束 primary key: 非空 唯一. 通常没有实际意义.
            加上AUTO_INCREMENT可实现自增长
        2. 非空约束 not null
        3. 唯一约束 
        4. 外键约束 
2. 删除数据表: drop table 表名;
3. 查看数据库中的所有表: show tables 
4. 查看表结构: desc 表名;
5. 修改表结构:
    * 添加列: alter table 表名 add 列名 数据类型 约束;
    * 修改列: alter table 表名 modify 列名 数据类型 约束;
    * 修改列名: alter table 表名 change 旧列名 新列名 数据类型 约束;
    * 删除列: alter table 表名 drop 列名;
    * 修改表名: rename table 表名 to 新表名;
    * 修改表的字符集:alter table 表名 character set 字符集;
</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>(</div><div class="line">	uid <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</div><div class="line">	uname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">	uaddress <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">);</div><div class="line"><span class="comment">-- 展示所有表</span></div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</div><div class="line"><span class="comment">-- 显示表结构</span></div><div class="line">DESC users;</div></pre></td></tr></table></figure>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><pre><code>1. 增加数据:(列名1为主键)
    * insert into 表名(列名1,列名2,列名3) values(值1,值2,值2);
    * insert into 表名(列名2,列名3) values (值2,值3); 省去主键不写
    * insert into 表名 values (全列值); 包括主键值也要写
    * 批量写入数据: insert into 表名 (列名1,列名2,列名3) values (值1,值2,值3),(值1,值2,值3),...;
2. 修改数据: (在数据原有基础上修改)
    * update 表名 set 列1=值1,列2=值2 where 条件
    * 条件的写法: 
        1. id = 5
        2. id &lt;&gt; 5 : 不等于5
        3. id &lt;= 5
        4. or : 或
        5. and : 与
        6. not : 非
        7. id in (1,3,4,5,6) : 表示包含的id
        8. id not in (1,3,4,5,6)
3. 删除数据: delete from 表名 where 条件
    * 删除表中所有记录使用delete from 表名, 还是用truncate table 表名 ?
      delete是一条一条的删, 不清空AUTO_INCREMENT记录数
      truncate直接将表删除,重新建表,AUTO_INCREMENT将置为0,重新开始
4. 查询数据
    * 查询指定列的数据: select 列名1,列名2 from 表名
    * 查询全部列的数据: select * from 表名
    * 查询去掉重复数据: select distinct 列名 from 表名
    * 查询重新命名列: select 列名 AS 新名 from 表名
    * 查询时直接运算: select 列名1,列名2+1000 as 新名 from 表名 : 列名2进行了运算,并用新名查询结果
* 命令行乱码问题: 
    * mysql的客户端编码的问题我们的是utf8,而系统的cmd窗口编码是gbk,在cmd下输出中文会乱码
    * 解决方案: 修改mysql客户端编码。
    * dos下:  set character_set_results=gbk;  或  set names gbk;
</code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><pre><code>* 格式: select 字段  from 表名  where 条件;    
* 比较运算符: 
    * &gt;  &lt;  &lt;=   &gt;=   =  &lt;&gt;
    * BETWEEN  ...AND... :显示在某一区间的值(含头含尾)
    * IN(set) :显示在in列表中的值，例：in(100,200)
    * LIKE :模糊查询
        * Like语句中有两个通配符：
        % 用来匹配多个字符；例 &apos;%a%&apos;;
        _ 用来匹配一个字符。例 &apos;a_&apos;;
    * is null :判断是空
    * is not null &quot;:判断不为空
</code></pre><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><pre><code>* order by 列名 [desc][asc]:排序要放在最后
* desc 降序
* asc 升序,默认升序
* 升序: select * from 表名 order by 列名
* 降序: select * from 表名 order by 列名 desc;
</code></pre><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><pre><code>* count：统计指定列不为NULL的记录行数；
* sum：计算指定列的数值和，如果指定列类型不是数值类型,则计算结果为0；
* max：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串类型排序运算；
* min：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；
* avg：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；
</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 统计行数</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="string">'count'</span> <span class="keyword">from</span> 表名;</div><div class="line"><span class="comment">-- 求和</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(money) <span class="keyword">from</span> zhangwu <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%支出%'</span>;</div><div class="line"><span class="comment">-- 求最大值</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">max</span>(money) <span class="keyword">from</span> zhangwu;//null值不会计算</div><div class="line"><span class="comment">-- 求平均值</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(money) <span class="keyword">from</span> zhangwu;//null值不会计算</div></pre></td></tr></table></figure>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><pre><code>* 格式:
    select 列1,列2 from 表名 where 条件 group by 列名 having 条件 order by 列名;
* group by 被分组的列名 : 要放在最后,有排序的话,排序放最后
* having 和 where的区别:
    1. having是在分组后对数据进行过滤
        where是在分组前对数据进行过滤
    2. having后面可以使用聚合函数进行判断
        where后面不可以使用聚合函数进行判断
* 分组查询必须跟随聚合函数
* 被分组的列也要在select中
</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 分组查询</span></div><div class="line"><span class="comment">-- 对zname内容进行分组, zname也要写在select后面</span></div><div class="line"><span class="keyword">SELECT</span> zname,<span class="keyword">SUM</span>(zmoney) <span class="keyword">FROM</span> zhangwu <span class="keyword">GROUP</span> <span class="keyword">BY</span> zname</div><div class="line"><span class="comment">-- 对zname内容进行分组查询求和,但是只要名称中包含"支付"的</span></div><div class="line"><span class="keyword">SELECT</span> zname,<span class="keyword">SUM</span>(zmoney) <span class="keyword">AS</span> <span class="string">'getsum'</span> <span class="keyword">FROM</span> zhangwu <span class="keyword">WHERE</span> zname <span class="keyword">LIKE</span> <span class="string">'%支出%'</span></div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> zname</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> getsum <span class="keyword">DESC</span></div><div class="line"><span class="comment">-- 对zname内容进行分组查询求和,但是只要名称中包含"支付"的,且和超过100的</span></div><div class="line"><span class="comment">-- 结果集是分组查询后,再次进行筛选,不能用where,要用having</span></div><div class="line"><span class="keyword">SELECT</span> zname,<span class="keyword">SUM</span>(zmoney) <span class="keyword">AS</span> <span class="string">'getsum'</span> <span class="keyword">FROM</span> zhangwu <span class="keyword">WHERE</span> zname <span class="keyword">LIKE</span> <span class="string">'%支出%'</span></div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> zname</div><div class="line"><span class="keyword">HAVING</span> getsum &gt; <span class="number">100</span></div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> zmoney <span class="keyword">DESC</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[17.多线程]]></title>
      <url>https://geekhoon.github.io/2017/02/25/17-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><pre><code>* 进程: 正在执行的程序. 当一个程序进入内存执行,即变成一个进程
* 线程: 进程中的一个执行单元,执行路径.
    * 单线程: 一个应用程序只有一条执行路径
    * 多线程: 一个应用程序有多条执行路径
</code></pre><a id="more"></a>
<pre><code>* 一个程序运行后至少有一个进程,一个进程中可以包含多个线程
* 线程的调度:
    * 分时调度: 所有线程轮流使用CPU的使用权,平均分配每个线程占用 CPU 的时间。
    * 抢占式调度: 优先让优先级高的线程使用 CPU,如果线程的优先级相同,那么会随机选择一个
* 对于CPU的一个核而言,某个时刻,只能执行一个线程,
   而 CPU的在多个线程间切换速度相对我们的感觉要快,看上去就是在同一时刻运行。
* 多线程程序并不能提高程序的运行速度,但能够提高程序运行效率,让CPU的使用率更高
* main的主线程: &quot;main&quot;
* 多线程的意义: 提高应用程序的使用率
* 多进程的意义: 提高CPU的使用率
* Java程序的运行原理: 
    Java命令去启动JVM,JVM会启动一个进程,该进程会启动一个主线程
* JVM的启动是多线程吗?
    是.因为它最低有俩个线程启动,主线程和垃圾回收线程 
</code></pre><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>* 是线程的一种实现方式
* Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程
* 多线程的实现方案:
    1. 继承Thread类
        该子类应重写 Thread 类的 run 方法。创建对象，开启线程。run方法相当于其他线程的main方法。
    2. 实现Runnable接口
        该类实现 run 方法, 然后创建Runnable的子类对象，传入到Thread子类的构造方法中，开启线程。
</code></pre><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><pre><code>* 创建和启动一个线程:
    1. 创建Thread子类对象, 继承Thread, 重写方法run()
    2. 子类对象调用start(): 让线程程序执行, JVM调用线程中的run 
        一个对象只能开启一次start(),多次启动一个线程是非法的
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">			System.out.println(<span class="string">"SubThread...."</span>+i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SubThread st = <span class="keyword">new</span> SubThread();</div><div class="line">		st.start();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">			System.out.println(<span class="string">"main...."</span>+i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//打印结果是SubThread....和main....无规律交叉打印,因为线程执行的随机性</span></div></pre></td></tr></table></figure>
<h4 id="为什么要继承Thread类"><a href="#为什么要继承Thread类" class="headerlink" title="为什么要继承Thread类"></a>为什么要继承Thread类</h4><pre><code>* 因为可以根据自己的需求重写run方法
* 注意start()和run()的区别:
    start(): 开启线程,并让JVM调用run()
    run(): 不开启线程
* 创建线程的目的: 让程序可以独立运行
</code></pre><h4 id="获取线程名字"><a href="#获取线程名字" class="headerlink" title="获取线程名字"></a>获取线程名字</h4><h5 id="getName"><a href="#getName" class="headerlink" title="getName()"></a>getName()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>: 返回该线程的名称, Thread类的方法</span></div><div class="line"><span class="keyword">public</span> class SubThread extends Thread &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="keyword">super</span>.getName());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SubThread st = <span class="keyword">new</span> SubThread();</div><div class="line">		SubThread st1 = <span class="keyword">new</span> SubThread();</div><div class="line">		st.start();</div><div class="line">		st1.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">打印结果: 获得的是当前线程的默认名字,根据线程被执行的先后顺序命名</div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div></pre></td></tr></table></figure>
<h5 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span>: 返回正在执行的线程对象, Thread类的方法</span></div><div class="line"><span class="comment">//如果要获取主线程的名字, 只能用此方法</span></div><div class="line"><span class="keyword">public</span> class Test &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//返回正在执行的线程的名字</span></div><div class="line">		System.out.println(Thread.currentThread().getName());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="设置线程名字"><a href="#设置线程名字" class="headerlink" title="设置线程名字"></a>设置线程名字</h4><pre><code>* 两种方式:
    1. 构造器
    2. setName()
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(getName());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubThread</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(<span class="string">"线程名2"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SubThread st1 = <span class="keyword">new</span> SubThread(<span class="string">"旺财"</span>);</div><div class="line">		st1.start();<span class="comment">//打印旺财</span></div><div class="line">		</div><div class="line">		SubThread st2 = <span class="keyword">new</span> SubThread();</div><div class="line">		st2.start();<span class="comment">//打印线程名2</span></div><div class="line">		</div><div class="line">		SubThread st3 = <span class="keyword">new</span> SubThread();</div><div class="line">		st3.setName(<span class="string">"线程名1"</span>);</div><div class="line">		st3.setName(<span class="string">"线程名3"</span>);</div><div class="line">		st3.start();<span class="comment">//打印线程名3</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="睡眠sleep"><a href="#睡眠sleep" class="headerlink" title="睡眠sleep()"></a>睡眠sleep()</h4><pre><code>* static void sleep(毫秒)
* main方法中和Thread子类的run()中都可以使用
* main()中可以抛异常
* run()中只能try/catch,不能抛异常,因为父类Thread没抛异常
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">做法一:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; i--) &#123;</div><div class="line">			<span class="keyword">try</span>&#123;</div><div class="line">				System.out.println(i);</div><div class="line">				Thread.sleep(<span class="number">1000</span>);</div><div class="line">			&#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"发射!!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		SubThread st = <span class="keyword">new</span> SubThread();</div><div class="line">		st.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">做法二:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; i--) &#123;</div><div class="line">			System.out.println(i);</div><div class="line">			Thread.sleep(<span class="number">1000</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"发射!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h3><pre><code>* 实现线程程序的另一个方式
* 实现接口Runnable, 重写run()
* 创建和启动一个线程: 
    1. 定义一个类,实现接口Runnable, 重写run()
    2. 测试类中创建Thread类对象,构造方法中,传递Runnable接口实现类
    3. Thread类对象调用方法start()
* 实现Runnable接口, 避免了继承Thread类的单继承局限性, 可以多实现
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 定义一个类,实现接口Runnable, 重写run()</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"..."</span>+i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//2. 测试类中创建Thread类对象,构造方法中,传递Runnable接口实现类</span></div><div class="line">		SubRunnable sr = <span class="keyword">new</span> SubRunnable();</div><div class="line">		Thread t = <span class="keyword">new</span> Thread(sr);</div><div class="line"><span class="comment">//3. Thread类对象调用方法start()		</span></div><div class="line">		t.start();</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"..."</span>+i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果是Thread-0..值 和 main...值交叉无规律打印</span></div></pre></td></tr></table></figure>
<h4 id="实现Runnable的好处"><a href="#实现Runnable的好处" class="headerlink" title="实现Runnable的好处"></a>实现Runnable的好处</h4><pre><code>* 避免了单继承的局限性
* 降低了程序的耦合性,Runnable接口对线程对象和线程任务进行解耦
</code></pre><h3 id="匿名内部类实现多线程程序"><a href="#匿名内部类实现多线程程序" class="headerlink" title="匿名内部类实现多线程程序"></a>匿名内部类实现多线程程序</h3><pre><code>* 前提: 继承或接口实现
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//方式一:new Thread类,调用start()</span></div><div class="line">	<span class="keyword">new</span> Thread()&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			System.out.println(<span class="string">"1.开启线程"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;.start();</div><div class="line">	<span class="comment">//方式二:new Runnable接口,作为Thread构造方法的参数,Thread对象调用start()</span></div><div class="line">	Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			System.out.println(<span class="string">"2.开启线程"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">new</span> Thread(r).start();</div><div class="line">	<span class="comment">//方式三: 将方式二两步合在一起</span></div><div class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			System.out.println(<span class="string">"3.开启线程"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><pre><code>1. NEW: 新建状态 new Thread()/Thread子类对象
2. RUNNABLE: 运行状态 start()
3. BLOCKED: 受阻塞状态 
4. TIMED_WAITING: 休眠  sleep()
5. WAITING: 等待     wait()/notify()唤醒
6. TERMINATED: 死亡状态  run()结束,stopr()
</code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><pre><code>* 容纳多个线程的容器
* 原理: 
    * 程序一开始的时候,创建多个线程对象,存储到集合中,需要线程时,从集合获取线程出来
    * 线程用完后,回到容器中,省去每次开启关闭线程的麻烦和资源浪费
* JDK1.5之后, 内置线程池技术
</code></pre><h4 id="使用线程池的方式"><a href="#使用线程池的方式" class="headerlink" title="使用线程池的方式"></a>使用线程池的方式</h4><pre><code>* Executors类
    * 创建线程池的工厂类
    * 方法:
        * static ExecutorService newFixedThreadPool(int nThreads): 返回线程池对象
            其实返回的是ExecutorService接口的实现类(线程池对象)
        * newSingleThreadExecutor()
        * shutdown(): 删除线程池
* 步骤:
    1. 使用工厂类Executors中的静态方法创建线程对象,指定线程个数
        static ExecutorService newFixedThreadPool(int nThreads)
    2. 接口实现类对象, 调用方法submit(Runnable r), 提交线程执行任务
        参数是Runnable接口的实现类
</code></pre><h4 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable<t>接口</t></h4><pre><code>* 实现线程的第三种方式
* 有返回值, 可以抛异常
* 重写call()
* 步骤: 
    1. 使用工厂类Executors中的静态方法创建线程对象,指定线程个数
        static ExecutorService newFixedThreadPool(int nThreads)
    2. 接口实现类对象, 调用方法submit(Callable&lt;T&gt; c), 提交线程执行任务
        参数是Callable接口的实现类 
        submit(Callable&lt;T&gt; c)返回Future&lt;T&gt;接口的实现类
        Future接口中有get(),可以获取返回值
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubCollable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="string">"geekhoon"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, ExecutionException </span>&#123;</div><div class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</div><div class="line">		Future&lt;String&gt; f1 = es.submit(<span class="keyword">new</span> SubCollable());</div><div class="line">		Future&lt;String&gt; f2 = es.submit(<span class="keyword">new</span> SubCollable());</div><div class="line">		String s1 = f1.get();</div><div class="line">		String s2 = f2.get();</div><div class="line">		System.out.println(s1);</div><div class="line">		System.out.println(s2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="线程实现异步求和"><a href="#线程实现异步求和" class="headerlink" title="线程实现异步求和"></a>线程实现异步求和</h4><pre><code>* 要求: 两个进程,1个进程求1+..100的和,另一个进程求1+..200的和
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">方式一: 使用Runnable接口</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubRunnable</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.num = num;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</div><div class="line">			sum += i;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//因为Runnable接口没有返回值,所以和要直接打印</span></div><div class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"..."</span>+sum);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SubRunnable sr1 = <span class="keyword">new</span> SubRunnable(<span class="number">100</span>);</div><div class="line">		SubRunnable sr2 = <span class="keyword">new</span> SubRunnable(<span class="number">200</span>);</div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread(sr1, <span class="string">"线程1"</span>);<span class="comment">//第二个参数就是设置当前进程的名字</span></div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread(sr2, <span class="string">"线程2"</span>);<span class="comment">//也可以用setName()</span></div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">方式二: 使用Callable接口</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubCallable</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.num = num;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</div><div class="line">			sum += i;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sum;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</div><div class="line">		Future&lt;Integer&gt; f1 = es.submit(<span class="keyword">new</span> SubCallable(<span class="number">100</span>));</div><div class="line">		Future&lt;Integer&gt; f2 = es.submit(<span class="keyword">new</span> SubCallable(<span class="number">200</span>));</div><div class="line">		System.out.println(<span class="string">"1 + .. + 100 = "</span>+f1.get());</div><div class="line">		System.out.println(<span class="string">"1 + .. + 200 = "</span>+f2.get());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//注意: 两种方法的run()和call()都是无参方法,只能通过构造方法进行传值</span></div></pre></td></tr></table></figure>
<h3 id="多线程安全问题"><a href="#多线程安全问题" class="headerlink" title="多线程安全问题"></a>多线程安全问题</h3><pre><code>* 判断多线程是否有安全问题的依据:
    1. 是否是多线程环境
    2. 是否有共享数据
    3. 是否有多条语句操作共享数据
* 解决安全问题,Java程序提供了同步技术
* 同步代码块公式:
    synchronized(任意对象){ 
        多条语句操作共享数据的代码
    }
* 特别注意: 同步代码块生效的前提是对象锁唯一,就是要用同一个对象
* 卖票问题:
    1. 同票多次: CPU的每一次执行,必须是一个原子性操作(最简单,最基本的操作).
        System.out.println(&quot;...卖了第&quot;+(100-ticketsCount+1)+&quot;票,剩&quot;+--ticketsCount+&quot;张&quot;);
        这一句就不是原子操作,因为既进行了打印又进行了递减操作,可能线程刚打印完还没进行自减
        此时第二个线程进来,抢占了CPU资源,于是打印的值就和前一个一样
    2. 负数票: 随机性和延迟导致的

* 解决方法:
    1. 同步代码块
    2. 同步方法: 同步方法(this)和静态同步方法(类名.class)
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">设置了休眠Thread.sleep(<span class="number">500</span>);引发了多线程安全问题</div><div class="line"><span class="comment">//出现多线程负数票的原因:</span></div><div class="line">当剩下最后一张票的时候,窗户<span class="number">1</span>进入一处并休眠,窗口<span class="number">2</span>也进入一处并休眠</div><div class="line"><span class="number">1</span>唤醒后,打印卖了<span class="number">100</span>张,剩<span class="number">0</span>张</div><div class="line">但此时窗口<span class="number">2</span>线程也在循环内,也进行打印,就出现了负值</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticketsCount = <span class="number">100</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="keyword">if</span> (ticketsCount &lt;= <span class="number">0</span> ) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">500</span>);<span class="comment">//一处</span></div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"...卖了第"</span>+(<span class="number">100</span>-ticketsCount+<span class="number">1</span>)+<span class="string">"票,剩"</span>+--ticketsCount+<span class="string">"张"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread my1 = <span class="keyword">new</span> MyThread();</div><div class="line">		<span class="keyword">new</span> Thread(my1, <span class="string">"窗口1"</span>).start();</div><div class="line">		<span class="keyword">new</span> Thread(my1, <span class="string">"窗口2"</span>).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">设置同步代码块,解决多线程安全问题</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticketsCount = <span class="number">100</span>;</div><div class="line">	<span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">	<span class="comment">//ticketsCount是共享数据, 所以要放在同步代码中</span></div><div class="line">				<span class="keyword">if</span> (ticketsCount &lt;= <span class="number">0</span> ) &#123;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">500</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"...卖了第"</span>+(<span class="number">100</span>-ticketsCount+<span class="number">1</span>)+<span class="string">"票,剩"</span>+--ticketsCount+<span class="string">"张"</span>);	</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread my1 = <span class="keyword">new</span> MyThread();</div><div class="line">		<span class="keyword">new</span> Thread(my1, <span class="string">"窗口1"</span>).start();</div><div class="line">		<span class="keyword">new</span> Thread(my1, <span class="string">"窗口2"</span>).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h4><pre><code>* 同步代码块传入的对象是任意对象, 这个对象也叫做同步锁,对象监视器
* 同步保证安全性: 没有锁的线程不能执行, 只能等
* 前提: 多线程
* 解决问题时要注意: 多个线程使用的是同一个锁对象
* 好处: 解决了多线程的安全问题
* 弊端: 线程很多时,每个线程都会判断同步上的锁,很耗费资源,并且降低程序运行效率
* 原理:
    1. 线程遇到同步代码块, 就会判断有没有同步锁,
    2. 有: 获取同步锁,进去同步代码中执行.
           执行完毕后, 将锁对象还回去
           在同步中的线程, 进行了休眠, 此时另一个线程会执行
           遇到同步代码块, 再一次判断有没有同步锁
       没有: 线程不能进去同步代码, 被阻挡在同步代码块外面
* 一个线程进入了同步代码块, 其余线程就进不去, 只能在线程代码块外面等
* 没有锁的线程,不能进入同步,在同步中的线程,不出去同步,不会释放锁
</code></pre><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><pre><code>* 采用同步方法形式, 解决线程的安全问题
* 好处: 代码简洁
* 将线程共享数据,同步,抽取到方法
* 在方法的声明上, 加上同步关键词synchronized
* 问题:
    1. 同步方法中有锁吗?
       有.同步方法中的对象锁就是本类对象的引用this
    2. 如果同步方法是静态的, 有锁吗?
       成员变量也要改成静态的. 也有锁. 锁不是this(因为静态随类的加载而加载,此时还没有对象)
       锁是本类的字节码文件对象(类名.class)
* 线程安全的类:
    1. StringBuffer
    2. Vector
    3. HashTable
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticketsCount = <span class="number">20</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			payTickets();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTickets</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (ticketsCount &gt; <span class="number">0</span> ) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">500</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"...卖了第"</span>+(<span class="number">20</span>-ticketsCount+<span class="number">1</span>)+<span class="string">"票,剩"</span>+--ticketsCount+<span class="string">"张"</span>);	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread my1 = <span class="keyword">new</span> MyThread();</div><div class="line">		<span class="keyword">new</span> Thread(my1, <span class="string">"窗口1"</span>).start();</div><div class="line">		<span class="keyword">new</span> Thread(my1, <span class="string">"窗口2"</span>).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">静态同步方法</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticketsCount = <span class="number">20</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			payTickets();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTickets</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (ticketsCount &gt; <span class="number">0</span> ) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">500</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"...卖了第"</span>+(<span class="number">20</span>-ticketsCount+<span class="number">1</span>)+<span class="string">"票,剩"</span>+--ticketsCount+<span class="string">"张"</span>);	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">或</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticketsCount = <span class="number">20</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			payTickets();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">payTickets</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span>(MyThread.class)&#123;<span class="comment">//锁是本类</span></div><div class="line">			<span class="keyword">if</span> (ticketsCount &gt; <span class="number">0</span> ) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">500</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"...卖了第"</span>+(<span class="number">20</span>-ticketsCount+<span class="number">1</span>)+<span class="string">"票,剩"</span>+--ticketsCount+<span class="string">"张"</span>);	</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="lock接口"><a href="#lock接口" class="headerlink" title="lock接口"></a>lock接口</h4><pre><code>* JDK1.5新特性
* 方法:
    1. void lock(): 上锁
    2. void unlock(): 解锁
* 实现类有ReentrantLock
* 加锁解锁位置与同步代码块一样
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticketsCount = <span class="number">20</span>;</div><div class="line">	<span class="comment">//在类的成员位置,创建Lock接口的实现类对象</span></div><div class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="comment">//调用lock获取锁</span></div><div class="line">			lock.lock();</div><div class="line">			<span class="keyword">if</span> (ticketsCount &gt; <span class="number">0</span> ) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">500</span>);</div><div class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"...卖了第"</span>+(<span class="number">20</span>-ticketsCount+<span class="number">1</span>)+<span class="string">"票,剩"</span>+--ticketsCount+<span class="string">"张"</span>);	</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;<span class="keyword">finally</span>&#123;</div><div class="line">					<span class="comment">//释放锁</span></div><div class="line">					lock.unlock();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread my1 = <span class="keyword">new</span> MyThread();</div><div class="line">		<span class="keyword">new</span> Thread(my1, <span class="string">"窗口1"</span>).start();</div><div class="line">		<span class="keyword">new</span> Thread(my1, <span class="string">"窗口2"</span>).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><pre><code>* 如果出现了同步嵌套, 就容易产生死锁
* 同步弊端: 1.效率低  2.容易产生死锁
* 死锁问题:
    是指两个或两个以上的线程在执行过程中,因争夺资源产生的一种互相等待的现象
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两把锁</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockA</span> </span>&#123;</div><div class="line">	<span class="comment">//私有化构造方法</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="comment">//使得对象只能通过类名.调用, 且保证唯一性</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LockA locka = <span class="keyword">new</span> LockA();</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockB</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LockB lockb = <span class="keyword">new</span> LockB();</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">				<span class="comment">//先进入A同步,再进入B同步</span></div><div class="line">				<span class="keyword">synchronized</span> (LockA.locka) &#123;</div><div class="line">					System.out.println(<span class="string">"if...loaka"</span>);</div><div class="line">					<span class="keyword">synchronized</span> (LockB.lockb) &#123;</div><div class="line">						System.out.println(<span class="string">"if...lockb"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="comment">//先进入B同步,再进入A同步</span></div><div class="line">				<span class="keyword">synchronized</span> (LockB.lockb) &#123;</div><div class="line">					System.out.println(<span class="string">"else...lockb"</span>);</div><div class="line">					<span class="keyword">synchronized</span> (LockA.locka) &#123;</div><div class="line">						System.out.println(<span class="string">"else...locka"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		DeadLock d = <span class="keyword">new</span> DeadLock();</div><div class="line">		Thread t0 = <span class="keyword">new</span> Thread(d);</div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread(d);</div><div class="line">		t0.start();</div><div class="line">		t1.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程间通信问题"><a href="#线程间通信问题" class="headerlink" title="线程间通信问题"></a>线程间通信问题</h3><pre><code>* 不同种类的线程间针对同一个资源的操作
* 可能出现的问题:
    1. 赋值不生效, 打印的是默认值: 操作不同资源类对象
    2. 同一数据出现多次: CPU的一点点时间片的执行权,就足够执行多次,Output的线程一直抢占,就会打印多次
    3. 姓名和性别不匹配: 线程运行的随机性
* 以下为操作不同资源类对象,产生null的代码
* 处理这个问题,可以在测试类中先创建好该对象,再作为参数,
  通过生产者Input,消费者Output各自的构造方法进行传参, 以达到操作同一资源的目的,完成线程间通信
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 资源类,有两个成员变量</div><div class="line"> * 有两个线程Input和Output分别对其赋值和打印</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> String name;</div><div class="line">	<span class="keyword">public</span> String sex;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 输入的线程,即生产者线程, 对资源对象Resource中成员变量赋值</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="comment">//注意:只声明了资源类对象,并没有new</span></div><div class="line">	<span class="keyword">private</span> Resource r = <span class="keyword">new</span> Resource();</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="comment">//这里加上同步锁,避免出现打印"张三...nv"和"lisi...男"的情况</span></div><div class="line">			<span class="comment">//特别注意:生产者消费者加的要是同一把锁,所以传的是唯一的Resource类对象</span></div><div class="line">			<span class="keyword">synchronized</span> (r) &#123;</div><div class="line">				<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">					r.name = <span class="string">"张三"</span>;<span class="comment">//如果不加同步代码块,且上一次打印的是lisi..nv,则执行到这一步,如果输出线程抢到了CPU,就会打印出张三...nv</span></div><div class="line">					r.sex = <span class="string">"男"</span>;</div><div class="line">				&#125;<span class="keyword">else</span>&#123;</div><div class="line">					r.name = <span class="string">"lisi"</span>;<span class="comment">//如果不加同步代码块,且上一次打印的是张三...男,执行到这一步时,输出线程抢到了CPU,就会打印出lisi...男</span></div><div class="line">					r.sex = <span class="string">"nv"</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> *  输出线程, 即消费者线程, 对资源对象Resource中成员变量,输出值</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> Resource r = <span class="keyword">new</span> Resource();</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="keyword">synchronized</span> (r) &#123;</div><div class="line">				System.out.println(r.name+<span class="string">"..."</span>+r.sex);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Input in = <span class="keyword">new</span> Input();</div><div class="line">		Output out = <span class="keyword">new</span> Output();</div><div class="line">		</div><div class="line">		<span class="keyword">new</span> Thread(in).start();</div><div class="line">		<span class="keyword">new</span> Thread(out).start();</div><div class="line">	&#125;</div><div class="line">&#125; </div><div class="line">打印结果是循环打印<span class="keyword">null</span>...<span class="keyword">null</span>, 原因是Input和Output中都重新<span class="keyword">new</span>了Resource对象</div><div class="line">它们操作的是不同对象</div></pre></td></tr></table></figure>
<h3 id="线程等待与唤醒机制"><a href="#线程等待与唤醒机制" class="headerlink" title="线程等待与唤醒机制"></a>线程等待与唤醒机制</h3><pre><code>* 等待唤醒机制所涉及到的方法,在Object类中:
    1. wait(): 等待, 将正在执行的线程释放其执行资格和执行权,并存储到线程池中。
    2. notify(): 唤醒, 唤醒线程池中wait()的线程,一次唤醒一个,而且是任意的。
    3. notifyAll(): 唤醒全部, 可以将线程池中的所有wait()线程都唤醒。
* 为什么这些方法不定义在Thread类中?
     因为这些方法的调用必须通过锁对象调用, 而同步代码块的锁对象是任意类型对象
* 唤醒: 让线程池中的线程具备执行资格。必须注意的是,这些方法都是在同步中才有效。
* 这些方法在使用时必须标明所属锁,这样才可以明确出这些方法操作的到底是哪个锁上的线程。
* 思路:
    1. 生产者: 先看是否有数据,有就等待,没有就生产,生产完之后,通知消费者消费数据
    2. 消费者: 先看是否有数据,有就消费,没有就等待,等待前,通知生产者生产数据
* 为什么变成了一个一个打印,而不是一片一片打印?
    因为等待唤醒机制,使得每生产一个数据就消费一个数据,生产完会暂停生产,待消费完再生产
    消费完会暂停消费,待生产完再消费,保证了每次只有一个数据在操作
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 资源类,有两个成员变量</div><div class="line"> * 有两个线程Input和Output分别对其赋值和打印</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> String name;</div><div class="line">	<span class="keyword">public</span> String sex;</div><div class="line">	<span class="comment">//设置布尔类型变量flag, 用于表示赋值和打印的状态</span></div><div class="line">	<span class="comment">//true表示,有数据, 赋值完成,需要进行输出操作了</span></div><div class="line">	<span class="comment">//false表示,没有数据, 需要进行赋值操作,此时不能进行输出操作</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 输入的线程,对资源对象Resource中成员变量赋值</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="comment">//注意:只声明了资源类对象,并没有new</span></div><div class="line">	<span class="keyword">private</span> Resource r;</div><div class="line">	<span class="comment">//用构造方法对Input,Output进行传参,使得Resource对象锁唯一</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Input</span><span class="params">(Resource r)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.r  = r;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="comment">//这里加上同步锁,避免出现打印"张三...nv"和"lisi...男"的情况</span></div><div class="line">			<span class="keyword">synchronized</span> (r) &#123;</div><div class="line">				<span class="comment">//判断有没有数据, true说明赋值完成,使对象等待</span></div><div class="line">				<span class="keyword">if</span> (r.flag) &#123;<span class="comment">// 1处</span></div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						r.wait();</div><div class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//为fasle,进行赋值操作</span></div><div class="line">				<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">					r.name = <span class="string">"张三"</span>;</div><div class="line">					r.sex = <span class="string">"男"</span>;</div><div class="line">				&#125;<span class="keyword">else</span>&#123;</div><div class="line">					r.name = <span class="string">"lisi"</span>;</div><div class="line">					r.sex = <span class="string">"nv"</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//有数据了,置为true</span></div><div class="line">				r.flag = <span class="keyword">true</span>;</div><div class="line">				<span class="comment">//唤醒,注意是资源类对象进行唤醒,唤醒消费者线程</span></div><div class="line">				r.notify(); <span class="comment">//唤醒消费者,并不意味着消费者线程马上执行,还是需要二者抢夺CPU</span></div><div class="line"><span class="comment">//如果生产者抢到了,会再次进入run(),有数据进入1处后,还是等待,此时消费者线程可以抢到CPU,从之前等待处唤醒,打印当前信息</span></div><div class="line"><span class="comment">//如果消费者抢到了,会从之前等待处唤醒,打印当前信息</span></div><div class="line">			&#125;</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> *  输出线程,对资源对象Resource中成员变量,输出值</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> Resource r;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Output</span><span class="params">(Resource r)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.r = r;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="keyword">synchronized</span> (r) &#123;</div><div class="line">				<span class="comment">//为false,说明输出完了,没有数据,就等待</span></div><div class="line">				<span class="keyword">if</span> (!r.flag) &#123;</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						r.wait();<span class="comment">//1处</span></div><div class="line"><span class="comment">//1处:消费者线程wait()后,立即释放锁.生产者线程就会执行, 消费者线程醒来的时候还是从本条语句醒来</span></div><div class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//为true,有数据就消费</span></div><div class="line">				System.out.println(r.name+<span class="string">"..."</span>+r.sex);</div><div class="line">				<span class="comment">//消费完, 没有数据了</span></div><div class="line">				r.flag = <span class="keyword">false</span>;</div><div class="line">				<span class="comment">//唤醒生产者线程</span></div><div class="line">				r.notify();<span class="comment">//注意唤醒生产者,不代表立即执行生产者线程</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 测试类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Resource r = <span class="keyword">new</span> Resource();</div><div class="line">		Input in = <span class="keyword">new</span> Input(r);</div><div class="line">		Output out = <span class="keyword">new</span> Output(r);</div><div class="line">		</div><div class="line">		<span class="keyword">new</span> Thread(in).start();</div><div class="line">		<span class="keyword">new</span> Thread(out).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><pre><code>1. start()和run()的区别:
    * run(): 封装了被线程执行的代码, 直接调用仅仅是普通方法的调用
    * start(): 启动线程, 并由JVM自动调用run()
2. sleep()和wait()的区别:
    * sleep(): 必须指定时间; 不释放锁
    * wait(): 可以指定时间,也可以不指定时间; 释放锁
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[16.IO流]]></title>
      <url>https://geekhoon.github.io/2017/02/20/16-IO%E6%B5%81/</url>
      <content type="html"><![CDATA[<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>* java.io.File 
* 文件和目录路径名的抽象表示形式
* 将操作系统中文件,目录(文件夹),路径,封装成File对象
* 提供方法, 操作系统中的内容
* File是与系统无关的类
</code></pre><a id="more"></a> 
<pre><code>* 文件 file
* 目录 directory
* 路径 path
</code></pre><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><pre><code>1. static String pathSeparator : 与系统有关的 路径分隔符
    Windows: 打印出来是一个分号
    Linux : 打印出来是一个冒号
2. static separator : 与系统有关的默认 名称分隔符
    Windows: 打印出来是一个 \
    Linux: 打印出来是一个 /
</code></pre><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code>1. File(String pathname) : 传递路径名, 将路径封装成一个File类型对象
    路径名中\,要写两个,因为要转义
2. File(String parent,String child) : 传递路径, 传递字符串父路径, 字符串子路径
    好处: 可以单独操作父路径与子路径
3. File(File parent, String child) : 传递路径, 传递File类型父路径, 字符串子路径
    好处: 父路径是File类型, 父路径可以直接调用File类方法
</code></pre><h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><pre><code>* 绝对路径: 具体的一个文件路径, 在系统中具有唯一性
* 相对路径: 表示的是路径之间的相对关系, 
</code></pre><h4 id="File类的功能"><a href="#File类的功能" class="headerlink" title="File类的功能"></a>File类的功能</h4><h5 id="1-创建功能"><a href="#1-创建功能" class="headerlink" title="1.创建功能"></a>1.创建功能</h5><pre><code>1. 创建文件: boolean createNewFile(), 创建的文件路径和文件名, 是在File构造方法中给出的
    File file = new File(&quot;c:\\a.txt&quot;);
    boolean b = file.createNewFile();
    如果创建的文件已存在, 不再重新创建.
    这个方法只能创建文件, 不能创建文件夹
2. 创建文件夹: boolean mkdir(), 创建的文件夹路径和文件夹名, 是在File构造方法中给出的
    如果创建的文件夹已存在, 不再重新创建
3. 创建多层文件夹: boolean mkdirs()
    推荐使用, 因为创建一层和多层文件夹都可以
</code></pre><h5 id="2-删除功能"><a href="#2-删除功能" class="headerlink" title="2.删除功能"></a>2.删除功能</h5><pre><code>1. 删除文件或文件夹: boolean delete(), 删除的文件或文件夹, 是在File构造方法中给出
    文件不存在或被打开, 则删除失败
    删除文件可以直接删除,删除文件夹要确保该文件夹是空的
    删除,不走回收站,直接从硬盘删除(需谨慎)
</code></pre><h5 id="3-获取功能"><a href="#3-获取功能" class="headerlink" title="3.获取功能"></a>3.获取功能</h5><pre><code>1. 返回路径中表示的文件或文件夹名: String getName()
    获取路径中最后部分的名字, 不管存不存在
2. 返回路径字符串: String getPath()
3. 返回路径中表示的文件的字节数: long length()
    只能拿到文件的字节数, 文件夹没有字节数
4. 获取String类型绝对路径: String getAbsolutePath()
5. 获取File类型绝对路径: File getAbsoluteFile()
    eclipse环境中, 写的是一个相对路径, 获得的绝对位置是当前工程根目录
6. 获取String类型父路径: String getParent()
7. 获取File类型父路径: File getParentFile()
8. 获取到File构造方法中封装的路径中的文件和文件夹名: String[] list()
    获取的是文件名
9. 获取到File构造方法中封装的路径中的文件和文件夹名: File[] listFiles()
    获取的是目录或者文件的全路径
    8和9中如果要获得D盘根目录下的内容,要写成&quot;D:\\&quot;,如果只写成&quot;D:&quot;,获得是当前工程目录下的内容
10. 返回的是根目录盘符: static File[] listRoots()
</code></pre><h5 id="4-判断功能"><a href="#4-判断功能" class="headerlink" title="4.判断功能"></a>4.判断功能</h5><pre><code>1. 判断File构造方法中封装路径是否存在: boolean exists()
2. 判断File构造方法中封装的路径是不是文件夹 boolean isDirectorty()
3. 判断File构造方法中封装的路径是不是文件 boolean isFile()
4. 判断是否是隐藏的 boolean isHidden()
</code></pre><h4 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h4><pre><code>* 过滤一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹
* 方法介绍
    * public File[] listFiles(FileFilter filter)
* 原理:
    * listFiles()遍历目录的同时，获取到了文件名全路径，
      调用过滤器的方法accept，将获取到的路径传递给accept方法的参数pathname
    * accept方法接收了参数pathname，参数是listFiles传递来的
    * 在accept方法中，进行判断，如果这个路径是Java文件，返回true，否则返回false
    * 一旦方法返回了true
    * listFiles将路径保存到File数组中
</code></pre><h4 id="遍历目录下的所有java文件"><a href="#遍历目录下的所有java文件" class="headerlink" title="遍历目录下的所有java文件"></a>遍历目录下的所有java文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">方式一: 自定义实现类,实现FileFilter接口,重写accep方法</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">FileFilter</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</div><div class="line"><span class="comment">//注意这个if条件的重要性: </span></div><div class="line"><span class="comment">//判断当前过滤到的是否是文件夹, 如果是文件夹, 返回true,则继续遍历该文件夹</span></div><div class="line"><span class="comment">//如果不加这个if,所有不是以.java为结尾的文件夹也被过滤掉,进不去文件夹内部进行遍历了</span></div><div class="line">		<span class="keyword">if</span> (pathname.isDirectory()) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\Demo"</span>);</div><div class="line">		getAllJava(file);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllJava</span><span class="params">(File file)</span></span>&#123;</div><div class="line">		File[] subFiles = file.listFiles(<span class="keyword">new</span> MyFilter());</div><div class="line">		<span class="keyword">for</span>(File subFile : subFiles)&#123;</div><div class="line">			<span class="keyword">if</span> (subFile.isDirectory()) &#123;</div><div class="line">				getAllJava(subFile);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				System.out.println(subFile);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">方式二: 使用匿名内部类</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\Demo"</span>);</div><div class="line">		getAllJava(file);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllJava</span><span class="params">(File file)</span></span>&#123;</div><div class="line">		File[] subFiles = file.listFiles(<span class="keyword">new</span> FileFilter() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</div><div class="line">				<span class="keyword">if</span> (pathname.isDirectory()) &#123;</div><div class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		<span class="keyword">for</span>(File subFile : subFiles)&#123;</div><div class="line">			<span class="keyword">if</span> (subFile.isDirectory()) &#123;</div><div class="line">				getAllJava(subFile);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				System.out.println(subFile);</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">方式三: 不使用文件过滤器, 自己写判断条件</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\Demo"</span>);</div><div class="line">		getAllJava(file);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllJava</span><span class="params">(File file)</span></span>&#123;</div><div class="line">		File[] subFiles = file.listFiles();</div><div class="line">		<span class="keyword">for</span> (File subFile : subFiles) &#123;</div><div class="line">			<span class="keyword">if</span> (subFile.isFile() &amp;&amp; subFile.getName().toLowerCase().endsWith(<span class="string">".java"</span>)) &#123;</div><div class="line">				System.out.println(subFile);</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (subFile.isDirectory()) &#123;</div><div class="line">				getAllJava(subFile);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="递归遍历全目录"><a href="#递归遍历全目录" class="headerlink" title="递归遍历全目录"></a>递归遍历全目录</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	File file = <span class="keyword">new</span> File(<span class="string">"D:\\demo"</span>);</div><div class="line">	getAllName(file);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllName</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">	<span class="comment">//打印当前文件名</span></div><div class="line">	<span class="comment">//System.out.println(file);</span></div><div class="line">	<span class="comment">//拿到file文件夹下所有内容</span></div><div class="line">	File[] subFiles = file.listFiles();</div><div class="line">	<span class="comment">//注意加上这步, 以免报错</span></div><div class="line">	<span class="keyword">if</span> (subFiles != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//遍历文件数组</span></div><div class="line">		<span class="keyword">for</span>(File subFile : subFiles)&#123;</div><div class="line">			<span class="comment">//如果是文件夹,继续递归调用getAllName</span></div><div class="line">			<span class="keyword">if</span> (subFile.isDirectory()) &#123;</div><div class="line">				getAllName(subFile);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="comment">//如果是文件, 直接打印</span></div><div class="line">				System.out.println(subFile);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="概念和注意事项"><a href="#概念和注意事项" class="headerlink" title="概念和注意事项"></a>概念和注意事项</h4><pre><code>* 方法自己调用自己, 方法频繁进栈
* 递归分两种, 直接递归与间接递归
* 注意:
 1. 递归一定要有出口,必须可以让程序停下
 2. 递归次数不能过多
 3. 构造方法,禁止递归
</code></pre><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	System.out.println(getFBNQ(<span class="number">12</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFBNQ</span><span class="params">(<span class="keyword">int</span> month)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span> (month == <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (month == <span class="number">2</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> getFBNQ(month-<span class="number">2</span>)+getFBNQ(month-<span class="number">1</span>);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><pre><code>* 输入Input:  文件到程序
* 输出Output: 程序到文件
* 输入输出以Java程序为参照
</code></pre><h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h4><pre><code>* java.io.OutputStream 所有字节输出流的父类
* 是一个抽象类
* 作用: 从Java程序,写出文件
* 字节: 这样的流每次只操作文件中的一个字节
* 可以写任意文件, 注意不是文件夹
</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><pre><code>1. write(int b): 写入一个字节, int可以变成byte
2. write(byte[] b): 写入字节数组
3. write(byte[] b, int off, int len): 写入字节数组, off是开始写入的索引,len是写几个
4. void close(): 关闭流对象,释放与流相关的资源, 关闭之前会调用flush方法
注意: 流对象, 操作文件的时候, 自己不做, 依赖操作系统
</code></pre><h5 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h5><pre><code>* OutputStream实现类
* 写入数据文件
* 构造方法:绑定输出的输出目的, 可以创建文件, 如果文件已存在, 直接覆盖
    * 参数(输出目的): 
        1. File 封装文件
        2. String 字符串的文件名
* 流对象使用步骤:
    1. 创键流子类的对象, 绑定输出目的
    2. 调用流对象的方法write写
    3. close释放资源
* 文件的续写和换行
    1. 续写使用FileOutputStream类构造方法: 
        * FileOutputStream(File file, boolean append)
        * FileOutputStream(String file, boolean append)
        append置为true, 可以续写
    2. 换行
        * \r\n
        * 可以写在上一行的末尾, 或者下一行的开头
        * fos.write(&quot;\r\n&quot;.getBytes());
* IO流中的异常处理
    try..catch..finally
    * 细节:
        1. 保证流对象变量, 作用域足够
        2. catch里面
           * 处理异常(输出异常信息)
           * 停止程序, 重新尝试
        3. 如果流对象建立失败了, 即new对象时失败了, 没有占用系统资源
           * 释放资源时, 对流对象进行判断null
           * 变量不是null, 对象建立成功, 需要关闭资源
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//1. 创建流对象, 绑定输出的输出目的</span></div><div class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>,<span class="keyword">true</span>);</div><div class="line">	<span class="comment">//2. 写入一个字节,会自动查ASCII表, 写入解码后的内容</span></div><div class="line">	fos.write(<span class="number">97</span>);<span class="comment">//这是一个字节</span></div><div class="line">	<span class="comment">//写入一个字节数组, 使用getBytes()后,查两次码表,第一次将字符串编码成对应的ASCII码</span></div><div class="line">	<span class="comment">//第二次是写入文件时, 将对应的ASCII码解码成对应的字符</span></div><div class="line">	<span class="keyword">byte</span>[] bytes = &#123;-<span class="number">65</span>,-<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</div><div class="line">	fos.write(bytes); <span class="comment">//写入了一个汉字和CD, 两个负数代表一个汉字</span></div><div class="line">	fos.write(<span class="string">"\r\n"</span>.getBytes());<span class="comment">//插入换行</span></div><div class="line">	fos.write(bytes,<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//写入字节数组的一部分, 写入了CD</span></div><div class="line">	<span class="comment">//写入字节数组的简便方式: 调用String类的getBytes()</span></div><div class="line">	fos.write(<span class="string">"www.geekhoon.com"</span>.getBytes());<span class="comment">//这是十六个字节 </span></div><div class="line">	foe.write(<span class="string">"你好"</span>.getBytes()); <span class="comment">//一个汉字是两个字节</span></div><div class="line">	<span class="comment">//3. 关闭流对象</span></div><div class="line">	fos.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IO流中异常处理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//声明变量</span></div><div class="line">	FileOutputStream fos = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		<span class="comment">//创建对象</span></div><div class="line">		fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\a.txt"</span>);</div><div class="line">		<span class="comment">//写入数据</span></div><div class="line">		fos.write(<span class="number">100</span>);</div><div class="line">	&#125;<span class="keyword">catch</span>(IOException ex)&#123;</div><div class="line">		<span class="comment">//打印异常信息</span></div><div class="line">		ex.printStackTrace();</div><div class="line">		<span class="comment">//如果是运行时异常,IOException处理不了,要抛异常</span></div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件写入失败,请重试"</span>);</div><div class="line">	&#125;<span class="keyword">finally</span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//判断对象是否创建成功</span></div><div class="line">			<span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</div><div class="line">				fos.close();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">		<span class="comment">//关闭流对象,添加try.catch的原因是,对象即使创建成功了,可能在写入过程中</span></div><div class="line">		<span class="comment">//突然将外界存储断开,则写入失败, 要抛运行异常</span></div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"关闭资源失败"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h4><pre><code>* java.io.InputStream 所有字节输入流的父类
* 是一个抽象类
* 作用: 读取任意文件, 每次只读取1个字节
</code></pre><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><pre><code>1. int read(): 读取一个字节
2. int read(byte[] b): 读取一定量的字节,存储到数组中
</code></pre><h5 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h5><pre><code>* InputStream实现类
* 构造方法: 为这个流对象绑定数据源
    * 参数(数据源)
        1. File 封装文件
        2. String 字符串的文件名
* 步骤:
    1. 创建字节输入流的子类对象
    2. 调用read读取
    3. 关闭资源
* read()执行一次, 自动读取下一个字节,返回值返回的是读取到的字节
    当读取到文件结尾时, 返回值为 -1 
* 注意一个点:
    fis.read()读的是字节,为啥返回int类型: 因为读到结尾返回-1, -1是两个字节,
    一个字节接收不了,所以使用int接收, 自动补齐32位
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//创建InputStream的实现类对象</span></div><div class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</div><div class="line">	<span class="comment">//定义len变量, 接收读到的字符</span></div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	<span class="comment">//循环调用读方法</span></div><div class="line">	<span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>)&#123;</div><div class="line">		<span class="comment">//len直接打印,会查ASCII,将字符转成ASCII值进行打印,所以要进行强转</span></div><div class="line">		<span class="comment">//如果文件中是0,不强转,打印的是48</span></div><div class="line">		System.out.print((<span class="keyword">char</span>)len);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//while循环的一种错误写法:</span></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 错误原因是: 每次执行fis.read(),都会读取到下一个字符,两次fis.read()读到的内容不一样</div><div class="line">	 * 和迭代器的next()道理类似</div><div class="line">	 * while(fis.read() != -1)&#123;</div><div class="line">	 * 		System.out.print(fis.read());</div><div class="line">	 * &#125;</div><div class="line">	 */</div><div class="line">	<span class="comment">//关闭流对象</span></div><div class="line">	fis.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="字节输入流FileInputStream读取字节数组"><a href="#字节输入流FileInputStream读取字节数组" class="headerlink" title="字节输入流FileInputStream读取字节数组"></a>字节输入流FileInputStream读取字节数组</h5><pre><code>* 数组作用:　缓冲, 提高效率
* read返回的int, 表示什么含义: 读取到的有效字节数
* int read(byte[] b): 读取到字节数组
* int read(byte[] b, int off, int len): 读取到字节数组, off是开始读取的索引,len是读几个
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//创建字节输入流对象</span></div><div class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</div><div class="line">	<span class="comment">//定义变量,接收read()返回值</span></div><div class="line">	<span class="keyword">int</span> len;</div><div class="line">	<span class="comment">//定义byte数组, 作为缓冲</span></div><div class="line">	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</div><div class="line">	<span class="comment">//循环读取, 判断条件使用的是int read(byte[] b),别忘传入b</span></div><div class="line">	<span class="keyword">while</span>((len = fis.read(b)) != -<span class="number">1</span>)&#123;</div><div class="line">		<span class="comment">//使用String类的构造方法 String(byte[] b), 字节数组转成字符串</span></div><div class="line">		System.out.print(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//关闭流对象</span></div><div class="line">	fis.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">将根目录下的a.txt的内容拷贝到b.txt中,考虑到可能复制的是大文件</div><div class="line">所以使用<span class="keyword">byte</span>数组,作为缓冲,提高效率</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	<span class="comment">//创建字节输入流对象</span></div><div class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</div><div class="line">	<span class="comment">//创建字节输出流对象</span></div><div class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</div><div class="line">	<span class="comment">//创建变量接收读的值</span></div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	<span class="comment">//创建byte数组,做缓冲, 作为参数传入read方法中</span></div><div class="line">	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">	<span class="comment">//循环读入a.txt中的内容,并写入b.txt</span></div><div class="line">	<span class="keyword">while</span>((len = fis.read(b)) != -<span class="number">1</span>)&#123;</div><div class="line">		fos.write(b,<span class="number">0</span>,len);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//释放资源</span></div><div class="line">	fis.close();</div><div class="line">	fos.close();</div><div class="line">	System.out.println(<span class="string">"拷贝完毕!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字节流复制文件读取"><a href="#字节流复制文件读取" class="headerlink" title="字节流复制文件读取"></a>字节流复制文件读取</h4><pre><code>* 字节输入流, 绑定数据源
* 字节输出流, 绑定数据目的
* 抛运行异常的原因是让程序停止.抛编译异常的话,异常后面的代码还会执行
* 可用于图片加密: 添加异或, 因为一个数异或一个数两次,还等于本身,可用于加密,解密
* 如fos.write(len ^ 123)
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">读一个字节,写一个字节</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//定义两个流对象的变量</span></div><div class="line">	FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">	FileOutputStream fos = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		<span class="comment">//new两个对象</span></div><div class="line">		fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>); <span class="comment">//绑定数据源</span></div><div class="line">		fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c.txt"</span>); <span class="comment">//绑定数据目的</span></div><div class="line">		<span class="comment">//定义变量接收read()返回值</span></div><div class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">		<span class="comment">//循环读取并写入</span></div><div class="line">		<span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>)&#123;</div><div class="line">			fos.write((<span class="keyword">char</span>)len);</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="keyword">catch</span>(IOException ex)&#123;</div><div class="line">		ex.printStackTrace();</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件复制失败"</span>);</div><div class="line">	&#125;<span class="keyword">finally</span>&#123;</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			<span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</div><div class="line">				fos.close();</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">catch</span>(IOException ex)&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</div><div class="line">		&#125;<span class="keyword">finally</span>&#123;</div><div class="line">			<span class="keyword">try</span>&#123;</div><div class="line">				<span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</div><div class="line">					fis.close();</div><div class="line">				&#125;</div><div class="line">			&#125;<span class="keyword">catch</span>(IOException ex)&#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">采用数组缓冲,提高效率</div><div class="line">读字节数组, 写字节数组</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//定义两个流对象的变量</span></div><div class="line">	FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">	FileOutputStream fos = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		<span class="comment">//new两个对象</span></div><div class="line">		fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>); <span class="comment">//绑定数据源</span></div><div class="line">		fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d.txt"</span>); <span class="comment">//绑定数据目的</span></div><div class="line">		<span class="comment">//定义变量接收read()返回值</span></div><div class="line">		<span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//len为每次读取的有效字节个数</span></div><div class="line">		<span class="comment">//定义数组, 作为缓冲</span></div><div class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">		<span class="comment">//循环读取并写入, 读数组,写数组</span></div><div class="line">		<span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</div><div class="line">			fos.write(bytes,<span class="number">0</span>,len);</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="keyword">catch</span>(IOException ex)&#123;</div><div class="line">		ex.printStackTrace();</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件复制失败"</span>);</div><div class="line">	&#125;<span class="keyword">finally</span>&#123;</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			<span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</div><div class="line">				fos.close();</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">catch</span>(IOException ex)&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</div><div class="line">		&#125;<span class="keyword">finally</span>&#123;</div><div class="line">			<span class="keyword">try</span>&#123;</div><div class="line">				<span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</div><div class="line">					fis.close();</div><div class="line">				&#125;</div><div class="line">			&#125;<span class="keyword">catch</span>(IOException ex)&#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	System.out.println(<span class="string">"复制结束"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h4><pre><code>* java.io.Writer 所有字符输出流的父类
* 只能写文本文件,文本文件就是能用记事本打开看的懂的文件
</code></pre><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><pre><code>1. write(int c): 写一个字符
2. write(char[] c): 写字符数组
3. write(char[] c, int off, int len): 字符数组一部分
4. write(String s): 写入字符串
</code></pre><h5 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h5><pre><code>* Writer的子类
* 构造方法: 
    绑定数据目的,注意是文件路径,不是文件夹路径,如果文件路径不存在,自动创建,存在则覆盖
    * File 类型对象
    * String 文件名
* 字符输出流写数据的时候, 必须要运行一个刷新功能flush()
* 建议write一次,flush一次, 最后close
</code></pre><h4 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h4><pre><code>* java.io.Reader 所有字符输入流的父类
* 只能读文本文件
* 不能读字符串
</code></pre><h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h5><pre><code>1. int read(): 读取一个字符
2. int read(char[] c): 读取一个字符数组
</code></pre><h5 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h5><pre><code>* Reader的子类
* 构造方法: 绑定数据源
    * File 类型对象
    * String 文件名
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">字符流完成文本文件复制</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">// 创建字符流对象</span></div><div class="line">	FileReader fr = <span class="keyword">null</span>;</div><div class="line">	FileWriter fw = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// new字符流对象</span></div><div class="line">		fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>); <span class="comment">// 绑定数据源</span></div><div class="line">		fw = <span class="keyword">new</span> FileWriter(<span class="string">"e.txt"</span>); <span class="comment">// 绑定数据目的</span></div><div class="line">		<span class="comment">// 定义变量,接收read返回值</span></div><div class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">		<span class="comment">// 定义字符数组,做缓冲</span></div><div class="line">		<span class="keyword">char</span>[] cBuff = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>]; <span class="comment">// 2KB</span></div><div class="line">		<span class="comment">// 循环读写</span></div><div class="line">		<span class="keyword">while</span> ((len = fr.read(cBuff)) != -<span class="number">1</span>) &#123;</div><div class="line">			fw.write(cBuff, <span class="number">0</span>, len);</div><div class="line">			<span class="comment">// 记住,写完要刷新</span></div><div class="line">			fw.flush();</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">		ex.printStackTrace();</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"复制失败"</span>);</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</div><div class="line">				fw.close();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</div><div class="line">					fr.close();</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="字符转字节的过程"><a href="#字符转字节的过程" class="headerlink" title="字符转字节的过程"></a>字符转字节的过程</h4><pre><code>* java.io.OutputStreamWriter 继承Writer类
* OutputStreamWriter的子类是FileWriter, 本质就是一个字符输出流, 操作字节输出流,写文本文件
* 字符流通向字节流的桥梁, 将字符流转成字节流
* 主要作用: 把java程序中写好的字符流转成可选的编码表对应的字节流, 然后通过字节输出流写入到文件中
* GBK中一个汉字2个字节, UTF-8中一个汉字3个字节
</code></pre><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code>1. OutputStreamWriter(OutputStream out): 接收字节输出流
    字节输出流: FileOutpuStream
2. OutputStreamWriter(OutputStream out, String charsetName): 接收字节输出流,转成对应编码的字节流输出流,再写入到数据目的 
    charsetName : 编码表名(不区分大小写)  可写的: GBK, UTF-8
    使用GBK的话, 不用在参数中传递GBK, 因为默认GBK
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	getGBK();</div><div class="line">	getUTF8();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getGBK</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	<span class="comment">//创建字节输出流</span></div><div class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\gbk.txt"</span>);</div><div class="line">	<span class="comment">//创建转换流对象, 包装字节输出流</span></div><div class="line">	OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"GBK"</span>);</div><div class="line">	<span class="comment">//写</span></div><div class="line">	osw.write(<span class="string">"你好"</span>);</div><div class="line">	<span class="comment">//关</span></div><div class="line">	osw.close();<span class="comment">//关闭转换流对象,字节输出流对象也跟着关闭了</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUTF8</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"><span class="comment">//创建字节输出流, 如果绑定数据目的是"UTF-8.txt",在eclipse中打开,还会乱码</span></div><div class="line"><span class="comment">//因为即使用UTF-8写进UTF-8.txt,但eclipse默认使用的是GBK码表,还会将UTF-8转成GBK,不在eclipse中打开就行</span></div><div class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\UTF-8.txt"</span>);</div><div class="line">	<span class="comment">//创建转换流对象</span></div><div class="line">	OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"UTF-8"</span>);</div><div class="line">	<span class="comment">//写</span></div><div class="line">	osw.write(<span class="string">"你好"</span>);</div><div class="line">	<span class="comment">//关</span></div><div class="line">	osw.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字节转字符的过程"><a href="#字节转字符的过程" class="headerlink" title="字节转字符的过程"></a>字节转字符的过程</h4><pre><code>* java.io.InputStreamReader ,继承Reader
* InputStreamReader的子类是FileReader, 本质就是一个字符输入流, 操作字节
* 字节流通向字符流的桥梁, 将字节流转成字符流
* 读取的方法: read() : 读取一个字符,也可以读取一个字符数组
</code></pre><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code>1. InputStreamReader(InputStream in)
2. InputStreamReader(InputStream in, String charsetName)
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//readGBK() ; //如果要读取一个GBK编码的文件,使用子类字符输入流FileReader或者字节输入流FileInputStream即可,无需指定编码表</span></div><div class="line">	readUTF8(); <span class="comment">//当需要读取一个UTF-8编码的文件时,需要使用转换流,指定转换后的字符流是UTF-8的格式</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readGBK</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	<span class="comment">//创建字节输入流</span></div><div class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\gbk.txt"</span>);</div><div class="line">	<span class="comment">//创建转换流对象,包装字节输入流</span></div><div class="line">	InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"GBK"</span>);</div><div class="line">	<span class="comment">//创建char[], 作为缓冲</span></div><div class="line">	<span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>((len = isr.read(c)) != -<span class="number">1</span>)&#123;</div><div class="line">		System.out.println(<span class="keyword">new</span> String(c,<span class="number">0</span>,len));</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//关闭流对象</span></div><div class="line">	isr.close();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readUTF8</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	<span class="comment">//创建字节输入流</span></div><div class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\UTF-8.txt"</span>);</div><div class="line">	<span class="comment">//创建转换流对象,包装字节输入流</span></div><div class="line">	InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>);</div><div class="line">	<span class="comment">//创建char[], 作为缓冲</span></div><div class="line">	<span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>((len = isr.read(c)) != -<span class="number">1</span>)&#123;</div><div class="line">		System.out.println(<span class="keyword">new</span> String(c,<span class="number">0</span>,len));</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//关闭流对象</span></div><div class="line">	isr.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="转换流和子类区别"><a href="#转换流和子类区别" class="headerlink" title="转换流和子类区别"></a>转换流和子类区别</h4><pre><code>* 继承关系
    OutputStreamWriter
        |--FileWriter
    InputStreamReader
        |--FileReader
* 区别:
    * 当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。
    * 以下三句话功能相同
    1. InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));//默认字符集。
    2. InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;GBK&quot;);//指定GBK字符集。
    3. FileReader fr = new FileReader(&quot;a.txt&quot;);
* 使用场景:
    1. 向数据目的中写入UTF-8格式的内容时, 需要用到OutputStreamWriter(OutputStream,&quot;UTF-8&quot;)
    2. 从数据源中读取UTF-8格式的内容时, 需要用到InputStreamReader(InputStream,&quot;UTF-8&quot;)
* 应用:
    1. 向一个文件中写入GBK格式的内容,读这个GBK格式的文件,生成内容与GBK格式相同的UTF-8格式的文件
        步骤:
        1. 写入GBK格式的内容:
            * FileWriter fw = new FileWriter(&quot;d:\\a.txt&quot;);
            * 或OuputStreamWriter osw = new OuputStreamWriter(new FileOutputStream(&quot;d:\\a.txt&quot;),&quot;GBK&quot;);
            * 或OuputStreamWriter osw = new OuputStreamWriter(new FileOutputStream(&quot;d:\\a.txt&quot;));
        2. 读GBK格式的内容:
            * FileReader fr = new FileReader(&quot;d:\\a.txt&quot;);
            * 或InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;d:\\a.txt&quot;),&quot;GBK&quot;);
            * 或InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;d:\\a.txt&quot;));
        3. 写入UTF-8格式:
            * OuputStreamWriter osw = new OuputStreamWriter(new FileOutputStream(&quot;d:\\b.txt&quot;),&quot;UTF-8&quot;);
    * 记住一句话: 什么格式的内容, 就是什么格式来读, 要写入什么格式, 就用什么格式来写
</code></pre><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><pre><code>* 提高IO流读写速度
* 分为字节缓冲流和字符缓冲流
* 装饰设计模式
</code></pre><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><pre><code>1. 字节输出缓冲流
    * java.io.BufferedOutputStream
    * 继承自OutputStream
    * 作用: 提高原有输出流的写入效率
    * 方法: write() 字节或字节数组
    * 先写入底层输出缓冲流,一定量后,再一起写入
    * 构造方法: 
        1. BufferedOutputStream(OutputStream out) :
        可以传递任意的字节输出流, 传递的是哪个字节流,就对哪个字节流提高效率
2. 字节输入缓冲流
    * java.io.BufferedInputStream
    * 继承自InputStream
    * 方法: read() 字节或字节数组
    * 构造方法:
        1. BufferedInputStream(InputtStream out)
        可以传递任意的字节输入流, 传递的是哪个字节流,就对哪个字节流提高效率
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">字节输出缓冲流</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedOutputStreamDemo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="comment">//创建字节输出流,绑定文件</span></div><div class="line">		<span class="comment">//FileOutputStream fos = new FileOutputStream("c:\\buffer.txt");</span></div><div class="line">		<span class="comment">//创建字节输出流缓冲流的对象,构造方法中,传递字节输出流</span></div><div class="line">		BufferedOutputStream bos = <span class="keyword">new</span></div><div class="line">				BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\buffer.txt"</span>));</div><div class="line">		</div><div class="line">		bos.write(<span class="number">55</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">byte</span>[] bytes = <span class="string">"HelloWorld"</span>.getBytes();</div><div class="line">		</div><div class="line">		bos.write(bytes);</div><div class="line">		</div><div class="line">		bos.write(bytes, <span class="number">3</span>, <span class="number">2</span>);</div><div class="line">		</div><div class="line">		bos.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">字节输入缓冲流</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStreamDemo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">		<span class="comment">//创建字节输入流的缓冲流对象,构造方法中包装字节输入流,包装文件</span></div><div class="line">		BufferedInputStream bis = <span class="keyword">new</span> </div><div class="line">				BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\buffer.txt"</span>));</div><div class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</div><div class="line">		<span class="keyword">int</span> len = <span class="number">0</span> ;</div><div class="line">		<span class="keyword">while</span>((len = bis.read(bytes))!=-<span class="number">1</span>)&#123;</div><div class="line">			System.out.print(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</div><div class="line">		&#125;</div><div class="line">		bis.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="四种文件复制效率分析"><a href="#四种文件复制效率分析" class="headerlink" title="四种文件复制效率分析"></a>四种文件复制效率分析</h4><pre><code>* 推荐使用第二种和第四种
</code></pre><h5 id="字节流读写单个字节"><a href="#字节流读写单个字节" class="headerlink" title="字节流读写单个字节"></a>字节流读写单个字节</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_1</span><span class="params">(File src,File desc)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</div><div class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(desc);</div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>)&#123;</div><div class="line">		fos.write(len);</div><div class="line">	&#125;</div><div class="line">	fos.close();</div><div class="line">	fis.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="字节流读写字节数组"><a href="#字节流读写字节数组" class="headerlink" title="字节流读写字节数组"></a>字节流读写字节数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_2</span><span class="params">(File src,File desc)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</div><div class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(desc);</div><div class="line">	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>((len = fis.read(b)) != -<span class="number">1</span>)&#123;</div><div class="line">		fos.write(b, <span class="number">0</span>, len);</div><div class="line">	&#125;</div><div class="line">	fos.close();</div><div class="line">	fis.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="字节流缓冲区流读写单个字节"><a href="#字节流缓冲区流读写单个字节" class="headerlink" title="字节流缓冲区流读写单个字节"></a>字节流缓冲区流读写单个字节</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_3</span><span class="params">(File src,File desc)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</div><div class="line">	BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(desc));</div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>((len = bis.read()) != -<span class="number">1</span>)&#123;</div><div class="line">		bos.write(len);</div><div class="line">	&#125;</div><div class="line">	bos.close();</div><div class="line">	bis.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="字节流缓冲区流读写字节数组"><a href="#字节流缓冲区流读写字节数组" class="headerlink" title="字节流缓冲区流读写字节数组"></a>字节流缓冲区流读写字节数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_4</span><span class="params">(File src,File desc)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</div><div class="line">	BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(desc));</div><div class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">	<span class="keyword">while</span>((len = bis.read(b)) != -<span class="number">1</span>)&#123;</div><div class="line">		bos.write(b,<span class="number">0</span>,len);</div><div class="line">	&#125;</div><div class="line">	bos.close();</div><div class="line">	bis.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><pre><code>1. 字符输出缓冲流
    * BufferedWriter, 继承自Writer
    * 方法: write() : 单个字符, 字符数组, 字符串
    * 构造方法:
        1. BufferedWriter(Writer w): 传递任意字符输出流
        传递谁,就高效谁
        能传递的字符输出流: FileWriter,OutputStreamWriter
    * BufferedWriter特有方法: newLine(): 实现换行,功能与\r\n一样,区别是这个方法可以跨平台
2. 字符缓冲输入流
    * BufferedReader, 继承自Reader
    * 有一个子类LineNumberReader, 可以读行号
    * 方法: read() 单个字符, 字符数组
    * 特有方法: String readLine(): 可以读取文本的一行, 返回值是String,读取到末尾,返回null
    * 构造方法:
        1.  BufferedReader(Reader r)
        能传递的字符输入流: FileReader,InputStreamReader
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">字符输出缓冲流</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//创建字符输出流</span></div><div class="line">	FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"D:\\a.txt"</span>);</div><div class="line">	<span class="comment">//创建字符输出缓冲流, 传入字符输出流,包装数据目的</span></div><div class="line">	BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</div><div class="line">	</div><div class="line">	bfw.write(<span class="number">97</span>);</div><div class="line">	bfw.newLine();</div><div class="line">	bfw.flush();</div><div class="line">	</div><div class="line">	bfw.write(<span class="string">"你好"</span>.toCharArray());</div><div class="line">	nfw.newLine();</div><div class="line">	bfw.flush();</div><div class="line">	</div><div class="line">	bfw.write(<span class="string">"大家好"</span>);</div><div class="line">	bfw.flush();</div><div class="line">	</div><div class="line">	bfw.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">字符输入缓冲流</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//定义计数变量作为行号</span></div><div class="line">	<span class="keyword">int</span> lineNumber = <span class="number">0</span>;</div><div class="line">	<span class="comment">//创建字符输入流</span></div><div class="line">	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"D:\\a.txt"</span>);</div><div class="line">	<span class="comment">//创建字符输入缓冲流,传递字符输入流,包装数据源</span></div><div class="line">	BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</div><div class="line">	<span class="comment">//定义String类型变量, 接收readLine()返回值</span></div><div class="line">	String line = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//循环读取</span></div><div class="line">	<span class="keyword">while</span>((line = bfr.readLine()) != <span class="keyword">null</span>)&#123;</div><div class="line">		lineNumber++;</div><div class="line">		System.out.println(lineNumber+<span class="string">"  "</span>+line);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//关闭缓冲流对象</span></div><div class="line">	bfr.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="使用字符缓冲流对象-复制文本文件"><a href="#使用字符缓冲流对象-复制文本文件" class="headerlink" title="使用字符缓冲流对象,复制文本文件"></a>使用字符缓冲流对象,复制文本文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">注意: </div><div class="line"><span class="number">1</span>.生成的b.txt会比a.txt大两个字节,因为写入最后一行后,又nextLine()了</div><div class="line"><span class="number">2</span>.注意这种读写方式,读一行,写一行,加一个换行,加一个刷新</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//创建字符输入缓冲流对象</span></div><div class="line">	BufferedReader bfr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"D:\\a.txt"</span>));</div><div class="line">	<span class="comment">//创建字符输出缓冲流对象</span></div><div class="line">	BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"D:\\b.txt"</span>));</div><div class="line">	<span class="comment">//创建String类型变量接收readLine()返回值</span></div><div class="line">	String line = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//循环读, 读一行, 写一行, 加一个换行</span></div><div class="line">	<span class="keyword">while</span>((line = bfr.readLine()) != <span class="keyword">null</span>)&#123;</div><div class="line">		bfw.write(line);</div><div class="line">		bfw.newLine();</div><div class="line">		<span class="comment">//刷新</span></div><div class="line">		bfw.flush();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//关闭流对象</span></div><div class="line">	bfw.close();</div><div class="line">	bfr.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="IO流对象的操作规律"><a href="#IO流对象的操作规律" class="headerlink" title="IO流对象的操作规律"></a>IO流对象的操作规律</h3><h4 id="IO流相关类继承关系"><a href="#IO流相关类继承关系" class="headerlink" title="IO流相关类继承关系"></a>IO流相关类继承关系</h4><pre><code>1. 字节流抽象父类:
        输入流:
            InputStream:
                |-- FileInputStream(字节输入流的子类)
                         |- read(int len) : 读取单个字节
                         |- read(byte[] b): 读取字节数组
                |-- BufferedInputStream(InputStream in)
        输出流:
            OutputStream:
                |-- FileOutputStream(字节输出流的子类)
                         |- write(int len) : 写出单个字节
                         |- write(byte[] b): 写出字节数组
                         |- write(byte[] b,int off,int len): 写出字节数组的一部分
                |-- BufferedOutputStream(OutputStream ou)
2. 字符流抽象父类
        输入流:
            Reader:
                |-- InputStreamReader(将字节转成字符)
                         |-- FileReader(字符输入流的子类)
                                |- read(char c) : 读取单个字符
                                |- read(char[] ch): 读取字符数组
                |-- BufferedReader(Reader r)
                         |- readLine() : 读取一整行
        输出流:  
            Writer:
                |-- OutputStreamWriter(将字符转成字节)
                         |-- FileWriter(字符输出流的子类)
                                |- write(char c) : 写出单个字符
                                |- write(char[] ch): 写出字符数组
                                |- write(String str): 写出字符串
                |-- BufferedWriter(Writer w)
                         |- newLine() : 写出一个换行
        对象操作流：
                |-- ObjectInputStream(对象输入流)
                         |- readObject();        对象必须实现序列化接口

                |-- ObjectOutputStream(对象输出流)
                            |- writeObject(Object obj)   
        打印流：
                PrintWriter:（流对象,boolean b）  如果是true、自动刷新
                    1.可以自动刷新
                    2.只能输出
                    3.println()(原样输出、并且自带换行)   print()   printf()
</code></pre><h4 id="操作规律"><a href="#操作规律" class="headerlink" title="操作规律"></a>操作规律</h4><pre><code>1. 如果操作的是纯文本文件, 直接使用带缓冲的字符流即可! 读一行,写一行
2. 如果操作的是所有文件,直接使用待缓冲的字节流即可! 带上小数组
3. 如果需要编码转换, 直接使用转换流即可!
</code></pre><h3 id="Properties集合类"><a href="#Properties集合类" class="headerlink" title="Properties集合类"></a>Properties集合类</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>* HashTable的子类, 实现Map接口
* 集合都是临时存储, 但Properties可以与IO对象结合使用,实现持久化存储
* 没有泛型(不能写泛型), 键值对都是字符串
</code></pre><h4 id="存储键值对"><a href="#存储键值对" class="headerlink" title="存储键值对"></a>存储键值对</h4><pre><code>* 特有方法:
    1. setProperty(String key, String value): 功能等同于Map中的put
    2. getProperty(String key): 通过键获取值, 功能等同于Map中的get(index)
    3. StringPropertyNames(): 将集合的键存储到Set集合, 类似与keySet
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Properties pro = <span class="keyword">new</span> Properties();</div><div class="line">pro.setProperty(<span class="string">"a"</span>, <span class="string">"1"</span>);</div><div class="line">pro.setProperty(<span class="string">"b"</span>, <span class="string">"2"</span>);</div><div class="line">pro.setProperty(<span class="string">"c"</span>, <span class="string">"3"</span>);	</div><div class="line">System.out.println(pro.getProperty(<span class="string">"a"</span>)); <span class="comment">//1</span></div><div class="line">System.out.println(pro.getProperty(<span class="string">"b"</span>)); <span class="comment">//2</span></div><div class="line">System.out.println(pro.getProperty(<span class="string">"c"</span>)); <span class="comment">//3</span></div><div class="line">System.out.println(pro.getProperty(<span class="string">"d"</span>)); <span class="comment">//null</span></div><div class="line"><span class="comment">//遍历</span></div><div class="line">Set&lt;String&gt; keySet = pro.stringPropertyNames();</div><div class="line"><span class="keyword">for</span> (String key : keySet) &#123;</div><div class="line">	System.out.println(key+<span class="string">"..."</span>+pro.getProperty(key));<span class="comment">//存取无序</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><h5 id="load"><a href="#load" class="headerlink" title="load"></a>load</h5><pre><code>1. load(InputStream in)
2. load(Reader r)
* 传递任意的字节或字符输入流
* 作用: 读取文件中的键值对到集合
* Properties并不是只能读.properties配置文件,.txt等文本也可以读,只是通常而已
* .properties代表键值对格式存储的文件
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">注意config.properties中写键值的时候,键和值后不要加空格或分号,否则就成为键或值的一部分了</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	Properties pro = <span class="keyword">new</span> Properties();</div><div class="line">	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"config.properties"</span>);</div><div class="line">	pro.load(fr);</div><div class="line">	fr.close();</div><div class="line">	System.out.println(pro);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="store"><a href="#store" class="headerlink" title="store"></a>store</h5><pre><code>1. store(OutputStream o, String comments)
2. store(Writer w, String comments)
* 接收所有的字节或字符输出流
* 作用: 将集合中的键值对写到文件
* String类型的comments写的是: 写回文件的原因,可以写&quot;&quot;,或者英文形式,如&quot;abc&quot;
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	Properties pro = <span class="keyword">new</span> Properties();</div><div class="line">	pro.setProperty(<span class="string">"name"</span>, <span class="string">"geekhoon"</span>);</div><div class="line">	pro.setProperty(<span class="string">"age"</span>, <span class="string">"11"</span>);</div><div class="line">	pro.setProperty(<span class="string">"blog"</span>, <span class="string">"www.geekhoon.com"</span>);</div><div class="line">	FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"config.properties"</span>);</div><div class="line">	pro.store(fw, <span class="string">"just a test"</span>);<span class="comment">//后面写原因,可以写""</span></div><div class="line">	fw.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象操作流"><a href="#对象操作流" class="headerlink" title="对象操作流"></a>对象操作流</h3><h4 id="对象的序列化与反序列化"><a href="#对象的序列化与反序列化" class="headerlink" title="对象的序列化与反序列化"></a>对象的序列化与反序列化</h4><pre><code>* 序列化: 对象中的数据,以流的形式,写入到文件中保存
* 反序列化: 在文件中,以流的形式,将对象读取出来
</code></pre><h4 id="ObjectOutputStream流写对象"><a href="#ObjectOutputStream流写对象" class="headerlink" title="ObjectOutputStream流写对象"></a>ObjectOutputStream流写对象</h4><pre><code>* 将对象数据写到文件中, 实现序列化
* 构造方法:
    * ObjectOutputStream(OutputStream out),传递任意的字节输出流
* 方法:
    * void writeObject(Object obj): 写出对象的方法
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">对象类,要实现Serializable接口</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	构造方法;</div><div class="line">	get/set;</div><div class="line">	toString();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//创建字节输出流,封装文件</span></div><div class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\person.txt"</span>);</div><div class="line">	<span class="comment">//创建序列化流的对象,构造方法传递字节输出流</span></div><div class="line">	ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</div><div class="line">	Person p = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">11</span>);</div><div class="line">	<span class="comment">//调用序列化流的方法writeObject,写出对象</span></div><div class="line">	oos.writeObject(p);</div><div class="line">	oos.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ObjectInputStream流读取对象"><a href="#ObjectInputStream流读取对象" class="headerlink" title="ObjectInputStream流读取对象"></a>ObjectInputStream流读取对象</h4><pre><code>* 从文件中读取对象数据, 实现反序列化
* 构造方法:
    * ObjectInputStream(InputStream in), 传递任意的字节输入流
    * 注意: 字节输入流封装的文件,必须是序列化的文件
* 方法:
    * Object readObject(): 读取对象
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\person.txt"</span>);</div><div class="line">	<span class="comment">//创建反序列化流的对象,构造方法传递字节输入流</span></div><div class="line">	ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</div><div class="line">	<span class="comment">//调用反序列化的方法readObject(),读取对象</span></div><div class="line">	Object obj = ois.readObject();<span class="comment">//readObject()要抛ClassNotFoundException这个异常</span></div><div class="line">	System.out.println(obj); <span class="comment">//打印Person [name=张三, age=11]</span></div><div class="line">	ois.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="静态不能序列化"><a href="#静态不能序列化" class="headerlink" title="静态不能序列化"></a>静态不能序列化</h4><pre><code>* 被static修饰的成员变量,属于类
* 非静态成员变量才属于对象
* 对象序列化和反序列化操作的是对象, 静态变量不能序列化
* 如: private static int age;
    * readObject()打印的结果就是Person [name=张三, age=0]
</code></pre><h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><pre><code>* 不能写成静态变量, 也不想被序列化, 需要使用transient关键字
* 作用: 阻止成员变量序列化
* 如:　private transient int age;
    * readObject()打印的结果就是Person [name=张三, age=0]
</code></pre><h4 id="Serializable接口的含义"><a href="#Serializable接口的含义" class="headerlink" title="Serializable接口的含义"></a>Serializable接口的含义</h4><pre><code>* 接口中并没有方法
* 这种接口称为标记接口
* 实现标记接口的实现类, 才可以序列化
</code></pre><h4 id="序列化中的序列号冲突问题"><a href="#序列化中的序列号冲突问题" class="headerlink" title="序列化中的序列号冲突问题"></a>序列化中的序列号冲突问题</h4><pre><code>* 序列化之后,还没进行反序列化,去把person类的内容进行了修改,再进行反序列化,会报错
</code></pre><h4 id="序列化中自定义的序列号"><a href="#序列化中自定义的序列号" class="headerlink" title="序列化中自定义的序列号"></a>序列化中自定义的序列号</h4><pre><code>*　(权限) static　final long serialVersionUID = 1L;
*　权限和值可以改,序列化之前可以改
* 类,自定义了序列号,编译器不会计算序列号
</code></pre><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><pre><code>* PrintStream类
* PrintWriter类
* 特点: 
    1. 此流不负责数据源, 只负责数据目的
    2. 为其他输出流, 添加功能
    3. 永远不会抛出IOException, 但是可能抛出其他异常 
* 两个打印流的方法完全一致
* 区别在于构造方法,就是打印流的输出目的端
    1. PrintStream: 构造方法,接收File对象,字节输出流OutputStream,字符串文件名
    2. PrintWriter: 构造方法,接收File对象,字节输出流OutputStream,字符串文件名, 字符输出流Writer
</code></pre><h4 id="打印流输出目的是File对象"><a href="#打印流输出目的是File对象" class="headerlink" title="打印流输出目的是File对象"></a>打印流输出目的是File对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\a.txt"</span>);<span class="comment">//a.txt原来不存在的话,也可以被自动创建,但是在读的时候不可以</span></div><div class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(file);</div><div class="line">pw.println(<span class="number">100</span>);<span class="comment">//文件中打印出的的是100, 原样输出</span></div><div class="line">pw.write(<span class="number">100</span>);<span class="comment">//文件中打印的出的是d,会查码表</span></div><div class="line">pw.flush();</div><div class="line">pw.close();</div></pre></td></tr></table></figure>
<h4 id="输出语句是char数组"><a href="#输出语句是char数组" class="headerlink" title="输出语句是char数组"></a>输出语句是char数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">字符串的本质是<span class="keyword">char</span>[], String str = <span class="string">"abc"</span>;等同于<span class="keyword">char</span>[] arr = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</div><div class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</div><div class="line">System.out.println(arr); <span class="comment">//打印的是abc, 而不是地址值</span></div></pre></td></tr></table></figure>
<h4 id="打印流输出目的是String文件名和流对象"><a href="#打印流输出目的是String文件名和流对象" class="headerlink" title="打印流输出目的是String文件名和流对象"></a>打印流输出目的是String文件名和流对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">打印流,输出目的是字符串文件名</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</div><div class="line">	PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"d:\\1.txt"</span>);<span class="comment">//文件可以自己创建</span></div><div class="line">	pw.println(<span class="string">"你好"</span>);</div><div class="line">	pw.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">打印流,输出目的是流对象</div><div class="line">可以是字节输出流OutputStream, 也可以是字符输出流<span class="function">Writer</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</div><div class="line">	<span class="comment">//FileOutputStream fos = new FileOutputStream("d:\\3.txt");//文件可以自己创建</span></div><div class="line">	FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"d:\\4.txt"</span>);<span class="comment">//文件可以自己创建</span></div><div class="line">	PrintWriter pw = <span class="keyword">new</span> PrintWriter(fw);</div><div class="line">	pw.print(<span class="string">"abc"</span>);</div><div class="line">	pw.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="打印流开启自动刷新"><a href="#打印流开启自动刷新" class="headerlink" title="打印流开启自动刷新"></a>打印流开启自动刷新</h4><pre><code>* 需要满足两个条件:
    1. 输出目的必须是流对象,OutputStream或Writer, 不可以是String类型文件名或File对象
    2. 必须调用println,printf,format方法中的一个
    3. PrintWriter(流对象,true);参数中要加上true
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\5.txt"</span>);</div><div class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(fos,<span class="keyword">true</span>);<span class="comment">//添加参数true, 可以实现自动刷新</span></div><div class="line">pw.println(<span class="string">"a"</span>);</div><div class="line">pw.println(<span class="string">"b"</span>);</div><div class="line">pw.println(<span class="string">"c"</span>);</div><div class="line"><span class="comment">//不需要刷新,现在运行,也可以在文件中打印abc</span></div><div class="line"><span class="comment">//但流对象还是要关闭</span></div><div class="line">pw.close();</div></pre></td></tr></table></figure>
<h4 id="打印流复制文本文件"><a href="#打印流复制文本文件" class="headerlink" title="打印流复制文本文件"></a>打印流复制文本文件</h4><pre><code>* 打印流只负责写
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	BufferedReader bfr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"d:\\a.txt"</span>));</div><div class="line">	PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"d:\\b.txt"</span>),<span class="keyword">true</span>);</div><div class="line">	String line = <span class="string">""</span>;</div><div class="line">	<span class="keyword">while</span>((line = bfr.readLine()) != <span class="keyword">null</span>)&#123;</div><div class="line">		pw.println(line);</div><div class="line">	&#125;</div><div class="line">	pw.close();</div><div class="line">	bfr.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第三方jar包"><a href="#第三方jar包" class="headerlink" title="第三方jar包"></a>第三方jar包</h3><h4 id="commons-io工具类"><a href="#commons-io工具类" class="headerlink" title="commons-io工具类"></a>commons-io工具类</h4><h5 id="FilenameUtils工具类"><a href="#FilenameUtils工具类" class="headerlink" title="FilenameUtils工具类"></a>FilenameUtils工具类</h5><pre><code>* 常用方法:
    1. static String getExtension(String filename): 获取文件扩展名
    2. static String getName(String filename): 获取文件名
    3. static boolean isExtension(String filename, String extension): 
        判断文件名的后缀是不是extension, 区分大小写
</code></pre><h5 id="FileUtils工具类"><a href="#FileUtils工具类" class="headerlink" title="FileUtils工具类"></a>FileUtils工具类</h5><pre><code>* 常用方法:
    1. static String readFileToString(File file): 读取文件内容，并返回一个String
    2. static void writeStringToFile(File file，String content): 将内容content写入到file中
    3. static void copyDirectoryToDirectory(File srcDir,File destDir): 文件夹复制
    4. static void copyFile(File srcFile,File destFile): 文件复制
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识总结]]></title>
      <url>https://geekhoon.github.io/2017/02/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>1.JDK和JRE的区别<br>答：JDK是java语言开发工具包，包含JRE和开发工具（javac.exe等）；JRE是java语言的运行环境，包含JVM和核心类库；JVM是java虚拟机，保证了java的跨平台性。<br><a id="more"></a><br>2.JVM跨平台吗？<br>答：JVM不具有跨平台性，不同的操作系统所对应的JVM不一样。正是因为JVM的不跨平台，才能够使java语言具有跨平台性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"你好"</span>);</div></pre></td></tr></table></figure></p>
<p>3.保留字是什么？<br>答：保留字是还未使用的关键字，可能在java以后的版本中使用。有goto和const。<br>    <code>System.out.println(&quot;你好&quot;);</code><br>4.java语言的特点？<br>答：开源，跨平台性，面向对象，多线程，多态。 </p>
<p>5.main是关键字吗？<br>答：不是的。main是主函数的名字，能够被虚拟机识别，是程序执行的入口。</p>
<p>6.path和classpath的区别？<br>答：path环境变量配置的是可执行文件.exe的执行路径;能够在任意地方访问path路径下的可执行文件。Classpath配置的java语言编译后生成的字节码文件的执行路径，作用是能够在任意地方使用配置后的字节码文件对象。</p>
<p>7.计算机最基本的存储单位是：字节（byte）<br>   计算机能直接识别的进制是：二进制<br>计算机底层运算采用的是二进制补码形式<br>Java语言最基本的单位是类<br>能够直接操作计算机硬件的高级语言是C语言</p>
<p>8.进行运算的时,变量和常量有什么区别?<br>答：变量在运算过程中的值是变化的，可以被多次赋值。<br>常量则是固定的，只能赋值一次。<br>**常量的初始化时机是什么？</p>
<p>9.标识符的组成？以及命名规则？<br>答：标识符有英文字母，数字,<em>和$组成。<br>    命名规则：不能使用关键字，不能数字开头，严格区分大小写，要见名知义。<br>    命名规范：<br>函数名和变量名如果是多个单词组成，第一个单词的首字母小写，其余首字母大写。<br>            类名和接口名如果是多个单词组成，首字母全部大写。<br>            包名全部小写，多级包中间用.隔开<br>            常量名全部大写，如果是多个单词，用</em>隔开。</p>
<p>10.变量数据类型分为哪几种？如何使用变量？<br>答：基本数据类型：整型：包括byte、short、int、long。浮点型：包括float、doble。<br>字符型;char;布尔型：boolean。<br>引用数据类型：数组、自定义类、接口。<br>变量需要先定义，再赋值，才能使用。<br>（变量必须先初始化，然后才能使用。）</p>
<p>11.常量分为哪几种？<br>答：自定义常量和字面值常量。自定义常量是我们自己通过final修饰定义的常量。字面值常量包括整数、小数、布尔、字符、字符串，null（空常量）。</p>
<p>12.byte的范围多少？char的范围多少？<br>答:byte范围-128到127 。   char范围0到65535.</p>
<p>13.ASCII码表中 字符 ‘0’  , ‘a’ , ‘A’ 分别对应int类型的值是多少.<br>答:0在表中对应的值是48，a对应的是97；A对应的是65.</p>
<p>14.long是8个字节,float是4个字节,为什么long 比 float小?<br>答：底层采用的运算规则不一样。一个是整型，一个是浮点型。</p>
<p>15.以取值范围的大小排列数据的基本类型.<br>答：double&gt;float&gt;long&gt;int&gt;char，short&gt;byte</p>
<p>16.+=、-=、这些运算符内隐含了强制类型转换。</p>
<p>17.++和—的使用？<br>答：单独使用的时候，在前在后都一样。<br>    参与运算的时候，在前是先自加或者自减，然后再用这个结果参与运算。在后是先参与运算，再进行自加或者自减。</p>
<p>18.逻辑或 “ | “ 和 短路或 “ || “有什么区别？<br>答：|不管前面的结果是真是假后面的都会运算，||前面为真后面的不参与运算。但是他们最终的运算结果是一样的。</p>
<p>19.逻辑与 “ &amp; “ 和 短路与 “ &amp;&amp; “ 由什么区别？<br>答：&amp;不管前面的结果是真是假后面的都会运算，&amp;&amp;前面为假后面的不参与运算。但是结果是一样的。</p>
<p>20.Math.round原理是什么？<br>答：round()方法是用来进行四舍五入操作的。原理是先加0.5，然后再取floor值。</p>
<p>21.生成随机数的方法？<br>答：第一种：Random类中的方法；第二种Math.random()方法，生成的是0.0和1.0范围直接的小数，包左不包右。</p>
<p>22.if…else..和三元表达的区别<br>答：能用三元表达式写的就能用if语句写，但是能用if语句写的，三元表达式不一定能写。if…else..是语句，三元表达式是一个运算符，必须要有一个结果。</p>
<p>23.while、do while 、for的区别？<br>答：for循环结束后，其中定义的初始化条件不能再使用。<br>do while语句是先执行后判断，while和for先判断后决定执行。</p>
<p>24.if和switch区别？<br>答：if常用来进行区间（范围）的判断 ，而switch常用来进行固定值的判断。</p>
<p>25.switch语句的表达式可以放什么？<br>答：byte、short、char、int。JDK1.5以后可以使用枚举，1.7之后可以使用String。</p>
<p>26.死循环的两种写法.<br>答：while(true)  和  for（；；）</p>
<p>27.break和continue的区别<br>答：break是完全跳出循环，不再执行循环体的代码。break还可以用于switch- case中。Continue是提前结束本次循环，进入下次循环。Return是结束方法。</p>
<p>28.switch中break可以省略吗？default可以省略吗？<br>答：break在最后一个可以省略，其他的不要省略，如果省略的话，可能会发生case穿透。看需求，Default可以省略，建议不要省略。</p>
<p>29：方法重载和方法重写的区别？<br>答：同一个类中出现方法名相同，参数列表不同的两个或以上的方法，称为方法重载。与返回值类型无关。<br>    方法重写是在子父类间，子类出现和父类声明完全相同的方法时，就成为方法重写。重写要求返回值必须相同 或者 有子父类关系。</p>
<p>30.定义方法的步骤是什么：<br>答:要明确方法的返回值类型，明确方法的参数列表。</p>
<p>31.方法的调用？<br>答：有返回值的方法可以单独调用，但是没有意义；也可以放在输出语句中；还可以赋值调用（推荐使用）。没有返回值的方法直接调用即可。</p>
<p>32.数组的定义格式？<br>答：int[] arr =new int[5];    //定义一个int 类型的数组，数组长度为5<br>    int arr[]= new int[5];    //定义一个int 类型的arr数组 长度为5<br>int[] arr = new int[]{1,5,6,7} //静态初始化<br>int[] arr = {23,6,8,9…}  //静态初始化<br>二维数组<br>String[][] arr = new String[3][];<br>Syso(arr[0])  打印的结果是null。</p>
<p>33.数组的默认值？<br>答;整型的默认值是0，double类型是0.0，引用数据类型是null；boolean型的是false。 Char = ‘\u0000’</p>
<p>34.栈内存和堆内存？<br>答：栈内存用于存储局部变量和所有代码的执行，<br>堆内存中存的都是所有new出来的东西。</p>
<p>栈，队列，数组，链表<br>35.数组和集合的区别：<br>（1）长度区别：数组长度是固定的；集合长度可变。<br>（2）存储内容：一个数组只能存储同一种数据类型（或者类型兼容）的元素；集合可以存储不同数据类型的元素。Object类型除外<br>Object[] obj = {};<br>（3）数据类型：数组既能存储基本数据类型，也能够存储引用数据类型；集合只能存储引用数据类型。</p>
<p>36.数组和集合的转换？<br>答：数组转为集合：Arrays.asList(数组)，转为集合后不能添加、删除元素。但是可以修改元素。把基本类型的数组转为集合，是将整个数组看作一个对象存入集合中。  ArrayList<int[]><br>集合转为数组：list.toArray().</int[]></p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>37.局部变量和成员变量的区别：<br>（1）定义位置不同：成员变量定义在类中方法外，局部变量定义在方法内或者方法的声明上。<br>（2）内存位置不同：成员变量存放在堆内存中，局部变量存放在栈内存中。<br>（3）初始化值不同：局部变量没有默认值，必须先赋值才能使用；成员变量有默认初始化值。<br>（4）生命周期不同：成员变量随着对象的存在而存在，随着对象的消失而消失；局部变量随着方法的调用而存在，方法调用完毕而消失。</p>
<p>38.变量的使用顺序？<br>答:就近原则。先在局部找，有就使用，没有就去本类的成员位置找，有就使用，没有就去父类找，有就使用，没有就报错。</p>
<p>39.类和对象的关系？<br>答：类是用来描述事物的属性和行为的，是一个抽象的概念；对象是类的实例化。</p>
<p>40.java描述事物最基本的单位？<br>答：类</p>
<p>41.什么叫面向对象？概述 思想特点 举例 总结<br>答：面向对象是一种编程思想，它是基于面向过程的，强调的用对象来完成各种事情（功能）。说到面向对象不得不提的就是他的三大思想特点1,2,3，<br>自己举例说明：厨师做饭，女朋友洗衣服。。。。。（最好能结合当时的场景）<br>总结：万物皆对象。</p>
<p>42.什么是封装？封装的原则？好处？<br>答：封装就是隐藏对象的属性和实现细节，仅对外提供公共的访问方式。。<br>原则：（1）将不需要对外暴露的信息隐藏；（2）对外提供公共的访问方式。<br>好处：将变化隔离；提高了安全性；便于使用，提高了重用性。</p>
<p>43.封装就是私有，对吗？为什么？<br>答：不对，private仅仅是封装的一种体现形式。我们常用的类，方法，函数也是封装。</p>
<p>44.Java中参数传递的问题：<br>答：Java中只有值传递，引用传递传递的是地址值。（这种说法的支持者是：高司令）<br>如果是基本数据类型，传递的是值，<br>如果是引用数据类型，传递的地址值（String类型作为方法的形参时，传递的是值）。</p>
<p>45.构造方法，set方法都可以给成员变量赋值，这两种赋值方式有什么区别？<br>答：构造方法主要作用是用来给对象初始化，赋值只是他的兼职工作，也可以不用赋值。//重复赋值是重新创建对象。<br>    Set方法只能用来赋值，在原有对象的基础上赋值。//可以重复赋值。</p>
<p>46.static关键字的特点？注意事项是什么？有什么好处和弊端？<br>答：（1）静态成员随着类的加载而加载（2）优于对象存在（3）能够被类名点的形式直接调用（4）资源共享。</p>
<p>注意事项：静态方法中不可以定义this、super关键字，因为静态优先于对象存在；静态只能覆盖静态。<br>好处：能够被类名点的形式调用，简化书写。被该类下所有的对象所共享。<br>弊端：生命周期过长。</p>
<p>47.类变量(静态变量)和实例变量（对象变量，成员变量）的区别？<br>答：（1）所属不同：类变量属于类，是对象的共性内容；实例变量属于对象，是对象的特性内容。<br>（2）存储位置不同：类变量存在方法区的静态区；实例变量存在堆内存中。<br>（3）生命周期不同：类变量随着类的加载而存在，随着类的消失而消失；实例变量随着对象的存在而存在，随着对象的消失而消失。<br>（4）调用方式不同：类变量既能被类名点的形式调用，也能被对象点的形式调用；而实例变量只能被对象点的形式调用。<br>48.构造方法能不能重载？<br>答：可以。因为重载与方法的返回值类型无关。</p>
<p>49.静态代码块和构造代码块的区别？<br>答：（1）静态代码块随着类的加载而加载，一般是用来加载驱动的<br>（2）构造代码块里边放的是所有构造方法的共性内容，它是优先于构造方法执行的。为了简化书写，调高效率。<br>50.什么是继承？<br>答：当多个类中有很多共性的内容时，我们可以把这些共性内容抽取出来封装成一个类，让这些类与这个封装的类产生关系。这种关系就是继承。</p>
<p>51.继承的的特点和好处，弊端？<br>答：特点：类与类之间的继承：只能单继承不能多继承，但是可以多层继承。<br>          接口与接口之间的继承：既可以单继承也可以多继承。<br>好处：（1）提高了代码的复用性（2）提高了代码的维护性（3）提高了代码的扩展性。（4）让类与类产生了关系，是多态的前提。<br>弊端：增强了类与类的耦合性。</p>
<p>52.this和super 的区别？<br>答：this代表本类当前对象的引用，super代表当前对象父类的内存空间标识（可以理解为父类引用）。</p>
<p>53．Super（）和this（）在构造方法能同时使用吗？<br>答 ：不能，super()调用的是父类的空参构造，this()调用的是本类的空参构造，他们都要放在第一行，所以不能同时使用。</p>
<p>Super关键字和this关键字能否在构造函数中共存？<br>答：能。</p>
<p>54.为什么每个构造函数中第一行都有默认的super()?<br>用于子类对象访问父类前，对父类数据进行初始化。</p>
<p>55.为什么默认的super()都是空参的呢？<br>因为Object类是所有 类的父类，Object中只有一个空参构造。</p>
<p>56.构造方法的特点？<br>答：（1）方法名和类名完全一致（2）没有返回值类型，连viod都没有。（3）没有明确的返回值，但是可以有return关键字;</p>
<p>57.this的作用？<br>答：（1）区别局部变量和成员变量（2）代表本类当前对象的引用（3）也可以用于构造方法的调用。</p>
<p>58.子父类都有静态代码块，构造代码块，构造方法，如果创建子类对象，那么他们六者之间的执行顺序是什么？<br>答：父类的静态代码块先执行，再执行子类中的静态代码块；接着执行父类的构造代码块和父类的构造方法，最后执行子类的构造代码块和构造方法。</p>
<p>59.final修饰的变量的初始化时机：<br>答：a.未被static关键字修饰</p>
<pre><code>* 可以显示初始化
* 可以在构造方法中初始化
</code></pre><p>b.被static修饰</p>
<pre><code>* 可以显示初始化
* 可以在静态代码块中初始化
* 不能在构造方法中初始化
</code></pre><p>60.final如果修饰局部变量，会发生什么事情？<br>答：基本类型，是值不能被改变，引用类型，是地址值不能被改变,对象中的属性可以改变。</p>
<p>61.什么是多态？多态的体现，前提，好处和弊端分别是什么？<br>答：同一事物在不同时刻表现出来的不同状态(形态)。<br>前提：（1）要有继承（或者实现）关系（2）要有方法重写（3）父类或者父接口引用指向子类对象。<br>好处：（1）提高了代码的维护性（2）提高了代码的扩展性<br>弊端：父类引用不能直接调用子类特有的属性和行为。</p>
<p><em>向上转型：父类或者父接口引用指向子类对象。
</em>向下转型：把那个引用强制转为子类对象。</p>
<p>62.多态中成员的访问特点是什么？<br>答：非静态方法，编译看左边，运行看右边。其他（变量，静态方法）都是编译和运行都看左边。原因是因为方法有重写。</p>
<p>63.抽象类和抽象方法的特点，有什么关系？<br>答：抽象类不能实例化，需要子类继承；抽象方法没有方法体，需要子类去重写。抽象类中不一定含有抽象方法，有抽象方法的类一定是抽象类。</p>
<p>64.抽象类中的抽象方法和非抽象方法的区别？<br>答：抽象方法要求子类必须重写，一般是用来强制要求子类完成某些事情的；非抽象方法让子类继承，提高代码的复用性。</p>
<p>65.abstract不能和哪些关键字共同存在？<br>答：abstract修饰的方法是抽象方法，没有方法体，而且要求子类必须重写。<br>private：私有的方法子类不能继承的，所以无法被复写，概念冲突。<br>    final：被final修饰的方法是最终方法，无法被复写，概念冲突。<br>    static：被static修饰的方法，可以被类名点的形式调用，而抽象方法是没有方法体的，所以类名点抽象方法无意义，所以不能共存。 </p>
<p>66.final修饰的变量、方法、和类有什么特点？<br>答：final是一个关键字，可以修饰变量，方法和类。final修饰的变量其实是一个常量；final修饰的 方法不能被子类重写；final修饰的类不能被继承，但是可以继承别的类。</p>
<p>67.final、finally、finalize的区别？<br>答：（1）final是一个关键字，是用来修饰类，成员变量，成员方法的，<br>        它修饰的类不能被继承，但是可以继承其他类，<br>        它修饰的成员变量是一个常量，只能赋值一次<br>        它修饰的成员方法不能被子类重写<br>  （2）finally是 try-catch-finally语句的一个模块，正常情况下里边的代        码永远会执行，一般是用来释放资源的<br>  （3）finalize是Object类中的方法，当对象变成垃圾的时候，由GC(Java        中的垃圾回收机制)来调用该类的finalize()方法回收垃圾。</p>
<p>68.接口中的成员的特点？<br>答：接口中有且只能有常量或者抽象方法。<br>因为常量的默认修饰符是public static final ;<br>方法的默认修饰符是：public abstract;</p>
<p>69、类与类、类与接口、接口与接口的关系？<br>答：<br>类与类之间是继承关系，只能单继承，不能多继承，但是能够多层继承；<br>类与接口之间是实现关系，可以单实现也可以多实现，还可以在继承一个类的同时实现多个接口。<br>接口与接口之间是继承关系，可以单继承也可以多继承。</p>
<p>70.接口和抽象类的区别？<br>（1）成员特点的区别：抽象类可以有变量、常量、构造方法、一般方法、抽象方法；接口有且只能有常量和抽象方法。<br>（2）关系特点的区别：<br>类与类之间是继承关系，只能单继承，不能多继承，但是能够多层继承；<br>类与接口之间是实现关系，可以单实现也可以多实现，还可以在继承一个类的同时实现多个接口。<br>接口与接口之间是继承关系，可以单继承也可以多继承；<br>（3）设计理念的区别：抽象类定义的是该继承体系的共性功能，是is a的关系。接口定义的是该体系的扩展功能，是like a的关系。</p>
<p>71.接口的思想特点？<br>（1）是程序对外暴露的规则（2）接口是程序对外的功能扩展（3）接口是用来多实现的（4）接口的出现降低了类与类之间的耦合性。</p>
<p>72．什么是内部类，特点是什么？<br>答：类中还有一个类，里边的那个类就是内部类。<br>特点（1）能够直接访问外部类的成员，包括私有的。（2）外部类访问内部类成员需要创建内部类的对象。</p>
<p>73.成员内部类是什么？<br>答：成员内部类是定义在成员位置的内部类。能够被私有、静态修饰。</p>
<p>74．内部类的方法如何访问局部变量，内部类的成员变量，外部类的成员变量？<br>答：局部变量可以直接访问；内部类的成员变量this.   ；外部类的成员变量：外部类名.this.</p>
<p>75.局部内部类访问其所在方法的局部变量时，该局部变量必须要加final修饰，为什么？<br>答案：为了延长该局部变量的生命周期。但是JDK1.8以后取消了这个特性，会默认加上final的。（所以我认为这是一个Bug）</p>
<p>答：因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用。但是JDK1.8以后取消了这个特性，会默认加上final的。（所以我认为这是一个Bug）</p>
<p>76．什么是匿名内部类？<br>答:匿名内部类就是没有名字的局部内部类，他的本质是一个继承了该类或者实现该接口的匿名的子类对象。<br>前提：必须要有一个类或一个接口。<br>使用：（1）当接口(抽象类)中的抽象方法只有一个时，并对方法调用一次的时候（2）如果方法的形参是接口或抽象类，也可以考虑使用匿名内部类。</p>
<p>77、匿名对象何时使用？<br>答：（1）当对对象方法调用一次的时候（2）可以作为实际参数进行传递。</p>
<p>79.四种权限修饰符的比较？<br>答：public  强调的是给大家使用<br>Protected强调的是给子类使用<br>默认     强调的是同一个包下的类  ——–default？？？？不等于？？<br>Private  强调的是给自己使用</p>
<p>80.package，import，class三者的顺序是什么？<br>package在第一行，只能有一个；然后是import导包，可以导多个包；最后是class，建议一个java文件中只写一个类（接口）。</p>
<p><em>*</em>公共类顶级类 在一个Java文件中只能有一个。文件名必须和顶级类名一致。</p>
<p>81.代码块的分类：<br>局部代码块：让变量尽早的消失，节约资源，提高效率。<br>构造代码块：用于给对象初始化；<br>静态代码块儿：一般是用来加载驱动。<br>同步代码块：用来解决多线程的安全问题的。  Synchronized</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>81.==和equals的区别？<br>答：“==”是比较运算符，既能比较基本数据类型，又能比较引用数据类型。基本数据类型比较的是数值，引用数据类型比较的是地址值。<br>equals是一个方法，只能比较引用数据类型。</p>
<p>82.String str = null 和String str = “”的区别？<br>答：null是空常量，而 双引号 是字符串类型的对象，只不过值为空。</p>
<p>83．String s1= “abc”, String s2= new String(“abc”),s1==s2结果是什么？s1.equals(s2)结果是什么？<br>答：s1==s2结果为false。s1指向的常量池中的对象，s2指向的是堆内存中的对象，两者的地址值不同。s1.equals(s2)结果是true。String重写了equals方法，比较的是内容。</p>
<p>84.String、StringBuffer、StringBuilder的区别？<br>答: String是长度固定的字符串，而其他两个是长度可变的字符串。</p>
<p>StringBuffer和StringBuilder的区别：<br> StringBuffer是JDK1.0版本的，线程是安全的，效率比较低。<br>StringBuilder是JDK1.5出现的，线程不安全，效率高。<br>他们的共同点是：都是长度可变的字符串。</p>
<p>85.StringBuilder的底层是什么？<br>答：底层是字符数组，原始长度为16。通过append添加元素的时候，会自动扩容，扩容规则：大字符串的长度= 小数组长度*2+2.</p>
<p>86.为什么出现基本数据类型包装类？<br>答：好处是：可以调用方法了，方便我们的操作。</p>
<p>87.String 和int直接的转换？<br>答：将int类型转为String类型的方法：（1）基本数据类型+“”（2）Integer.toString（int num）（3）String.valueOf（int  i）<br>将String转为int：Integer.parseInt(String s)</p>
<p>88.什么是自动拆装箱？<br>答：是JDK1.5版本出现的新特性，自动装箱就是把基本数据类型转为为包装类型。拆箱就是把包装类转换为基本数据类型。  Character Integer Double</p>
<p>89.Object类中的常见方法有哪些？<br>答：hashCode():返回值是int，是该对象的哈希玛值。<br>    equals():返回值是boolean，比较的是地址值。<br>    toString():返回该对象的字符串表现形式。<br>    getClass():返回值类型是Class。返回的是创建该对象所属类对应的字节码文件。<br>这些方法都需要对象调用，在开发的过程中要重写。<br>地址值的组成：全类名@十六进制的哈希值。</p>
<p>90.获取当前时间毫秒值有哪几种方式？<br>答：（1）new Date().getTime();（2）System. currentTimeMillis()（3）Calendar.getInstance().getTimeInMillis()</p>
<p>91.正则表达式常用的;<br>\d 数字：[0-9]<br>\w 单词字符：[a-zA-Z_0-9]<br>()表示分组<br>\1表示和前面的相同<br>. 任何字符  </p>
<p>X? ，一次或一次也没有<br>X* ，零次或多次<br>X+ ，一次或多次<br>X{n} ，恰好 n 次<br>X{n,} ，至少 n 次<br>X{n,m} ，至少 n 次，但是不超过 m 次</p>
<p>92.日历类和日期类相互转换：<br>Calendar c = Calendar.getInstance();  c.setTime(date);  c.getTime()</p>
<p>93.Date和String类型的转换？<br>Date类型转为String 是格式化：format<br>String转Date是解析；parse</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>94.简述集合体系？<br>答：集合分为单列集合和双列集合。<br>单列集合的顶层是Collection接口，包括List和Set集合。双列集合的顶层接口是Map。我们先来说下单列集合：<br>（1.1）List集合的特点是元素可重复，有序，有索引，能够有角标操作集合，有特有的迭代方式ListIterator。包括ArrayList、LinkedList和Vector。<br>ArrayList集合底层采用的是数组数据结构，查询速度比较快，因为数组有索引，在内存中分配的空间是连续的，但是增删比较慢。线程不同步，效率高。初始容量为10。<br>LinkedList集合的底层采用的是链表数据结构，增删速度比较快，查询速度比较慢。线程不同步。<br>Vector底层数据结构也是数组数据结构，但是线程同步，效率低，特有取出元素的方式是枚举。因为效率低，逐步被ArrayList替代。<br>（1.2） Set集合的特点元素是无序的（存入和取出的顺序不一致），元素不可以重复。包括HashSet和TreeSet。<br>    HashSet的底层数据结构是哈希表，线程不同步，效率高。保证元素的唯一性额有的依据是元素的hashCode和equals方法。如果hashCode不同，不调用equals方法。如果hashCode相同，才会调用equals方法判断元素是否相同。<br>    TreeSet的底层数据结构是二叉树，线程不同步，效率高。能够给元素进行排序。保证元素唯一性的依据是compareTo和return0。排序的两种方式：第一种元素自身实现Comparable接口，重写compareTo（）方法。这种排序方式叫元素的自热排序，也叫默认排序。第二种是当元素自身不具备比较性或者具备的比较性不是所需要的，这时就让集合自身具备比较性，当集合初始化时就有了比较性。定义一个比较器实现Comparator接口，重写compare方法，定义集合的时候将比较器作为参数传递给TreeSet的构造函数，这样集合就具有了比较性。<br>（2）Map是双列集合的顶层接口，该集合存储的是键值对，一对一对的往里存，而且要保证键的唯一性。包括Hashtable、HashMap、TreeMap。<br>    Hashtable的底层数据结构是哈希表，不可以存储null键和null值，线程同步，效率低。JDK1.0.<br>    HashMap的底层数据结构是哈希表，可以存储null键和null值，线程不同步，将Hashtable替代，JDK1.2效率高。保证键的唯一性的 依据是hashCode和equals方法。<br>    TreeMap的底层数据结构是二叉树，线程不安全，能够给集合中的键排序。</p>
<p>95.什么时候使用什么集合？<br>答：（1）首先要看是单列还是双列，是单列的话就用Collection，双列就用Map。<br>（2）要是单列的话看元素是不是要求重复，元素重复的话使用List，看查询多还是增删多，查询多的话用ArrayList，增删多的话用LinkedList，不确定的话用ArrayList。不重复的话使用Set，看是否要求排序，排序的话用TreeSet，不需要排序用HashSet。不确定的话用HashSet。<br>（3）要是双列的话，看是否要求排序，要求排序用TreeMap，不要求排序用HashMap，不确定的话用HashMap。</p>
<p>96.Collection（单列）和（Map）双列的区别？<br>答：Collection是单列集合，Map是双列集合。Map的键是唯一的，Collection体系中的Set集合中的元素是唯一的。Map集合的数据结构针对键有效，Collection的底层数据结构针对元素有效。</p>
<p>100.遍历集合的方式有哪些？<br>答：遍历List集合的方式有普通for、增强for、迭代器Iterator、列表迭代器ListIterator，转数组遍历<br>遍历Set集合的方式有增强for、迭代器Iterator。<br>遍历map集合的方式有keySet（），entrySet（）。然后通过增强for、迭代器Iterator遍历。</p>
<p>101.用迭代器和增强for遍历集合，能否用集合的方法操作集合？<br>答：不能，会出现并发修改异常，ConcurrentModificationException。<br>并发修改异常就是在用普通迭代器的时候用集合的方法增加、删除元素。可以用列表迭代器。</p>
<p>102.泛型是什么？有什么好处？<br>答：泛型是泛指某种具体的类型，是JDK1.5出现的新特性，用于解决安全问题，是一种类型安全机制。<br>好处：（1）将运行时期会可能出现的异常转移到编译期<br>（2）提高了安全性。<br>（3）避免了强制类型转换的麻烦。<br>（4）优化程序设计。</p>
<p>103、向上限定和向下限定？<br>？ super E：  E以及E的父类，固定下边界，向上限定。<br>？ extends E： E以及E的子类  固定的上边界，向下限定。</p>
<p>104.字典排序，自然排序和比较器排序是什么？<br>答：字典排序按照字典上的顺序升序排序。 A-Z<br>    自然排序是强制对实现Comparable接口的类进行排序，实现Comparable接口，重写compareTo（）方法，根据返回值进行排序。<br>    比较器排序是实现Comparator接口，重写compare（）方法，根据返回值进行排序。</p>
<p>106.Map有哪些取出元素的方式？原理是什么？<br>答：根据键获取其对应的值。通过keySet()和get（Key）方法结合实现。<br>根据键值对获取其对应的键和值。通过entrySet()和 getKey(),getValue（）方法结合实现。</p>
<p>107.Collections 和 collection的区别？<br>答：Collections是用来操作单列集合的工具类，里边定义了一些常用的操作单列集合的方法；而collection是单列集合的顶层接口，里边定义了单列集合的共性内容。</p>
<p>108：<br><em>栈和队列：<br>队列结构：先进先出的规则<br>栈结构：先进后出规则
</em>链表和数组的区别：<br>数组：一块连续的存储区域，每个元素都有编号，编号是从0开始的。特点是查询快。<br>链表结构：每个元素指向下一个元素.特点是：增删快。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>109.异常体系概述？<br>答:Throwable类<br>        |–Error：无法通过处理解决的错误,数据库崩溃，服务器宕机<br>        |–Exception：<br>            |–编译时异常: 非RunTimeException及其子类<br>            |–运行时异常: RunTimeException及其子类</p>
<p>110.异常处理有哪些方式？<br>答（1）try-catch<br>（2）throws</p>
<p>111.运行异常和编译异常的区别？<br>答：<br>运行时异常不处理也能通过编译，RuntimeException及其子类都是运行时异常。<br>而编译期异常必须处理，才能通过编译。非RuntimeException及其子类都是编译期异常。</p>
<p>112.throw和throws的区别？<br>答：throws<br>定义在方法的声明上，后面跟的是异常类名；<br>可以跟多个异常类名，用逗号隔开；<br>表示抛出异常，需要由调用者处理。<br>Throw<br>定义在方法体内，跟的异常对象名；<br>只能跟一个异常对象，<br>表示抛出异常，由方法内部的语句来处理。</p>
<p>113.子父类间异常的注意事项？<br>答：<br>子类不能出现父类没有的异常。<br>父类没有抛异常，子类有异常只能try不能抛。<br>关于异常处理，能try就try，try不了就抛</p>
<p>114.异常处理的注意事项：<br>（1）    子类不能出现父类没有的异常<br>（2）    父类没有抛异常，子类有异常只能try不能抛。<br>（3）    关于异常的处理，能try就try，try不了就抛（throws）</p>
<p>116.JVM是如何处理异常的？<br>先自己处理，处理不了交给调用者处理。</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>117.递归的注意事项？<br>答：1.递归必须要有出口，否则容易造成栈内存溢出。<br>2.递归调用次数不能过多，否则容易造成栈内存溢出。<br>3.构造方法不能递归调用。</p>
<p>117.路径的分类？<br>答：分为相对路径和绝对路径。绝对路径是以盘符开头的。相对路径一般是相对于当前项目来讲的。</p>
<p>118.集合的顶层是什么？IO的顶层是什么？<br>答：集合的顶层是接口。IO的顶层的是抽象类。</p>
<p>119.什么IO流？<br>IO流是用来在硬盘和内存之间进行数据交换的。<br>而I是Input的缩写，代表输入流。O是Output的缩写，代表输出流。</p>
<p>120：简述IO的分类？<br>答：按照流向分输入流和输出流。输入流是用来读取数据的，输出流是往外写数据的。<br>按照操作分为字节流和字符流。<br>字节流能操作任意类型的文件，如果操作文本，可能会出现乱码。字符流只能操作纯文本文件。 </p>
<p>121.为什么read（）方法返回值是int类型？<br>答:为了防止中间出现11111111（-1的补码）这样的数据，后面的内容就读不到了。</p>
<p>122.字符流通往字节流的桥梁是什么？字节流通往字符的桥梁是什么？<br>答：字符流通往字节流的桥梁是OutputStreamWriter；字节流通往字符流的桥梁是InputstreamReader。<strong><em>*</em></strong></p>
<p>123.标准输入流和输出流是什么？<br>答：标准输入流的是System.in。默认指向键盘，可以获取用户录入的数据。<br>标准输出流是System.out.默认指向控制台，可以把结果打印在控制台上。</p>
<p>124.高效字符流的方法？<br>ReadLine()读不到\r\n<br>newline()针对当前操作系统换行  BufferedWriter</p>
<p>125.字节输入流read()一次读取的一个字节，返回的字节的对应的ASCII值。<br>字符输入流呢？</p>
<p>126.字符缓冲流和字节缓冲流的缓冲区的默认大小是多少？<br>答：字符缓冲流缓冲区默认的大小是8192个字符，16kb。<br>    字节缓冲流缓冲区默认的大小是8192个字节，8kb。<br>Writer的2kb。</p>
<p>127.close（）和flush（）的区别：<br>答：flush()方法是来刷新缓冲区的，刷新之后还可以再次写出。<br>Close()是用来关闭流释放资源的，如果是带缓冲区的流对象关闭流之前还会刷新缓冲区，关闭之后无法写出。</p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>128.什么是网络编程？<br>答：网络编程又叫套接字编程，Socket编程，就是用java语言来实现网络互联的不同计算机间的数据通信。</p>
<p>129.网络编程的三要素？<br>答：IP地址、端口、协议。<br>IP的组成网关和主机地址。127.0.0.1本地回环(路)地址   255.255.255.255广播地址</p>
<p>130.端口的范围是什么？哪个范围的端口不能用，为什么？<br>答：端口的范围是0——65535.   0——1024这个范围的端口不能使用，因为已经被系统占用或者作为保留端口。</p>
<p>131.TCP和UDP协议的区别？<br>答：<br>TCP是面向有连接的，三次握手机制；<br>传输的数据是通过IO流的方式，无大小限制；<br>安全（可靠）协议；<br>效率低；<br>区分客户端和服务器端。</p>
<p>UDP是面向无连接的，<br>发送的数据是通过数据报包的形式，不超过64k；<br>不安全（可靠）协议；<br>效率高；<br>不区分客户端和服务器端。（叫发送端和接收端）</p>
<p>132.Socket通信的原理是是什么？<br>答：通信的两端都有独有的Socket， Socket通信指的是在两个Socket之间通过IO流互相传输数据。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>133.进程和线程？<br>进程是可执行的程序（.exe）。<br>线程是是进程的执行路径(执行单元)。<br>多线程：进程有多条执行路径，合起来就是多线程。</p>
<p>134.多线程并发和多线程并行是什么呢?<br>答：多线程并发指的是：两个或者多个任务同时请求执行，但是CPU同时只能执行一个，就会安排它们交替执行，因为间隔的时间比较短，我们看起来像同时执行的。</p>
<p>并行是两个或多个任务同时执行，前提是需要有多核CPU。</p>
<p>135.多线程的执行原理？<br>答：多线程的执行具有随机性和延迟性。 因为CPU在做着高速的切换。</p>
<p>136.线程的执行具有随机性和延迟性。</p>
<p>137.线程的默认命名规则？<br>答：Thread-编号，编号是从0开始的。</p>
<p>138.线程的优先级的范围是多少？默认的优先级是？<br>答：线程的优先级范围是1——10。默认的优先级是5.</p>
<p>139.Java程序的启动原理？<br>答：先开启JVM，JVM启动一个主线程，再由主线程调用某个类的main方法。</p>
<p>140.Java程序是多线程的吗？<br>答：是的，至少开启了主线程和垃圾回收线程。</p>
<p>141.线程的优先级越高，代表这个线程一定是第一个执行的吗？<br>答：不是，线程的优先级越高代表着在一定程度上让该线程可以获取更多的执行机会（执行权）。</p>
<p>142.线程的两种实现方式的区别？<br>答：<br>继承Thread类：<br>好处是：代码简单。因为是继承，所以能够直接使用Thread类的方法。<br>弊端是：扩展性比较差，因为继承了Thread类，所以不能再继承其他的            类。<br>实现Runnable接口：<br>好处是：扩展性比较强。<br>缺点时：代码比较冗余，因为不是继承Thread类，无法直接使用thread中的方法。</p>
<p>143.同步代码块和同步方法的锁是谁？<br>答;同步代码块的锁可以是任意类型的对象；非静态同步方法的锁是this；静态方法的锁是该类的字节码文件。（类名.class）</p>
<p>144.实现Runnable和Callable的区别？<br>答：实现Runnable接口重写的是run（）方法，该run方法没有返回值，不能抛异常；<br>而实现Callable接口重写的是call（）方法，该call方法可以抛异常，可以有返回值。</p>
<p>Runnable接口的实现类对象既可以作为参数传递给Thread的构造方法，也可以作为线程池submit的参数；<br>Callable接口的实现类对象只适应于线程池。</p>
<p>145.线程的生命周期（线程的五种状态）是什么？<br>答：新建、就绪、运行（运行的时候可能发生阻塞）、死亡。<br>线程的六种状态：新建、就绪、运行（运行的时候可能阻塞或者等待）、死亡。</p>
<p>146.sleep和wait的区别？<br>答：（1）sleep()必须传参，表示让线程睡制定时间，到点后自动醒来，睡的时候不释放资源。。<br>（2）wait()可传可不传参数，不传就立马等待，传就过制定时间再等待。必须被唤醒，等待的时候回释放资源。。</p>
<p>147.什么时候考虑使用同步？<br>多线程，并发，操作同一数据。</p>
<p>148.为什么wait()和notify()定义在Object中？<br>答：因为锁对象可以是任意类型的对象。</p>
<p><em>**</em>什么是时候用线程池？</p>
<p><em>**</em>死锁的原理是什么？</p>
<p>模拟tomcat服务器</p>
<p><em>**</em>什么是HTTP协议？<br>http协议是超文本传输协议，是互联网中应用最广泛的一种网络协议。</p>
<p>150.BS结构和CS的区别？<br>答：CS结构是指客户端和服务器端。开发比较容易，但是维护比较麻烦，因为用户的应用程序都在客户端。<br>BS结构是指浏览器端和服务器端，开发相对来讲有点复杂，但是维护比较方便，因为应用程序基本都在服务器端。</p>
<ol>
<li>静态资源和动态资源是什么？<br>答：静态资源是Web页面给人们看到的数据是始终不变的，例如html。<br>动态资源是Web页面给人们看的数据是系统自动生成的，随时变化的。例如JSP/Servlet、ASP、PHP<br>在JAVA，动态Web资源开发技术通称Javaweb。</li>
</ol>
<p>152.常用的状态码你知道哪些？<br>答：200  请求成功；404  请求的资源不存在；500  服务器发生未知的错误。</p>
<p>153.GET请求和POST请求的区别？<br>答：GET请求会将请求信息置于地址栏，不安全，适合小数据的传输。不能超过            255个字符<br>POST请求将请求信息置于请求体，相对安全，适合大数据的传输。</p>
<p>154.客户端向服务器发送请求request，服务器对客户端的请求做出响应response。</p>
<p>155.请求信息包括什么？响应信息包括什么？<br>答：请求头，空行，请求体（为空）。请求头又包括请求行和头信息。<br>响应信息包括响应头，空行，响应体。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>WHERE 和 HAVING 的区别？</p>
<p>156.为什么要有数据库？常见的数据库你知道哪些？<br>答：数据库是一个存储数据的仓库，本质是一个文件系统，可以有规律的对数据进行存储，方便用户进行增删改查。。<br>Oracle  MySQL SQL Server  </p>
<p>157.数据库的本质是什么?<br>答;数据库的本质是一个文件系统。</p>
<p>158.数据库以什么为单位存储数据？<br>数据库中以数据表为组织单位存储数据。</p>
<p>159.常用的SQL语句？<br>create  database 数据库名;     创建数据库<br>show databases;                查看所有数据库<br>use 数据库名；                 使用指定数据库<br>create table 表名（            创建表<br>列名1  数据类型 约束，<br>列名2  数据类型，<br>列名3  数据类型，<br>…<br>列名n  数据类型    –不加，<br> ）<br>insert into 表名（列名1，列名2，.列名n） values （值1，值2…）;添加数据<br>delete from 表名 where 条件       删除指定条件的数据<br>update 表名 set 字端1 = 值1，字端2=值2  where 条件； 修改指定数据<br>select 字段1,字段2,…from 表名;      按照表中的字段名查询：<br>select * from 表名;                       查询表中所有字段  </p>
<p>order by   排序<br>group by   分组：</p>
<p>160.聚合函数？<br>count、sum、max、min、avg</p>
<p>161.JDBC的核心功能是什么？ Java Data Base Connectivity<br>答：连接数据库；向数据库发送SQL语句；操作SQL语句的返回结果。</p>
<p>162.DBUtils能否创建数据库和表？<br>答：不能，只能操作数据库里面的数据。</p>
<p>163.SQL语言的分类？<br>答：SQL语言是JAVA操作数据库的语言。分为DDL（Data Definition Language）数据定义语言；DML（Data manipulation Language）数据操作语言(增删改)；DCL（Data Control Language）数据控制语言；DQL(Data Query Language)数据查询语言。</p>
<p>164.SQL注入的问题产生原因和解决方法？<br>答：SQL注入是指我们的SQL语句中有部分内容是让用户录入的，而我们有没有才有占位符的方式，用户就有可能录入一些危险信息，就会因为安全问题，这就是SQL注入攻击。 可以使用占位符的方式解决，也就是PreparedStatement接口的子类对象。</p>
<p>165.数据库连接池？<br>答：实际开发中，我们需要经常操作数据库，而每次操作数据库都创建一个连接对象（Connection），是非常消耗资源的。针对这种情况，我们就搞一个池子，里边放一些连接对象，用的时候从里边拿，用完之后再放进去。这个池子就是数据库连接池。这样做可以节约资源，提高效率。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[15.异常]]></title>
      <url>https://geekhoon.github.io/2017/02/18/15-%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h3 id="异常继承体系"><a href="#异常继承体系" class="headerlink" title="异常继承体系"></a>异常继承体系</h3><pre><code>* Throwable类是所有错误,异常的超类
    | - Error     : 错误, Throwable的子类
    | - Exception : 异常, Throwable的子类
        |-RuntimeException :　运行期异常, JAVA程序运行过程中出现的问题, Exception的子类
        |-非RuntimeException : 编译期异常，必须处理的，否则程序编译不通过, Exception的子类
</code></pre><a id="more"></a> 
<pre><code>* 异常与错误的区别
 1. 异常: 
    * 异常指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。
    * 若不处理异常，程序将会结束运行。
 2. 错误:
    * 指程序在运行期间发生了某种错误，Error错误通常没有具体的处理方式，程序将会结束运行。
    * Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。
    * 我们无法针对处理，只能修正代码
</code></pre><h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><pre><code>1. JVM的默认处理方式
    * 把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。
    * 一旦有异常发生，其后来的代码不能继续执行。
2. 解决程序中异常的手动方式
    * 编写处理代码 try...catch...finally
        自己编写处理代码,后面的程序可以继续执行
    * 抛出 throws
        把自己处理不了的，在方法上声明，告诉调用者，这里有问题
</code></pre><h3 id="异常中关键字"><a href="#异常中关键字" class="headerlink" title="异常中关键字"></a>异常中关键字</h3><h4 id="抛出异常对象-throw"><a href="#抛出异常对象-throw" class="headerlink" title="抛出异常对象 throw"></a>抛出异常对象 throw</h4><pre><code>* 在方法内部,抛出异常
* 用来抛出一个指定的异常对象, 
* 以抛出异常的方式,告诉调用者main,(如果是main方法调用的话)
* throw 后面, 必须写new 对象,必须是异常的对象,只能写一个对象
</code></pre><h4 id="方法中声明异常关键字-throws"><a href="#方法中声明异常关键字-throws" class="headerlink" title="方法中声明异常关键字 throws"></a>方法中声明异常关键字 throws</h4><pre><code>* 在方法声明上, 表明此方法,可能出现异常 
* throws 后面, 必须写异常类的类名,可以写多个异常类名
* 格式: 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… {   }
* 当调用了一个抛出异常的方法,调用者就必须处理, 不处理,编译失败
</code></pre><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><pre><code>1. 编译期异常和运行期异常的区别
    编译期异常 必须要处理的，否则编译不通过
    运行期异常 可以不处理，也可以处理
2. throw,throws区别
    throw:
        在方法体中,后面跟的是异常对象名,并且只能是一个
        throw抛出的是一个异常对象，说明这里肯定有一个异常产生了
    throws:
        在方法声明上,后面跟的是异常的类名,可以是多个
        throws是声明方法有异常，是一种可能性，这个异常并不一定会产生
</code></pre><h3 id="try-catch异常处理"><a href="#try-catch异常处理" class="headerlink" title="try..catch异常处理"></a>try..catch异常处理</h3><pre><code>* 格式:　
try{
   被检测代码
}catch (异常类名1 变量){
    异常处理方式
}catch (异常类名2 变量){
    ...
}catch ...
}finally{
    必须要执行的代码
}
* 注意: 
    如果出现了上下级关系的异常, 越高级越要写在catch下面
* finally,无论程序是否有异常出现,程序必须执行释放资源
      如：IO流操作和数据库操作中会见到
* finally：是try-catch的一部分！被它修饰的代码一定会被执行到！除非在这之前退出了虚拟机
   System.exit(0);
* 方法中, 在catch语句中有return, return语句在finally之前执行, 还是之后执行?
  return , 先建立了一个返回的链接, 先检测一下, 如果有finally, 那么执行完finally代码块后, 继续返回
</code></pre><h3 id="运行时期异常处理"><a href="#运行时期异常处理" class="headerlink" title="运行时期异常处理"></a>运行时期异常处理</h3><pre><code>* 编译异常: 调用了抛出异常的方法, 不处理编译失败 (try  throws)
* 运行异常: 抛出的异常是RuntimeException类, 或者它的子类, 除此之外,都是编译异常

* throws Exception : 抛的是编译异常
* throws NullPointerException : 抛的是运行异常
* 运行异常的特点:
    * 方法中抛出运行异常,方法定义中无需throws声明,调用者也无需处理此异常。
    * 运行异常一旦发生,后面的代码没有执行的意义,需要程序人员修改源代码
* 设计原因: (不写throws, 调用者也不用处理)
    * 运行异常, 不能发生, 但是如果发生, 程序人员停止程序, 修改源代码
</code></pre><h3 id="方法重写时异常的处理"><a href="#方法重写时异常的处理" class="headerlink" title="方法重写时异常的处理"></a>方法重写时异常的处理</h3><pre><code>* 继承后, 在子类重写父类方法的时候, 异常处理
* 结论: 
    1.父类的方法如果抛出异常, 子类重写后, 
        1. 可以不抛出异常
        2. 也可以抛出异常, 但是抛的异常不能大于父类的异常(异常的继承关系)
           如果抛同级异常, 只能和父类抛的异常一模一样

    2.父类的方法如果不抛出异常, 子类重写后, 也不能抛出异常
        如果子类重写的方法调用了抛出编译异常(注意,如果调用了抛运行异常的方法,不会出问题)的方法, 只能try/catch处理, 子类重写的方法不可以向外抛异常
</code></pre><h3 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h3><pre><code>* 都和异常的信息有关系
1. String getMessage() : 对异常信息的详细描述
2. String toString()   : 对异常信息的简短描述
3. void printStackTrace(): 将异常信息追踪到标准的错误流
</code></pre><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><pre><code>* 步骤: 
    1. 继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可, 一般写运行异常
    2. 构造方法中, super将异常信息传递给父类
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[14.正则表达式]]></title>
      <url>https://geekhoon.github.io/2017/02/11/14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><pre><code>*　操作字符串数据的规则表达式
</code></pre><a id="more"></a> 
<h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><pre><code>注意: 一个[ ]代表一个字符
* 字符
    * x  代表的是 字符x
    * \\ 代表的是 反斜线字符&apos;\&apos;
    * \t 代表的是 制表符
    * \n 代表的是 换行符
    * \r 代表的是 回车符
    * \s 代表的是 空格
* 字符类
    * [abc]    a、b 或 c 范围中的一个
    * [^abc]   任何字符，除了 a、b 或 c
    * [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） 
    * [0-9]    0到9的字符都包括
    * [^0-9]   不是数字
    * [a-zA-Z_0-9] 代表的字母或者数字或者下划线
* 预定义字符类
    * .  任何字符
    * \d 数字：[0-9]
    * \D 不是数字    
    * \w 单词字符：[a-zA-Z_0-9]
* 边界匹配器
    * ^  代表的是行的开头
    * $  代表的是行的结尾
    * \b 代表的是单词边界
* 数量词
    * X?     X，一次或一次也没有
    * X*     X，零次或多次
    * X+     X，一次或多次
    * X{n}   X，恰好 n 次 
    * X{n,}  X，至少 n 次 
    * X{n,m} X，至少 n 次，但是不超过 m 次
</code></pre><h3 id="正则表达式和String类相关的方法"><a href="#正则表达式和String类相关的方法" class="headerlink" title="正则表达式和String类相关的方法"></a>正则表达式和String类相关的方法</h3><pre><code>1.匹配。
      使用的是String类中的matchers方法。
    boolean matches(String 正则表达式)
    如boolean b = &quot;abc&quot;.matches(&quot;[a]&quot;);
    //返回false, 因为abc为三个字符,正则只有a一个,改成&quot;[abc]+&quot;返回true
2.切割。
      使用的是String类中的split方法。 
    String[] split(String 正则表达式)
    如String[] strArr = &quot;abc&quot;.split(&quot;a&quot;);
    注意: 
      1. 返回值类型是String类型的数组
      2. 如果用原字符串中没有的字符来切, 切割后数组长度为1
      3. 切割符是&quot;.&quot;的时候, 要转义,用&quot;\\.&quot; 两个反斜杠的原因: 第一个是java中先转义 第二个是正则中转义
      4. 切割符是&quot; &quot;的时候, 要转义,用&quot;\\s&quot;,或者&quot; +&quot;
3.替换。
      使用的是String类中的replaceAll方法。
    String replaceAll( String 正则表达式,String 字符串)
    如String str = &quot;abc0123&quot;.repalceAll(&quot;[\\d]&quot;,&quot;#&quot;); 
    //打印abc####  若要打印成abc# ,将正则表达式改为&quot;[\\d]+&quot;
</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><pre><code>1.QQ号正则表达式, 要求:全数字,0不能开头,5-10位
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QQ.matches(<span class="string">"[1-9][\\d]&#123;4,9&#125;"</span>);</div></pre></td></tr></table></figure>
<pre><code>2.要求: 输入aaa_bbbb_ccc_ddd,输出AaaBbbbCccDdd
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String str = <span class="string">"aaa_bbbb_ccc_ddd"</span>;</div><div class="line">		change(str);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span></span>&#123;</div><div class="line">		String[] strArr = str.split(<span class="string">"_"</span>);</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArr.length; i++) &#123;</div><div class="line">			String word = strArr[i];</div><div class="line">			sb.append(wordLowerToUpper(word));	</div><div class="line">		&#125;</div><div class="line">		System.out.println(sb.toString());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">wordLowerToUpper</span><span class="params">(String word)</span></span>&#123;</div><div class="line">		String first = word.charAt(<span class="number">0</span>)+<span class="string">""</span>;</div><div class="line">		first = first.toUpperCase();</div><div class="line">		String other = word.substring(<span class="number">1</span>);</div><div class="line">		<span class="keyword">return</span> first + other;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>3.简式邮箱格式正则表达式
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Email_Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String str = <span class="string">"fsd1111fdsfsddsdsad22@2.com.cn"</span>;</div><div class="line">		email_judge(str);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">email_judge</span><span class="params">(String str)</span></span>&#123;</div><div class="line">		<span class="comment">//.com.cn  .字母 可以有多个</span></div><div class="line">		<span class="keyword">boolean</span> b = str.matches(<span class="string">"[\\w]+@[a-z0-9]+(\\.[a-z]+)+"</span>);</div><div class="line">		System.out.println(b);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[13.API]]></title>
      <url>https://geekhoon.github.io/2017/02/10/13-API/</url>
      <content type="html"><![CDATA[<h3 id="API概念"><a href="#API概念" class="headerlink" title="API概念"></a>API概念</h3><pre><code>* API(Application Programming Interface) 
  应用程序编程接口
* Java API
  Java jdk给我们提供好的类
</code></pre><a id="more"></a>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><pre><code>* 所有类的父类
* 常用方法
    * boolean equals(Object obj){}
      比较两个对象的地址值是否一致

    * String toString()
      返回对象的地址值。(对象调用toString()默认不用写,自动调用)
      我们一般会在子类中重写toString方法来返回对象的内容
</code></pre><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><pre><code>* 特点: 1. 字符串是一个常量,一旦创建,不可改变
          如String str = &quot;abc&quot; 不变指的是&quot; &quot;内的值不变,不是str的值不可变
        2. 所有的 &quot;&quot; 都是String类的对象
* 注意: 
    1. 只有显示定义的字符串才会存在于常量池中
        * JDK1.6及以前, 常量池位于方法区
        * JDK1.7之后, 常量池位于堆中
    2. 源码分析,String类底层采用的是字符数组 
        字符串的本质是一个char数组, 字符串以字符形式存储于常量池中  
* String类创建方式和比较
    1. String s1 = &quot;abc&quot;;
       在内存中只有一个对象。这个对象在字符串常量池中
    2. String s2 = new String(&quot;abc&quot;);
       在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象，在字符串常量池中
* String类常见构造方法
    1. public String():空构造
    2. public String(byte[] bytes):把字节数组转成字符串
    3. public String(byte[] bytes,int offset,int length):把字节数组的一部分转成字符串 
    4. public String(char[] value):把字符数组转成字符串
    5. public String(char[] value,int offset,int count):把字符数组的一部分转成字符串
    6. public String(String original):把字符串常量值转成字符串
    注意: 
    1. 2和3中,将字节数组转成字符串,会通过使用机器操作系统的默认编码表(GBK)解码byte数组,构造新的String
       Java语言使用的就是unicode(字符串用GBK，字符用unicode码表)
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,-<span class="number">99</span>,-<span class="number">100</span>,-<span class="number">112</span>&#125;;</div><div class="line"><span class="comment">//调用String类的构造方法,传递字节数组</span></div><div class="line">String s = <span class="keyword">new</span> String(bytes);</div><div class="line">System.out.println(s);  <span class="comment">//打印结果为 ab潨?</span></div><div class="line"><span class="comment">//汉字的字节编码就是负数, 两个负数代表一个汉字, 多一个负数,会打出?</span></div><div class="line"></div><div class="line"><span class="keyword">byte</span>[] bytes1 =&#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>,<span class="number">69</span>&#125;;</div><div class="line"><span class="comment">//调用String构造方法,传递数组,传递2个int值,offset代表数组的起始的索引,length代表转的个数</span></div><div class="line">String s1 = <span class="keyword">new</span> String(bytes1,<span class="number">1</span>,<span class="number">3</span>);</div><div class="line">System.out.println(s1);</div></pre></td></tr></table></figure>
<pre><code>2. 4和5中,把字符数组转成字符串,如果是字符型数据,不查询编码表
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>[] c = &#123;<span class="number">97</span>,<span class="string">'8'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</div><div class="line"><span class="comment">//调用String构造方法,传递字符数组</span></div><div class="line">String s = <span class="keyword">new</span> String(c);</div><div class="line">System.out.println(s);<span class="comment">//打印a8cdef ,97会查编码表ASCii </span></div><div class="line">	</div><div class="line">String s1 = <span class="keyword">new</span> String(c,<span class="number">1</span>,<span class="number">4</span>);</div><div class="line">System.out.println(s1);<span class="comment">//打印8cde</span></div></pre></td></tr></table></figure>
<pre><code>* String的常用判断方法
    1. boolean equals(Object obj):比较字符串的内容是否相同,区分大小写
    2. boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写
    3. boolean contains(String str):判断大字符串中是否包含小字符串
    4. boolean startsWith(String str):判断字符串是否以某个指定的字符串开头
    5. boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾
    6. boolean isEmpty():判断字符串是否为空。
* String类的获取功能
    1. int length():获取字符串的长度。
    2. char charAt(int index):获取指定索引位置的字符
    3. int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。被查找的字符不存在,返回-1
    4. int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。
    5. String substring(int start):从指定位置开始截取字符串,默认到末尾。
    6. String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。(包含头，不包含尾)
    7. char[] toCharArray() 将字符串转成字符数组
    8. byte[] getBytes() 将字符串转成字节数组 (byte数组相关的功能,查询编码表)
    9. String toUpperCase();转成大写
    10. String toLowerCase();转成小写
    11. static String valueOf(char[] data) : 将字符数组,转成String类型
* String的替换功能
    1. String replace(char old,char new)
    2. String replace(String old,String new)
    3. String replaceFirst(String regex, String replacement) 
        使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
    4. String replaceAll(String regex, String replacement) 
        使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。
     注：如果要被替换字符或字符串在原字符串中不存在，则返回原字符串。
* 空串与null区别 
    * &quot;&quot;是字符串常量,同时也是一个String类的对象,既然是对象当然可以调用String类中的方法
     * null是空常量,不能调用任何的方法,否则会出现空指针异常,null常量可以给任意的引用数据类型赋值
     * 声明一个String str
       如果说str是null，那么内存根本没有创建字符串对象，没有str引用。
       如果说str是空串，那么确定存在一个由str引用的字符串对象，只不过这个字符串的值是空。
       null用来表示没有实例存在，而“”本身就是一个实例，有自己的对象空间，和“123456”这样的字符串没有区别。
    使用注意事项：
        对象用equals比较，null用等号比较。因此，如果str1=null;下面的写法运行会有错误： 
        if(str1.equals(&quot;&quot;)||str1==null){//当str1为null, str1.equals(&quot;&quot;)会报空指针异常
          //。。。。 
        } 
        正确的写法是 
        if(str1==null||str1.equals(&quot;&quot;)){ //先判断是不是对象，如果不是， 不需要判断是不是空字符串 
            //... 
        }
</code></pre><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><pre><code>* 概述
    * 字符串缓冲区 
    * 线程安全的可变字符序列 
    * 底层采用字符数组实现,初始容量为16
* StringBuffer和String的区别
    * String是一个不可变的字符序列
    * StringBuffer是一个可变的字符序列
    其实字符串String的底层也是用StringBuffer来完成的。
    比如：String str = &quot;abc&quot; + 4 + &apos;c&apos;;
    这句话的底层其实就是：
    String str = new StringBuffer().append(&quot;abc&quot;).append(4).append(&apos;c&apos;).toString();
* StringBuffer和数组容器的区别？ 
    1. 数组容器是固定长度的。
       StringBuffer是可变长度的。
    2. 数组容器一旦初始化就明确了元素的类型。
       StringBuffer可以存储任意类型。包括基本和引用。
    3. 数组存储完元素可以对元素进行操作（通过角标）。
       StringBuffer存储完元素后，都会变成字符串，只能用字符串的方法来操作。
* 特点
   1. 缓冲区就是用来缓存数据，意味着它是一个容器。
   2. 该容器的长度是可变的。 
   3. 提供了对容器中内容的操作的方法(最多无外乎四种：增删改查.)
   4. 该缓冲区中可以添加多种类型的元素，基本类型和引用类型。 
   5. 无论怎么样的改变容器中的数据，最终要使用结果，还是必须要将其转成字符串，使用toString方法。
* 构造方法
   1. public StringBuffer():无参构造方法
   2. public StringBuffer(String str) :向StringBuffer对象中插入一个字符串
 * 常用方法
   1. StringBuffer append(), 将任意类型的数据,添加缓冲区
      * 调用者是谁,返回值就是谁
   2. delete(int start,int end): 删除缓冲区中字符
      * 开始索引包含,结尾索引不包含
   3. insert(int index, 任意类型): 将任意类型数据,插入到缓冲区的指定索引上
   4. replace(int start,int end, String str): 将指定的索引范围内的所有字符,替换成新的字符串
   5. reverse(): 将缓冲区中的字符反转
   6. String toString(): 继承Object,重写toString()
      * 将缓冲区中的所有字符,变成字符串
</code></pre><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><pre><code>* StringBuffer和StringBuilder的区别
    * StringBuffer是jdk1.0版本的,是线程安全的,效率低
    * StringBuilder是jdk1.5版本的,是线程不安全的,效率高
</code></pre><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><pre><code>* 日期类
* 毫秒值
    * 获取当前日期的毫秒值
      System.currentTimeMillis() 返回值long类型参数
    * 时间原点: 公元1970年1月1日 00:00:00
    * 日期对象之间要进行基本运算，需要转成具体的毫秒数值才可以
* Date类的构造方法
    * 空参构造 
      public Date()    :获取当期操作系统的日期,时间
    * 带参构造
      public Date(long times) :将传入的毫秒值转为对应的日期,时间
* Date类的get/set方法
    * public long getTime()     :将当前的日期对象，转为对应的毫秒值
    * public void setTime(long times)  :根据给定的毫秒值，生成对应的日期对象
* 日期格式化SimpleDateFormat
    * SimpleDateFormat继承自抽象类 DateFormat,使用父类普通方法,重写抽象方法
    * 作用: 对日期进行格式化(自定义)
    * 对日期进行格式化的步骤: (Date对象 ==&gt; 字符串)
       1: 创建SimpleDateFormat对象
          在类构造方法中,写入字符串的日期格式 (自己定义)
       2: SimpleDateFormat调用方法format对日期进行格式化
          public String format(Date date) 
    * 字符串转成日期对象步骤: (字符串 ==&gt; Date对象)
       1: 创建SimpleDateFormat的对象
          在类构造方法中,写入字符串的日期格式 (自己定义)
       2: 子类对象,调用方法 parse 传递String,返回Date
          Date parse(String 日期模式)
          注意传递的Stirng类型日期模式,要和1中定义的格式相同
    * 日期模式:
        yyyy    年份
        MM      月份
        dd      月中的天数
        HH      0-23小时
        mm      小时中的分钟
        ss      秒
* 练习: 
1.计算出生至今活了多少天
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	System.out.println(<span class="string">"请输入出生日期 格式 YYYY-MM-dd"</span>);</div><div class="line">	<span class="comment">//获取出生日期,键盘输入</span></div><div class="line">	String birthdayString = <span class="keyword">new</span> Scanner(System.in).next();</div><div class="line">	<span class="comment">//将字符串日期,转成Date对象</span></div><div class="line">	<span class="comment">//创建SimpleDateFormat对象,写日期模式</span></div><div class="line">	SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">	<span class="comment">//调用方法parse,字符串转成日期对象</span></div><div class="line">	Date birthdayDate = sdf.parse(birthdayString);</div><div class="line">	</div><div class="line">	<span class="comment">//获取今天的日期对象</span></div><div class="line">	Date todayDate = <span class="keyword">new</span> Date();</div><div class="line">	</div><div class="line">	<span class="comment">//将两个日期转成毫秒值,Date类的方法getTime</span></div><div class="line">	<span class="keyword">long</span> birthdaySecond = birthdayDate.getTime();</div><div class="line">	<span class="keyword">long</span> todaySecond = todayDate.getTime();</div><div class="line">	<span class="keyword">long</span> second = todaySecond-birthdaySecond;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>(second &lt; <span class="number">0</span>)&#123;</div><div class="line">		System.out.println(<span class="string">"还没出生呢"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		System.out.println(second/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><pre><code>* 日历类(抽象类) 
* 创建对象: Calendar类中写了getInstance()静态方法,直接返回子类的对象,不用new子类对象
  格式如: Calendar c = Calendar.getInstance();
* 常用方法:

* get(日历字段): 获得指定日历字段的值
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Calendar c = Calendar.getInstance();</div><div class="line"><span class="comment">// 获取年份</span></div><div class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR);</div><div class="line"><span class="comment">// 获取月份</span></div><div class="line"><span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</div><div class="line"><span class="comment">// 获取天数</span></div><div class="line"><span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</div><div class="line">System.out.println(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + day + <span class="string">"日"</span>);</div></pre></td></tr></table></figure>
<pre><code>* getTime() 把日历对象,转成Date日期对象
* set(int field,int value)  设置指定的时间
  field 设置的是哪个日历字段 
  value 设置后的具体数值
* set(int year,int month,int day) 传递3个整数的年,月,日
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Calendar c = Calendar.getInstance();</div><div class="line"><span class="comment">// 设置,月份,设置到10月份</span></div><div class="line"><span class="comment">// c.set(Calendar.MONTH, 9);</span></div><div class="line"><span class="comment">// 设置年,月,日</span></div><div class="line">c.set(<span class="number">2017</span>, <span class="number">01</span>, <span class="number">01</span>);</div></pre></td></tr></table></figure>
<pre><code>* add(int field, int value) 进行整数的偏移
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让日历中的天数,向后偏移30天</span></div><div class="line">c.add(Calendar.DAY_OF_MONTH, <span class="number">30</span>);</div></pre></td></tr></table></figure>
<pre><code>* 练习: 
1.输入年份,判断是否为闰年
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</div><div class="line">	System.out.println(<span class="string">"请输入一个年份: "</span>);</div><div class="line">	<span class="keyword">int</span> year = <span class="keyword">new</span> Scanner(System.in).nextInt();</div><div class="line">	 Calendar c = Calendar.getInstance();</div><div class="line">	 <span class="comment">//把日期设置成输入年份,当年的3月1日</span></div><div class="line">	 c.set(year, <span class="number">2</span>, <span class="number">1</span>);</div><div class="line">	 <span class="comment">//利用偏移方法,前移一天,get二月的天数</span></div><div class="line">	 c.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</div><div class="line">	 <span class="comment">//闰年29天</span></div><div class="line">	 <span class="keyword">if</span>(c.get(Calendar.DAY_OF_MONTH) == <span class="number">29</span>)&#123;</div><div class="line">		 System.out.println(<span class="string">"闰年"</span>);</div><div class="line">	 &#125;<span class="keyword">else</span>&#123;</div><div class="line">		 <span class="comment">//平年28天</span></div><div class="line">		 System.out.println(<span class="string">"平年"</span>);</div><div class="line">	 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><pre><code>* 可以将字符串转换成对应的基本数据类型
* 八种基本类型对应的包装类:
   char    Character
   int     Integer
   byte    Byte
   short   Short
   long    Long
   float   Float
   double  Double
   boolean Boolean
</code></pre><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><pre><code>* int对应的包装类
* 构造方法
  Integer(String s) : 将数字格式的字符串作为参数
  如: Integer i = new Integer(&quot;100&quot;);
      int num = i.intValue();
    //intValue()方法返回值为int类型,以 int 类型返回该 Integer 的值
    //后面哟用到自动装箱可以直接 Integer i = 100;
* int与String之间互转方法
   1. 字符串转为int
      (1)static int parseInt(String s) :要求s要是数字形式的字符串
        static int valueof(string s) : 要求s要是数字形式的字符串
     (2)static int parseINt(String s,int radix) : 将指定进制的字符串转成十进制的int类型
     注意: parseInt方法的最后返回值都是十进制的int类型
       如: radix为2 ,则将2进制的String s转成10进制的int
   2. int转为字符串
        (1)方式一: 添加空字符串
        int i = 3;
        String str = i + &quot;&quot; ;
     (2)方式二: 
        * static String toString(int i): 
          注意这个方法不是Object类中toString的重写,因为Object类在tOString是空参方法
        * static String toString(int i,int radix):
          将int类型的数据转成radix进制的数字形式的字符串
        注意:　Java中最高支持36进制, 0-9A-Z
* 其他方法: 
  * 两个静态成员变量: 
      * MAX_VALUE : int范围最大值
      * MIN_VALUE
  * 三个静态方法:
      　1. toBinarString(int) : 10进制--&gt;2进制
      　2. toOctalString(int) : 10进制--&gt;8进制
      　3. toHexString(int)   : 10进制--&gt;16进制
       三个方法的返回值都是String类型
</code></pre><h3 id="自动装箱-自动拆箱"><a href="#自动装箱-自动拆箱" class="headerlink" title="自动装箱/自动拆箱"></a>自动装箱/自动拆箱</h3><pre><code>* 概述
    * 自动装箱: 基本数据类型,直接变成对象
    * 自动拆箱: 对象中的数据,变回基本数据类型
* 举例: 
    * 装箱: Integer i = 1;  //这步的实际操作是 Integer i = new Integer(1);
    * 拆箱: i = i + 1; 
            //实际操作是(1) i + 1 为  i.intValue() + 1;
                       (2) i = 2; 
* 好处: 基本数据类型与引用类型可以直接计算
* 坏处: 有可能会抛空指针异常, 如
        Integer i = null;
        i = i + 1;
        System.out.println(i);//会抛异常 
</code></pre><pre><code class="java">Integer a1 = <span class="number">500</span>;
Integer b1 = <span class="number">500</span>;
System.out.println(a1==b1);
<span class="comment">//因为自动装箱实质上也new了一个Integer对象,所以a1和b1地址值不同,false</span>
System.out.println(a1.equals(b1));
<span class="comment">//内容相同, 为true</span>

<span class="comment">//数据在byte范围内,JVM不会重新new对象</span>
Integer a2 = <span class="number">127</span>;   <span class="comment">//Integer a2 = new Integer(127);</span>
Integer b2 = <span class="number">127</span>;    <span class="comment">//Integer b2 = a2;</span>
System.out.println(a2==b2);  <span class="comment">//a2, b2指向的是同一个对象,地址相同</span>
System.out.println(a2.equals(b2)); <span class="comment">//内容相同,true</span>

Integer i1 = <span class="number">60</span>;
Integer i2 = <span class="number">60</span>;
Integer i3 = <span class="number">60</span> + <span class="number">60</span>; 
Integer i4 = i1 + i2;
System.out.println(i3 == i4);
<span class="comment">//这个我判断错了, 答案是true</span>
<span class="comment">//因为i3 = 120, 在byte范围内, i4也=120 ,不会重新new对象 ,所以它们地址相同</span>

String s1 = <span class="string">"he"</span>; 
String s2 = <span class="string">"llo"</span>; 
String s3 = <span class="string">"he"</span> + <span class="string">"llo"</span>; 
String s4 =  s1 + s2;     
System.out.println(s3 == s4); <span class="comment">//比较的是地址, false</span>

<span class="keyword">byte</span> b1 = <span class="number">60</span>;
<span class="keyword">byte</span> b2 = <span class="number">60</span>;
<span class="keyword">byte</span> b3 = <span class="number">60</span> + <span class="number">60</span>;
<span class="keyword">int</span> b4 = (<span class="keyword">byte</span>) (b1 + b2);
System.out.println(b3 == b4); <span class="comment">//比较的是值, true</span>

Byte by1 = <span class="number">60</span>;
Byte by2 = <span class="number">60</span>;
Byte by3 = <span class="number">60</span> + <span class="number">60</span>;
<span class="keyword">int</span> by4 = by1 + by2;
System.out.println(by3 == by4); 
<span class="comment">//这个我判断错了,比较的不是地址, 因为by4是int类型</span>
<span class="comment">//Byte by3 有个自动拆箱 即 byte by3</span>
<span class="comment">//基本数据类型比较 比较的就是值的大小</span>
<span class="comment">//结果是true</span>
</code></pre>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><pre><code>* 概述
    * 不能new, 因为构造方法是private的
    * 全是静态方法
* 常用方法
    1. static long currentMillis() : 获得当前时间毫秒值
    2. static void exit(int status) : 退出JVM,所有程序停止
        status传0 ,程序正常退出
        status传非0 ,程序异常时退出
    3. static void gc() :  调用垃圾回收器,但不能100%回收
        对象在被回收前,会调用对象的finalize方法,且只会执行一次
    4. static Properties getProperties() : 获取JVM和当前操作系统的属性
    5. static void arrayCopy(Object src, int srcPos, Object dest, int destPos, int length) 
       复制一个数组
        src : 要复制的源数组
        srcPos :　源数组的起始索引
        dest : 复制后的目标数组
        destPos : 目标数组起始索引
        length : 拷贝长度
</code></pre><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><pre><code>* 概述
    * 数学计算工具类
    * java.lang.Math
    * 全是静态方法
* 常用方法
    1. static int abs(int i) : 获取绝对值
    2. static double ceil(double d) : 返回大于或等于参数d的最小整数(向上取整)
    3. static double floor(doublr d) : 返回小于或等于参数d的最大整数(向下取整)
    4. static double pow(double a, double b) : 返回a的b次方
    5. static double sqrt(double a) : 开方
       输入负数,返回NaN,意思是not a number
    6. static double random() : 返回随机数0.0-1.0, [0.0-1.0)
    7. static double round(double d) : 获取d的四舍五入的值
        5.415622 得 5.0
        5.5222455555 得 6.0  
</code></pre><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><pre><code>* 概述
    * 数组工具类 
    * 位于java.util.Arrays
    * 全是静态方法
* 常用方法
    1. static void sort(数组) : 将数组进行升序排序
    2. static int binarySearch(数组,查找元素) :　返回查找元素在数组中的索引
    　  注意:　查找元素不存在时，返回(-插入点 - 1)
    3. static String toString(数组) : 将数组变成字符串
</code></pre><h3 id="大数据运算"><a href="#大数据运算" class="headerlink" title="大数据运算"></a>大数据运算</h3><h4 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h4><pre><code>* 概述
    * 将一个超大整数封装到BigInteger对象中
    * java.math.BigInteger
* 构造方法
    * BigInteger(String num) :  将BigInteger的十进制字符串表示形式转换为BigInteger对象。
* 四则运算(结果也是BigInteger对象)
    * 加  BigInteger add(BigInteger val) 
      BigInteger b = b1.add(b2);
    * 减  BigInteger subtract(BigInteger val)  
    * 乘  BigInteger multiply(BigInteger val)  
    * 除  BigInteger divide(BigInteger val) 
</code></pre><h4 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h4><pre><code>* 概述
    * 解决浮点数计算不准确的问题
* 构造方法
    * BigDecimal(String val) :　将 BigDecimal 的字符串表示形式转换为 BigDecimal
* 三则运算(结果也是BigDecimal对象)
    * 加  BigDecimal add(BigDecimal val) 
      BigDecimal b = b1.add(b2);
    * 减  BigDecimal subtract(BigDecimal val)
    * 乘  BigDecimal multiply(BigDecimal val)  
* 除  
    * divide(BigDecimal val) 除不尽会产生无限不循环小数,抛异常
    * 用BigDecimal divide(BigDecimal divisor, int scale,  int roundingMode) 
      scale : 保留几位数
      roundingMode : 保留模式,写下面这些静态成员变量
* 静态成员变量
    * static int ROUND_UP : 向上加１
    * static int ROUND_DOWN : 直接舍去
    * static int ROUND_HALF_UP : 如果舍弃部分&gt;=0.5,向上加1,否则直接舍去
    * static int ROUND_HALF_DOWN : &gt;0.5,向上加1,否则直接舍去
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[12.面向对象]]></title>
      <url>https://geekhoon.github.io/2017/02/04/12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><pre><code>* 面向过程： 注重实现过程，每件事都是要亲自去做
* 面向对象： 注重实现结果，强调这件事让别人帮我来做

好处:
  1. 更符合人类思考的习惯
  2. 将复杂的事情简单化
  3. 从执行者变成指挥者
</code></pre><a id="more"></a> 
<h3 id="局部变量和成员变量区别"><a href="#局部变量和成员变量区别" class="headerlink" title="局部变量和成员变量区别"></a>局部变量和成员变量区别</h3><pre><code>1.定义位置不同
    局部变量：方法中
    成员变量：类中方法外
2.作用域不同
    局部变量：方法中，出了方法就不能用了
    成员变量：整个类
3.默认值不同
    局部变量：没有默认值，局部变量必须先赋值才能使用
    成员变量：有默认值。和数组元素默认值一样  
4.内存位置不同
    局部变量：在栈内存的方法中
    成员变量：在堆内存的对象中
5.生命周期不同
    局部变量：随着方法弹栈而消亡
    成员变量：随着对象的回收而消亡
</code></pre><h3 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h3><pre><code>* private可以修饰成员内容包括成员方法和成员变量

* 被private修饰的内容不能在其他类访问
</code></pre><h3 id="get和set方法"><a href="#get和set方法" class="headerlink" title="get和set方法"></a>get和set方法</h3><pre><code>私有化所有的属性 (成员变量) ,必须写对应的get/set方法
凡是自定义的类,自定义成员变量,应该私有化,提供get/set
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">	<span class="comment">// set方法,变量name,age赋值</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// get方法,变量name,age获取值</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

* 测试代码1
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Person p = <span class="keyword">new</span> Person();</div><div class="line">		<span class="comment">//调用set方法,对成员变量赋值</span></div><div class="line">		p.setAge(<span class="number">18</span>);</div><div class="line">		p.setName(<span class="string">"旺财"</span>);</div><div class="line">		<span class="comment">//调用get方法,获取成员变量的值</span></div><div class="line">		System.out.println(p.getName());</div><div class="line">		System.out.println(p.getAge());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><pre><code>概念: 隐藏实现细节，对外提供可以访问的方式
好处:
    * 1、提高了代码的复用性
    * 2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。
    * 3、提高了安全性    
</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code>* 子类会自动拥有父类所有非private修饰的属性和方法

* 格式: class 子类 extends 父类 {} 

* 好处: 
    * 1、提高了代码的复用性，提高软件开发效率。
    * 2、让类与类之间产生了关系，提供了多态的前提。
* 坏处: 提高了类与类之间的耦合性

* 注意:
    * 1、Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类
    * 2、多个类可以继承一个父类
    * 3、Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类
        如:
        C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类
        <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;   <span class="comment">// 类B继承类A，类B是类A的子类</span></div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;   <span class="comment">// 类C继承类B，类C是类B的子类，同时也是类A的子类</span></div></pre></td></tr></table></figure>

    * 4、Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。
* 补充: 
     * 父类和子类创建后,编译时,父类.class先进内存方法区,然后子类再进
     * 创建子类的对象,子类在堆中划分区域存储,一个区域留给父类,父类成员变量
       跟随子类对象进入堆内存,另一块区域留给自己(父类区域在子类区域内部)
* 继承后子类父类成员变量的特点 :
    * 子父类中出现了同名的成员变量时,遵循就近查找原则,访问子类.
      在子类中需要访问父类中非私有成员变量时，需要使用super关键字
* 重写:
    * 当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法，
      若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。
    * 子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//手机类</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"发短信"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"打电话"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"来电显示号码"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//智能手机类</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">NewPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</div><div class="line">		</div><div class="line">		<span class="comment">//覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="comment">//调用父类已经存在的功能使用super</span></div><div class="line">			<span class="keyword">super</span>.showNum();</div><div class="line">			<span class="comment">//增加自己特有显示姓名和图片功能</span></div><div class="line">			System.out.println(<span class="string">"显示来电姓名"</span>);</div><div class="line">			System.out.println(<span class="string">"显示头像"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</code></pre><p>子类父类内存图:<br><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170209/154741718.png" alt=""></p>
<h3 id="重载与重写对比"><a href="#重载与重写对比" class="headerlink" title="重载与重写对比"></a>重载与重写对比</h3><pre><code>重载overload: 在同一个类中,方法名相同,参数列表不同
    和权限修饰符(public private 默认)无关,和返回值类型无关
    方法名:重载的两个方法的方法名必须相同
    形参列表(三者至少满足一个):
      形参类型的顺序不同
      形参的个数不同
      形参的类型不同
重写overwrite:
    权限修饰符(public private 默认): 
      子类方法的权限 &gt;= 父类的方法的权限
    方法名: 
      子类方法和父类方法必须相同
    形参列表: 
       子类方法和父类方法的形参列表必须相同
    返回值类型:
      基本类数据类型: 必须相同
      引用数据类型:
       子类方法的返回值类型和父类方法的返回值类型相同
       或者
       子类方法的返回值类型是父类方法的返回值类型的 子类
</code></pre><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><pre><code>* 抽象类定义格式:
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>

* 抽象方法定义格式:
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数);</div></pre></td></tr></table></figure>

  抽象方法,没有方法体;
* 使用:
    * 定义类，继承抽象类，并重写抽象方法
    * 创建子类对象，通过子类对象调用成员
* 特点:
    * 抽象类,抽象方法被abstract修饰,抽象方法只能出现在抽象类或接口中    
    * 抽象类不能创建对象
    * 一个普通类继承抽象类,一定要重写父类所有方法
    * 抽象类中可以有抽象方法,也可以有普通方法
    * 不能和private,final,static一起用 
</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre><code>* 概念
接口是功能的集合,同样可看做是一种数据类型,是比抽象类更为抽象的”类”,一般把接口当作功能扩展.
接口只有抽象方法定义,并没有具体实现。
* 接口定义格式
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</div><div class="line">	抽象方法<span class="number">1</span>;</div><div class="line">	抽象方法<span class="number">2</span>;</div><div class="line">	抽象方法<span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

    * 抽象方法定义格式
        <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</div></pre></td></tr></table></figure>

* 类实现接口
    *　类与接口之间为实现关系,不是继承
    *　定义实现类,实现接口,并重写接口中所有抽象方法
    *　类实现接口的格式：
        class 类名 implements 接口名 {
            重写接口中所有抽象方法
        }
    *  注意: 接口不能new, 实现类可以new
    *  实现类的特点: 重写接口中所有抽象方法,除非该实现类也是抽象类,则不能new         
* 接口中成员特点
    *  (1)成员变量的特点:(其实是常量,接口中没有变量)
        *  固定格式:
            <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 变量名 = 值;</div></pre></td></tr></table></figure>

        public :  公共权限
        static :  静态,可以被　类名．（接口名．）直接调用
        final  :  最终,固定变量的值. 所以再有赋值操作,都会报错
        注意: public static final,可以不写或选择性写.但默认还是被这三个修饰
    *  (2)成员方法的特点:
        *  固定格式:
            <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</div></pre></td></tr></table></figure>

        注意: public abstract,可以不写或选择性写.但默认还是被这两个修饰
    *  (3)实现类必须覆盖掉接口中所有的抽象方法后，实现类才可以实例化。否则实现类还是一个抽象类。
* 接口的多实现
    *　接口最重要的体现：解决多继承的弊端
    　　类如果多继承，多个父类有相同功能时，子类调用会产生不确定性，
    　　因为父类中方法有主体，调用运行时，不确定运行哪个主体内容。
    *　接口并没有这种安全隐患,因为接口中全是抽象方法,并没有方法体
    *  格式:
        <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line">	重写A,B中所有抽象方法,否则不能被实例化</div><div class="line">&#125;</div></pre></td></tr></table></figure>

        注意: 如果A,B中有同名方法,但返回值不同,实现类中重写方法会报错
    *  类在继承类的同时,可以实现多个接口(先写继承,再写接口实现)
          <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

* 接口的多继承 
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> 	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

    //D实现接口C, 需要重写C接口的全部抽象方法,
    //而且C继承A,B, 所以D实现类要重写ABC中所有抽象方法
    注意: 由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性    
    *  接口与接口之间是继承关系,用extends
    *  Java支持接口之间的多继承,一个接口可以同时继承多个接口
    *  问: Java中有多继承吗?
       类不支持多继承, 接口支持多继承        
* 接口与抽象类的区别
    1. 成员: 接口中全是抽象方法,抽象类中可以有抽象方法,也可以有非抽象方法
             接口中成员变量只能是常量,抽象类中可以有变量
    2. 继承关系: 接口可以多实现,多继承   抽象类只能单继承,多层继承
    3. 设计理念:  接口是这个事物中的额外内容   抽象类是这个事物中应该具备的内容               
</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>* 概念: 一种事物有多种形态
    如Student类继承了Person类，一个Student的对象便既是Student，又是Person。
* 格式:
    父类类型或接口类型  变量名  =  new  子类的对象();
    共有三种表现形式: 
        1.普通类作为父类引用指向子类对象
        2.抽象类作为父类引用指向子类对象
        3.接口做为父类,指向实现类对象
  注意:(1)父类引用可以指向子类对象
       (2)多态调用方法,方法必须运行子类的重写方法
* 好处: 
    1. 提高了代码扩展性(多态来保证)
    2. 提高了代码维护性(继承来保证)
* 坏处: 
    1. 无法调用子类特有的属性
* 多态前提:　
    1. 要有继承(实现)关系
    2. 要有方法重写(否则多态没有意义)
    3. 父类引用指向子类对象
* 多中成员特点:
    (1)成员变量(编译,运行看父类)
        编译时,参考父类中有无这个变量,有则编译成功,没有则失败
        运行时,运行的是父类中的变量值
    (2)非静态成员方法(编译看父类,运行看子类)
        编译时,参考父类中有无这个方法,有则编译成功,没有则失败
        运行时,运行的是子类中的重写方法
    (3)静态成员方法(编译,运行看父类)
* instanceof关键字: 比较引用数据类型
    * 格式:　引用变量  instanceof 类名
                p    instanceof Student 
    比较p是不是Student类型的对象,是则返回true
* 转型
    (1)向上转型(自动转换)
        父类引用指向子类对象
        Person p = new Student();
    (2)向下转型(强制转换): 父类类型转为子类,可以调用子类中特有方法
        格式:　子类类型　变量名　＝（子类类型）父类类型的变量；        
              Student s = (Student) p ;
</code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>* 作用: 在创建对象的同时,为成员变量初始化
* 快捷键: ALT+Shift+S (Generate Constructor using Firlds)
* 格式:　
    权限　方法名（参数列表）{
        方法体；
    }
* 注意:
    １.方法名与类名完全一致
    ２.不允许写返回值类型
    ３.构造方法在创建对象的时候执行，每个对象只执行一次
    ４.每一个类都有一个构造方法，如果我们没给，编译器会自动添加一个空参数的构造方法
    特别注意: 
    1.构造方法弹栈退出后,对象才算是创建结束
    2.一个类中,如果不写构造方法,默认会有一个空参构造,但是如果写了一个,就没有默认的构造方法了
    3.构造方法中可以有return
* 重载
    类中的构造方法可以有无限个, 区别就是参数列表不同
* 构造方法和普通方法区别
    * 定义格式不同:
        构造方法: 没有返回值,且方法名和类名一致
        普通方法: 有返回值,方法名字随意
    * 执行:
        构造方法: 在对象创建时自动执行，而且只执行一次
        普通方法: 对象创建后,需要手动调用,且可以执行多次  
* this
    * 代表本类对象的引用, 由谁调用,this就代表谁
    作用:  1. 区分成员变量和局部变量的同名情况
          2. 在本类中调用其他构造方法
    格式: this(参数列表);
        调用其他构造方法时,this()必须定义在构造方法的第一行，原因是初始化动作要最先执行。
        <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">this</span>(<span class="string">"geekhoon"</span>,<span class="number">25</span>);<span class="comment">//写在方法体的第一行</span></div><div class="line">	&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">测试类的main方法:</div><div class="line">	main()&#123;</div><div class="line">		Person p = <span class="keyword">new</span> Person();</div><div class="line">		syso(p.getName());<span class="comment">//geekhoom</span></div><div class="line">		syso(p.getAge());<span class="comment">//25</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure>

* super    
    作用: 调用父类的构造方法和成员变量        
    格式: 
        调用父类中的空参数构造方法   super();
        调用父类中的有参数构造方法   super(实参列表);
    注意: 
    * 只要是构造方法默认(隐式)第一行都是super();
    * 如果父类中有多个重载构造器,子类任意调用一个即可
    * super()和this()调用构造方法时,不能放在同一个代码块中,因为都要放在第一行
    * 无论如何,子类所有的构造方法,都要直接,间接调用父类构造方法
    * 当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句，指定要访问的父类有参数构造方法。
    * 子类默认会调用父类的无参构造， 但如果父类没有无参构造(即父类自定义了一个有参构造)，子类的构造方法继续调用父类的无参构造就会报错。
</code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><pre><code>* final就是固定, 不可变
* 可修饰 类,方法,成员变量,局部变量
  1.修饰类: 不可以被继承, 但是可以继承别的类
            String类就是final修饰的
  2.修饰方法: 不可以被子类重写, 但是可以被子类继承使用
  3.修饰局部变量: 
    (1)修饰基本数据类型: 称为常量,只能被赋值一次,终身不可改变
    (2)修饰引用数据类型: 变量存储的地址不可改变 
         但被final修饰的引用类型的变量指向的对象的属性是可以发生改变的
  4.修饰成员变量:
    * final固定的是成员变量的手动赋值,不是默认值
    * 一次赋值，终身不可改变
    * 需要在创建对象前赋值，否则报错,即不能用set赋值
    * 为成员变量赋值的两种实现方式: 
      (1)直接赋值,定义时用&quot;=&quot;赋值
        final int age = 1;
      (2)使用构造器进行赋值:
        <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> age;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      这两种赋值方式它不可以一起使用
</code></pre><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><pre><code>* 特点: 被static修饰的成员属于类, 被该类的所有对象共享。被static修饰的成员可以通过类名直接调用
         多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，
      其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量
* 可修饰 方法, 成员变量
* 注意: 
    1. 被satic修饰的方法不能被重写, 但是可以重载
    2. 静态不能直接访问非静态(因为生命周期不同,静态优先于非静态存在于内存中,即静态先进入内存)
    3. 不允许写this/super(因为它们是代表本类对象和父类对象) 
* 内存中位置: 
     1.被static修饰的成员存在于方法区
     2.静态优先于非静态存在
     3.随着类的加载而加载,随着类的消亡而消亡
* 应用场景: 
    1. 什么时候使用static修饰成员变量？  
       这个成员变量需要被这个类的所有对象共享 
    2. 什么时候使用static修饰成员方法？
       静态的方法只能访问静态的成员,如果成员方法中没有调用非静态成员,可以加static 
* 定义静态常量: 
    * 格式:  public static final 数据类型 变量名 = 值;
    * 变量名全部大写，多个单词使用下划线连接
* 记住: 静态和对象没有关系, 静态是属于类的
</code></pre><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><pre><code>* 指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。
* 特点:　
　　* 只能使用一次 
　　* 可以作为方法接收的参数、方法返回值使用
</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><pre><code>* 当一个类定义在一个类的内部，这个类就是一个内部类
* 包括:
    (1)成员内部类: 
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</div><div class="line">	修饰符 <span class="class"><span class="keyword">class</span> 内部类名 </span>&#123;</div><div class="line">	 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      注意: 成员内部类可以使用外部类成员,包括私有.
            外部类要使用内部类成员,必须建立内部类对象
      外部类调用内部成员访问方式:
        外部类名.内部类名 变量名 = new 外部类对象().new 内部类对象();
        变量名.内部类方法();
    (2) 局部内部类: 把一个类定义到另一个类的方法中
</code></pre><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><pre><code>* 实质: 父类类型的子类对象, 或接口的实现类对象
* 格式: 
        new 接口或父类(){
            重写接口或者父类中的方法;(注意: 不是只重写抽象方法)
        };
* 注意: 匿名方法只能在方法中或构造代码块,局部代码块中使用
* 优点: 减少代码量
* 缺点: 可读性差
</code></pre><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><pre><code>* 概念: 实质上就是文件夹，可以对java代码进行分类管理
* 声明包格式: package 包名;
* 导入包的格式: import 要导入的包名;
  * 注意: java.lang包下的类是不需要导包也可以使用的
* 包的命名规范: 全部小写，一般是域名的倒叙。 
</code></pre><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><pre><code> 从大到小
* public: 公共的，在任何包中都可使用
* protected: 受保护的，跨包子类中，本包中也可以使用
* default: 默认的，本包中可以使用。注意，默认的是什么都不写
* private: 私有的，只能在本类中使用
注意:
1. 修饰类只能使用public、默认的、final、abstract关键字
2. abstract不能和private,static,final一起用 
</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre><code>代码块中不能创建方法
* 局部代码块：在方法中的   {} : 限定局部变量的生命周期
* 构造代码块：在类的成员位置的 {} 
     构造代码块在创建对象的时候执行，每创建一次，就执行一次。构造代码块优先于构造方法执行
* 静态代码块: 在类的成员位置
     格式:　static {

            } 
     静态代码块在类加载的时候执行，并且只会执行一次，优先于构造代码块执行
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[11.数组操作之遍历、逆序、排序及查找]]></title>
      <url>https://geekhoon.github.io/2017/01/26/11-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E4%B9%8B%E9%81%8D%E5%8E%86%E3%80%81%E9%80%86%E5%BA%8F%E3%80%81%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//打印结果为[11, 33, 44, 22, 55]</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">55</span>&#125;;</div><div class="line">	printArr(arr);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">	System.out.print(<span class="string">"["</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(i == arr.length - <span class="number">1</span>)&#123;</div><div class="line">			System.out.print(arr[i]);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			System.out.print(arr[i]+<span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	System.out.print(<span class="string">"]"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a> 
<h3 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>,end = arr.length-<span class="number">1</span>;start &lt; end;start++,end--)&#123;</div><div class="line">		<span class="keyword">int</span> temp = arr[start];</div><div class="line">		arr[start] = arr[end];</div><div class="line">		arr[end] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原理如图:</p>
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170111/233540781.bmp" alt=""></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line"><span class="comment">//外层比较了arr.length-1次</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</div><div class="line"><span class="comment">//i=0时,arr[0]和arr[1]先比,再与arr[2],arr[3]比</span></div><div class="line"><span class="comment">//i=1时,arr[1]和arr[2]先比,再与arr[3]比</span></div><div class="line"><span class="comment">//i=2时,arr[2]和arr[3]比</span></div><div class="line"><span class="comment">//所以令j=i+1,内层循环次数递减</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; arr.length;j++)&#123;</div><div class="line">		<span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</div><div class="line">			<span class="keyword">int</span> temp = arr[i];</div><div class="line">			arr[i] = arr[j];</div><div class="line">			arr[j] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原理如图:</p>
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170126/192538430.png" alt=""></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">	<span class="comment">//外层循环与选择排序一样,循环arr.length-1次</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</div><div class="line">	<span class="comment">//内层循环,索引每次从0开始, 每圈次数递减,若是j &lt; arr.length-i,会报索引越界异常</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-i-<span class="number">1</span>; j++) &#123;</div><div class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">				<span class="keyword">int</span> temp = arr[j];</div><div class="line">				arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">				arr[j+<span class="number">1</span>] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原理如图:</p>
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170126/195527596.png" alt=""></p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> min = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> max = arr.length - <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> mid = <span class="number">0</span>;</div><div class="line">	<span class="comment">//当min&gt;max,证明未找到,返回-1</span></div><div class="line">	<span class="keyword">while</span>(min &lt;= max)&#123;</div><div class="line">		mid = (min + max)/<span class="number">2</span>;</div><div class="line">		<span class="comment">////让查找元素和中间索引元素进行比较</span></div><div class="line">		<span class="keyword">if</span> (key &gt; arr[mid]) &#123;</div><div class="line">			min = mid + <span class="number">1</span>;</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</div><div class="line">			max = mid - <span class="number">1</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//找到元素,返回元素索引</span></div><div class="line">			<span class="keyword">return</span> mid;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原理如图:</p>
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170126/220130538.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[10.集合]]></title>
      <url>https://geekhoon.github.io/2017/01/15/10-%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h3 id="ArrayList创建变量的步骤"><a href="#ArrayList创建变量的步骤" class="headerlink" title="ArrayList创建变量的步骤"></a>ArrayList创建变量的步骤</h3><pre><code>* 导入包 java.util包中
* 创建引用类型的变量
    数据类型&lt; 集合存储的数据类型&gt;  变量名 = new 数据类型&lt;集合存储的数据类型&gt;();
       创建集合引用变量的时候,必须先指定好存储的数据类型
* 变量名.方法 
    注意: 集合只存储引用数据类型,不存储基本类型
    8个基本类型要对应8个引用类型
</code></pre><a id="more"></a> 
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170115/204404840.bmp" alt=""></p>
<h3 id="集合和数组区别"><a href="#集合和数组区别" class="headerlink" title="集合和数组区别"></a>集合和数组区别</h3><pre><code>          集合            数组
长度:       可变        |    固定
数据类型:  只能引用    |    既可以基本既可以引用
</code></pre><h3 id="ArrayList的常见方法"><a href="#ArrayList的常见方法" class="headerlink" title="ArrayList的常见方法"></a>ArrayList的常见方法</h3><pre><code>* add(参数)           向集合中添加元素
* get(int index)   取出集合中的元素,get方法的参数,写入索引
* size()            返回集合的长度, 集合存储元素的个数

* add(int 索引,存储的元素)     将元素添加到指定的索引上
* set(int 索引,修改后的元素)     将指定索引的元素,进行修改
* remove(int 索引)             删除指定索引上的元素
* clear()                     清空集合中的所有元素,对象不会删
</code></pre><h3 id="ArrayList集合的遍历"><a href="#ArrayList集合的遍历" class="headerlink" title="ArrayList集合的遍历"></a>ArrayList集合的遍历</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>* 区别:遍历时,集合存储(Integer类型)与(类),调用get()得到的值是有区别的,分别是值与地址
* 但是类中如果重写了Object的toString()方法,可以打印出内容
</code></pre><h4 id="四种遍历方式"><a href="#四种遍历方式" class="headerlink" title="四种遍历方式:"></a>四种遍历方式:</h4><pre><code>1. System.out.println(集合变量名);(这个其实不算遍历,只是打印而已)
   这种方式适用于String类型和基本数据类型对应的引用类型如Integer做泛型的情况,如果是自定义类,需要重写toString()
2. 普通for循环遍历
3. 增强for循环
4. 迭代器  
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Integer类型:</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo_2</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">		array.add(<span class="number">121</span>);</div><div class="line">		array.add(<span class="number">125</span>);</div><div class="line">		array.add(<span class="number">123</span>);</div><div class="line">		array.add(<span class="number">120</span>);</div><div class="line">		array.add(<span class="number">128</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//对集合进行遍历</span></div><div class="line">		<span class="comment">//使用方法 size+get组合进行遍历</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.size(); i++)&#123;</div><div class="line">			System.out.println( array.get(i) );</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">类:</div><div class="line"><span class="comment">//遍历集合,打印所有学生信息</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;Student&gt; array)</span>	</span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size();i++)&#123;</div><div class="line">		<span class="comment">//array.get(i)返回的是Student对象,用s接收</span></div><div class="line">		Student s = array.get(i);</div><div class="line">		<span class="comment">//直接打印s ,是地址值,除非重写了toString()</span></div><div class="line">		System.out.println(<span class="string">"姓名是"</span>+s.name+<span class="string">",年龄是"</span>+s.age);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="集合中存储类对象-内存图"><a href="#集合中存储类对象-内存图" class="headerlink" title="集合中存储类对象 内存图"></a>集合中存储类对象 内存图</h4><p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170115/195450789.png" alt=""></p>
<h3 id="集合继承关系图"><a href="#集合继承关系图" class="headerlink" title="集合继承关系图"></a>集合继承关系图</h3><pre><code>* ArrayList类继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。
* Collection接口为最顶层集合接口了。Collection接口中的方法,是集合中所有实现类必须拥有的方法
* 源代码: 
    interface List extends Collection {
      }                                                    
      public class ArrayList extends AbstractList implements List{
      }
* Collection下都为单列集合
* Collecton接口常用的子接口有：List接口、Set接口
    * List接口常用的子类有：ArrayList类、LinkedList类
    * Set接口常用的子类有：HashSet类、LinkedHashSet类 

    * List: 存取有序,有索引,可以重复
        * ArrayList  : 底层依赖的是数组, 查询快, 增删慢
        * LinkedList : 底层依赖的是链表, 查询慢, 增删快
        * Vector : 线程安全,效率低(过时了)
    * Set : 存取无序,无索引,不能重复
        * HashSet : 顶层使用的是hash算法
            * LinkedHashSet : 可以保证存取有序
* 关系图     
                 Collection 接口     
                       |
         ----------------------------------------------------------------
         |                                                              |
       List接口                                                      Set接口
         |                                                              |
     ----------------                                             -------------
     |              |                                                   |     
ArrayList类   LinkedList类                                              HashSet类
                                                                        |
                                                                    LinkedHashSet类
</code></pre><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><pre><code>* 是一个接口
* 区别与Collections, Collections是一个集合工具类,里面有操作List集合的排序,查找等静态方法
  可以Collections.sort(list)使用
</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>* add()
* clear() :  清空集合中的所有元素, 集合容器本身依然存在,还可以继续添加
* size()
* boolean contains(Object o) : 判断任意类型数据是否存在于集合中  ,存在返回true
* Object[] toArray() : 集合中的元素,转成一个数组中的元素,集合转成数组    
  注意返回值类型,要写成Object数组
  集合转数组的意义: IO中获取文件夹下的文件
* boolean remove(Object o) : 移除集合中指定的元素(若重复,删掉第一个)
</code></pre><h4 id="Java中三种长度表现形式"><a href="#Java中三种长度表现形式" class="headerlink" title="Java中三种长度表现形式"></a>Java中三种长度表现形式</h4><pre><code>* 数组.length 属性  返回值 int
* 字符串.length() 方法,返回值int
* 集合.size()方法, 返回值int
</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接口多态的方式调用</span></div><div class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">coll.add(<span class="string">"abc"</span>);</div><div class="line">coll.add(<span class="string">"bcd"</span>);</div><div class="line">coll.add(<span class="string">"abc"</span>);</div><div class="line">coll.add(<span class="string">"abc"</span>);</div><div class="line">coll.add(<span class="string">"bcd"</span>);</div><div class="line">coll.add(<span class="string">"cde"</span>);</div><div class="line">System.out.println(coll);</div><div class="line"></div><div class="line">coll.clear();</div><div class="line">System.out.println(coll);</div><div class="line"></div><div class="line">Object[] objs = coll.toArray();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objs.length;i++)&#123;</div><div class="line">	System.out.println(objs[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ArrayList中remove(int 索引) : 删除指定索引上的元素</span></div><div class="line">ArrayList&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">coll.add(<span class="string">"aaa1"</span>);<span class="comment">//1处</span></div><div class="line">coll.add(<span class="string">"aaa4"</span>);<span class="comment">//2处</span></div><div class="line">coll.add(<span class="string">"aaa1"</span>);<span class="comment">//3处</span></div><div class="line">coll.add(<span class="string">"aaa1"</span>);</div><div class="line">coll.add(<span class="string">"aaa4"</span>);</div><div class="line">coll.add(<span class="string">"aaa5"</span>);</div><div class="line"><span class="comment">//get(索引)获取元素,只是ArrayList中的方法,Collection中没有,使用多态要向下转型</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coll.size(); i++) &#123;</div><div class="line">	<span class="keyword">if</span> (<span class="string">"aaa1"</span>.equals(coll.get(i))) &#123;</div><div class="line"><span class="comment">//注意ArrayList中remove的小细节,1处有"aaa1"删除后,i=1,</span></div><div class="line"><span class="comment">//假如2处也为"aaa1",因为删完后2处索引为0,而此时i=1,2处的"aaa1"就不会被删除</span></div><div class="line"><span class="comment">//将如1 2 3处如上所示,则没有影响,第二个出现的"aaa1"也可以被删除</span></div><div class="line">		coll.remove(i--);<span class="comment">//如果有相邻的重复元素,删除后,索引必须--</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(coll);</div></pre></td></tr></table></figure>
<h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><pre><code>* 是一个接口
* 因为每种集合的底层的数据结构不同, 迭代器是一种通用的获取集合中元素的方式
* ArrayList是Iterable的实现类
</code></pre><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>* boolean hasNext() : 判断集合中还有没有可以被取出的元素,如果有返回true
* next() : 取出集合中的下一个元素,且指针后移
</code></pre><h4 id="使用迭代器对集合进行遍历的步骤"><a href="#使用迭代器对集合进行遍历的步骤" class="headerlink" title="使用迭代器对集合进行遍历的步骤:"></a>使用迭代器对集合进行遍历的步骤:</h4><pre><code>1. 通过集合获取一个迭代器
   Iterator&lt;E&gt; it = list.iterator();//it是Iterator接口的实现类的对象
2. 循环判断迭代器中是否有元素
   while(it.hasnext()){
     3. 如果有元素, 取出元素并打印
      System.out.println(it.next());//it.next()的返回值类型为泛型E
    }
</code></pre><h4 id="for循环迭代写法"><a href="#for循环迭代写法" class="headerlink" title="for循环迭代写法:"></a>for循环迭代写法:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//for循环节约内存(因为迭代期在for里面)</span></div><div class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = coll.iterator(); it.hasNext();  ) &#123;</div><div class="line"> 	System.out.println(it.next());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="集合迭代中的转型"><a href="#集合迭代中的转型" class="headerlink" title="集合迭代中的转型"></a>集合迭代中的转型</h4><pre><code>* 注意:　
1. 集合中存储其实都是对象的地址。
2. 集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。
// 因为出现了基本类型包装类，它提供了自动装箱操作，集合中的元素就是基本数值的包装类对象。
3. 存储时提升了Object。取出时要使用元素的特有内容，必须向下转型
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Collection coll = <span class="keyword">new</span> ArrayList();</div><div class="line">coll.add(<span class="string">"abc"</span>);</div><div class="line">coll.add(<span class="string">"aabbcc"</span>);</div><div class="line">coll.add(<span class="string">"cast"</span>);</div><div class="line">Iterator it = coll.iterator();</div><div class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">	<span class="comment">//由于元素被存放进集合后全部被提升为Object类型</span></div><div class="line">	<span class="comment">//当需要使用子类对象特有方法时，需要向下转型</span></div><div class="line">	String str = (String) it.next();</div><div class="line">	System.out.println(str.length());</div><div class="line">&#125;</div><div class="line"><span class="comment">//注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。</span></div><div class="line"></div><div class="line"><span class="comment">//注意:　Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下：</span></div><div class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">coll.add(<span class="string">"abc"</span>);</div><div class="line">coll.add(<span class="string">"aabbcc"</span>);</div><div class="line">coll.add(<span class="string">"cast"</span>);</div><div class="line">Iterator&lt;String&gt; it = coll.iterator();</div><div class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">	String str =  it.next(); </div><div class="line">	<span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></div><div class="line">    System.out.println(str.length());</div><div class="line">	<span class="comment">// System.out.println(str+"....."+it.next());注意str与it.next()值会不一样,因为指针后移了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><pre><code>* 增强for循环是JDK1.5新特性
* JDK1.5版本后,出现新的接口 java.lang.Iterable , Collection开始继承Iterable
* Iterable接口的主要作用就是,实现增强for循环
</code></pre><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre><code>* for( 数据类型  变量名 : 数组或者集合 ){
       System.out.println(变量名);
  }
</code></pre><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><pre><code>* 好处:　代码少了，方便对容器遍历 
* 坏处:　没有索引，不能操作容器里面的元素
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</div><div class="line">		System.out.println(i);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//for对于对象数组遍历的时候,可以调用对象的方法  </span></div><div class="line">    String[] str = &#123;<span class="string">"abc"</span>,<span class="string">"cde"</span>,<span class="string">"cdef"</span>&#125;;</div><div class="line">    <span class="keyword">for</span>(String s : str)&#123;</div><div class="line">      System.out.println(s.length());<span class="comment">//可以调用String类的方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//存储自定义Person类型</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</div><div class="line">	ArrayList&lt;Person&gt; array = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</div><div class="line">	array.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">20</span>));</div><div class="line">	array.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">10</span>));</div><div class="line">	<span class="keyword">for</span>(Person p : array)&#123;</div><div class="line">		<span class="comment">//可以调用Person类中方法</span></div><div class="line">		System.out.println(p);<span class="comment">// 调用内容需要重写toString方法</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><pre><code>* JDK1.5出现新的安全机制,保证程序的安全性
* 指明了集合中存储数据的类型  &lt;数据类型&gt;
* 伪泛型
    * Java中泛型,是伪泛型 : 编译后class文件中,没有泛型
</code></pre><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><pre><code>* 格式:　修饰符 class 类名&lt;代表泛型的变量&gt; {  }
</code></pre><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><pre><code>* 格式: 修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }
    * 如: API中的ArrayList集合中的方法：
        public &lt;T&gt; T[] toArray(T[] a){  } 
//该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组
这个toArray方法不推荐使用, 将集合转成数组推荐定义一个新数组,然后遍历向里面赋值
</code></pre><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><pre><code>* 格式: 修饰符 interface 接口名&lt;代表泛型的变量&gt; {  }
* 方式一(常用): 实现类,先实现接口,不理会泛型:
  public class ArrayList&lt;E&gt; implements List&lt;E&gt;{ }
  调用者 : new ArrayList&lt;String&gt;() 后期创建集合对象的时候,指定数据类型 
* 方式二: 实现类,在实现接口的同时,也指定了数据类型
  public class 类名 implements List&lt;String&gt;{ }
</code></pre><h5 id="泛型好处"><a href="#泛型好处" class="headerlink" title="泛型好处"></a>泛型好处</h5><pre><code>1. 安全性(不指定类型,强转时传入不同类型会异常) 
2. 将运行时期的ClassCastException，提前到了编译时期
</code></pre><h4 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h4><pre><code>* 可以匹配所有的数据类型:  ? 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">  </div><div class="line">  	HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">  </div><div class="line">	  array.add(<span class="string">"123"</span>);</div><div class="line">	  array.add(<span class="string">"456"</span>);</div><div class="line">	  </div><div class="line">	  set.add(<span class="number">789</span>);</div><div class="line">	  set.add(<span class="number">890</span>);</div><div class="line">	  </div><div class="line">	  iterator(array);</div><div class="line">	  iterator(set);</div><div class="line">&#125;</div><div class="line">	<span class="comment">/*</span></div><div class="line">     *  定义方法,可以同时迭代2个集合</div><div class="line">     *  参数:不能写ArrayList,也不能写HashSet,所以可以写它们共同实现的接口</div><div class="line">     *  数据类型写泛型通配符 ?</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;</div><div class="line">	Iterator&lt;?&gt; it = coll.iterator();</div><div class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">		<span class="comment">//it.next();  注意这里不能强转,因为要匹配多个集合,不能指定单一类型</span></div><div class="line">		System.out.println(it.next()); <span class="comment">//直接放入打印语句中</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="comment">//创建3个集合对象</span></div><div class="line">  ArrayList&lt;ChuShi&gt; cs = <span class="keyword">new</span> ArrayList&lt;ChuShi&gt;();</div><div class="line">  ArrayList&lt;FuWuYuan&gt; fwy = <span class="keyword">new</span> ArrayList&lt;FuWuYuan&gt;();</div><div class="line">  ArrayList&lt;JingLi&gt; jl = <span class="keyword">new</span> ArrayList&lt;JingLi&gt;();</div><div class="line">  </div><div class="line">  <span class="comment">//每个集合存储自己的元素</span></div><div class="line">  cs.add(<span class="keyword">new</span> ChuShi(<span class="string">"张三"</span>, <span class="string">"后厨001"</span>));</div><div class="line">  cs.add(<span class="keyword">new</span> ChuShi(<span class="string">"李四"</span>, <span class="string">"后厨002"</span>));</div><div class="line">  </div><div class="line">  fwy.add(<span class="keyword">new</span> FuWuYuan(<span class="string">"翠花"</span>, <span class="string">"服务部001"</span>));</div><div class="line">  fwy.add(<span class="keyword">new</span> FuWuYuan(<span class="string">"酸菜"</span>, <span class="string">"服务部002"</span>));</div><div class="line">  </div><div class="line">  jl.add(<span class="keyword">new</span> JingLi(<span class="string">"小名"</span>, <span class="string">"董事会001"</span>, <span class="number">123456789.32</span>));</div><div class="line">  jl.add(<span class="keyword">new</span> JingLi(<span class="string">"小强"</span>, <span class="string">"董事会002"</span>, <span class="number">123456789.33</span>));</div><div class="line">  </div><div class="line">  ArrayList&lt;String&gt; arrayString = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//1处</span></div><div class="line">  iterator(jl);</div><div class="line">  iterator(fwy);</div><div class="line">  iterator(cs);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work</div><div class="line"> * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法</div><div class="line"> * 强制转换: 只写? ,是Object类型 it.next() = Object o ==&gt; Employee</div><div class="line"> * 写完泛型限定后,1处就会报错,不允许传入String类型</div><div class="line"> * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象</div><div class="line"> * 泛型的限定  本案例,父类固定Employee,但是子类可以无限</div><div class="line"> *   ? extends Employee 限制的是父类, 称为上限限定, 可以传递Employee,传递他的子类对象</div><div class="line"> *   ? super   Employee 限制的是子类, 称为下限限定, 可以传递Employee,传递他的父类对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(ArrayList&lt;? extends Employee&gt; array)</span></span>&#123;</div><div class="line">  </div><div class="line">   Iterator&lt;? extends Employee&gt; it = array.iterator();</div><div class="line">   <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">     <span class="comment">//获取出的next() 数据类型,是什么Employee</span></div><div class="line">     Employee e = it.next();</div><div class="line">     e.work();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><pre><code>* 特点: 有序,有索引,可以重复
    * 它的实现类ArrayList,LinkedList也满足上述特点
* 特有方法
    * 注意:　特有方法是带有索引的方法
    * 带有索引的操作,防止越界问题(集合中索引越界异常:　java.lang.IndexrOutOfBoundException)
        * ArrayIndexrOutOfBoundException : 数组索引越界异常
        * StringIndexrOutOfBoundException :字符串索引越界异常
    1. 增: add(int index, E): 将元素插入到列表的指定索引上
    2. 删: E remove(int index): 移除指定索引上的元素 , 返回被删除之前的元素
    3. 改:　E set(int index, E): 修改指定索引上的元素 , 返回被修改之前的元素
    4. 查: E get(int index): 获取指定索引处的元素，并返回该元素
* 三种遍历方式
    1. 迭代器
    2. 普通for
    3. 增强for
</code></pre><h5 id="迭代器的并发修改异常"><a href="#迭代器的并发修改异常" class="headerlink" title="迭代器的并发修改异常"></a>迭代器的并发修改异常</h5><pre><code>* 迭代器原理: 通过集合获取一个迭代器后,迭代器里面的内容是集合内容的映射
* 迭代器遍历过程中,使用了集合方法修改了集合长度(注意是修改长度,才会出错),
  导致迭代器并不知道集合中的变化，容易引发数据的不确定性, 
  会抛异常:java.util.ConcurrentModificationException
* 处理办法: 
    1. 使用迭代器自身的办法, 有remove(),没add
    2. 或者通过ListIterator迭代器操作元素是可以的，
       ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	list.add(<span class="string">"aaa1"</span>);</div><div class="line">	list.add(<span class="string">"aaa2"</span>);</div><div class="line">	list.add(<span class="string">"aaa3"</span>);</div><div class="line">	list.add(<span class="string">"aaa4"</span>);</div><div class="line">	list.add(<span class="string">"aaa5"</span>);</div><div class="line">	list.add(<span class="string">"aaa6"</span>);</div><div class="line">	list.add(<span class="string">"aaa7"</span>);</div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	Iterator&lt;String&gt; it = list.iterator();</div><div class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">		String str = it.next();</div><div class="line">		<span class="keyword">if</span> (str.equals(<span class="string">"aaa2"</span>)) &#123;<span class="comment">//0处</span></div><div class="line">			<span class="comment">//list.add("2222");  //1处</span></div><div class="line">			<span class="comment">//it.remove("aaa3"); //2处</span></div><div class="line">			it.remove(); <span class="comment">//3处</span></div><div class="line">			count++;</div><div class="line">			<span class="comment">//System.out.println("删了"+count+"次");</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">//System.out.println(str); //4处</span></div><div class="line">	&#125;</div><div class="line">	System.out.println(list);<span class="comment">//5处</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//0处判断,当前字符串是不是"aaa2",如果是,若运行1处,则会抛迭代器的并发修改异常</span></div><div class="line"><span class="comment">//2处是错的,因为迭代器的remove方法,没有参数</span></div><div class="line"><span class="comment">//执行3处后,"aaa2"被删除, 当然count是1,因为只有一个"aaa2"</span></div><div class="line"><span class="comment">//执行4处, 全部字符串都会打印</span></div><div class="line"><span class="comment">//执行5处, 除了"aaa2"都会打印</span></div><div class="line">注意这里有一个结论:并不会报错 !!</div><div class="line">如果是<span class="keyword">if</span>(str.equals(<span class="string">"aaa6"</span>)),即判断是倒数第二个,可以用集合的remove方法删除任何一个,比如list.remove(<span class="string">"aaa1"</span>);</div><div class="line">如果是<span class="keyword">if</span>(str.equals(<span class="string">"aaa5"</span>)),即判断是倒数第三个,可以用集合的remove方法删除任何两个,比如list.remove(<span class="string">"aaa1"</span>);list.remove(<span class="string">"aaa2"</span>);</div><div class="line">...</div><div class="line"><span class="comment">//迭代器没有add方法,但是要求用迭代器遍历,且如果集合中存在"aaa2",添加"AAA2"</span></div><div class="line"><span class="comment">//则可以定义一个标记, 如:</span></div><div class="line">Iterator&lt;String&gt; it = list.iterator();</div><div class="line"><span class="keyword">boolean</span> b = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">	String str = it.next();</div><div class="line">	<span class="keyword">if</span> (str.equals(<span class="string">"aaa2"</span>)) &#123;</div><div class="line">			b = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(b)&#123;</div><div class="line">	list.add(<span class="string">"AAA2"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="List集合存储数据的结构"><a href="#List集合存储数据的结构" class="headerlink" title="List集合存储数据的结构"></a>List集合存储数据的结构</h5><pre><code>* 常用数据存储结构: 栈,队列,数组,链表
* 栈:   先进后出(手枪弹夹)
* 队列: 先进先出(火车安检)
* 数组: 
   1. 查询快:通过索引快速找到元素
   2. 增删慢:每次增删都需要开辟新的数组,将老数组中的元素拷贝到新数组中,开辟新数组耗费资源
* 链表: 
   1. 查询慢:每次都需要从链头或者链尾找起
   2. 增删快:只需要修改元素记录的下个元素的地址值即可不需要移动大量元素
</code></pre><h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><pre><code>* 底层采用的是**数组**结构, 查询快,增删慢, 主要用来查询,遍历数据    
    ArrayList al=new ArrayList();//创建了一个长度为0的Object类型数组
     al.add(&quot;abc&quot;);//底层会创建一个长度为10的Object数组 Object[] obj=new Object[10]
    //obj[0]=&quot;abc&quot;
    //如果添加的元素的超过10个,底层会开辟一个1.5*10的长度的新数组
    //把原数组中的元素拷贝到新数组,再把最后一个元素添加到新数组中
    原数组:
     a b c d e f g h k l
    添加m:
     a b c d e f g h k l m null null null null
    注意: 打印集合长度,还是根据集合中存入数据的个数,而不是开辟空间的长度,即存入一个数据,打印长度为1
</code></pre><h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><pre><code>* 自身特点:　
    1. 底层是**链表**实现, 查询慢,增删快
    2. LinkedList的索引决定是从链头开始找还是从链尾开始找
       如果该元素小于元素长度一半,从链头开始找起,如果大于元素长度的一半,则从链尾找起
* 特有功能: (子类的特有功能,不能多态调用)
    1. addFirst(E): 添加到链表开头
    2. addLast(E) : 添加到链表结尾
     3. E getFirst(): 获取链表开头
     4. E getLast() : 获取链表结尾
        3和4在获取时,要判断是否元素,否则报错 if(list.size() != 0 )
    5. E removeFirst() : 移除并返回链表开头
    6. E removeLast()  : 移除并返回链表结尾
    5. isEmpty() : 判空  //这个不是特有,是Collection的方法
</code></pre><h4 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h4><pre><code>* Vector集合数据存储的结构是**数组**结构，为JDK中最早提供的集合,它是线程同步的
* 过时了,了解, 被ArrayList取代
* 弱点:　运行速度慢
</code></pre><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><pre><code>* 特点: 无序, 无索引,不存储重复元素
* 元素取出方式:
    1. 迭代器
    2. 增强for ,因为没有索引, 所以不能用普通for
* 方法与Collection接口一模一样
</code></pre><h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><pre><code>* Set接口的实现类
* HashSet代码的编写,和ArrayList一致
* 自身特点: 
    1. 底层数据结构是**哈希表**
    2. 存取比较快
    3. 线程不安全,运行速度快
* 注意: 取出顺序和存储顺序不同,但不管取出多少次,元素打乱取出的顺序是不变的,即遍历几次结果是一样的    
</code></pre><h5 id="Set集合存储和迭代"><a href="#Set集合存储和迭代" class="headerlink" title="Set集合存储和迭代"></a>Set集合存储和迭代</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//HashSet代码的编写,和ArrayList一致</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">		set.add(<span class="string">"11"</span>);</div><div class="line">		set.add(<span class="string">"22"</span>);</div><div class="line">		set.add(<span class="string">"33"</span>);</div><div class="line">		set.add(<span class="string">"java"</span>);</div><div class="line">		set.add(<span class="string">"55"</span>);</div><div class="line"></div><div class="line">		Iterator&lt;String&gt; it = set.iterator();</div><div class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">			System.out.println(it.next());</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"=============="</span>);</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(String s : set)&#123;</div><div class="line">			System.out.println(s);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="哈希表Hashtable数据结构"><a href="#哈希表Hashtable数据结构" class="headerlink" title="哈希表Hashtable数据结构"></a>哈希表Hashtable数据结构</h5><pre><code>* 数组链表结合
* 初始容量指的是数组的长度,默认长度是16
* 加载因子: 表中填入的记录数/哈希表的长度, 默认0.75 ,决定扩容时机
* 数组扩容:　当插入元素的个数 &gt; (当前数组长度 * 加载因子),会扩容
  底层会开辟一个长度为原长度2倍的数组,把老元素拷贝到新数组中,再把新元素添加数组中
</code></pre><h5 id="对象的哈希值"><a href="#对象的哈希值" class="headerlink" title="对象的哈希值"></a>对象的哈希值</h5><pre><code>* 一个普通的十进制整数
* 父类Object中有一个方法int hashcode() : 返回对象的哈希值,返回值int类型,结果不唯一
* 子类中可以重写hashcode(),自定义哈希值
* 哈希值是存储到HashSet的依据
* String类继承Object类,重写了hashcode()方法, **只要字符串相同,则返回结果唯一**,和对象地址相同无关
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	String s = <span class="string">"123"</span>;</div><div class="line">	String s1 = <span class="keyword">new</span> String(<span class="string">"123"</span>); <span class="comment">//s和s1地址不同, 但哈希值只考虑字符串是否相等</span></div><div class="line">	System.out.println(s.hashCode());<span class="comment">//48690</span></div><div class="line">	System.out.println(s1.hashCode());<span class="comment">//48690 结果一样,参考String类重写的hashcode()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="哈希表的存储结构"><a href="#哈希表的存储结构" class="headerlink" title="哈希表的存储结构"></a>哈希表的存储结构</h5><pre><code>* 可以解释HashSet存储元素不重复的原因
* 存取原理: 
  每存入一个新的元素都要走以下三步:
    1. 调用对象的hashCode()方法算出哈希值h
    2. 集合在容器中找是否与新元素哈希值相同的老元素,
          如果没有,直接存入
           如果有,转到第三步
    3. 集合会让新元素调用它的equals方法,若结果为true,集合判定元素重复,不再存入
       若为false,集合判定对象没有重复,采用&quot;桶&quot;的存储方式存入
       重复上述操作.....
* 哈希表存储对象的依据是: **对象的哈希值和equals方法**
</code></pre><h6 id="哈希表存储过程"><a href="#哈希表存储过程" class="headerlink" title="哈希表存储过程"></a>哈希表存储过程</h6><p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170215/192545705.png" alt=""></p>
<h5 id="哈希表存储自定义对象"><a href="#哈希表存储自定义对象" class="headerlink" title="哈希表存储自定义对象"></a>哈希表存储自定义对象</h5><pre><code>* 自定义类重写hashCode()和equals()的条件是: **需要写入哈希表**
* 自定义对象重写hashCode()和equals(), 要尽量降低出现相同哈希值的概率
* 重写目的: 让对象中的属性值相同时,得到相同的哈希值
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果自定义类没有重写hashCode()和equals():</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	HashSet&lt;Person&gt; list = <span class="keyword">new</span> HashSet&lt;Person&gt;();</div><div class="line">	</div><div class="line">	list.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>, <span class="number">11</span>));</div><div class="line">	list.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>, <span class="number">11</span>));</div><div class="line">	list.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>, <span class="number">10</span>));</div><div class="line">	list.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>, <span class="number">10</span>));</div><div class="line">	list.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>, <span class="number">13</span>));</div><div class="line">	list.add(<span class="keyword">new</span> Person(<span class="string">"d"</span>, <span class="number">12</span>));</div><div class="line">	</div><div class="line">	System.out.println(list);<span class="comment">//全部都会乱序打印出来</span></div><div class="line">	</div><div class="line">&#125;</div><div class="line"><span class="comment">//没有重写的话,会调用Object类中的hashCode()方法,属性值相同的对象也会哈希值不同</span></div><div class="line"></div><div class="line"><span class="comment">//自定义对象重写hashCode()和equals():</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> name.hashCode() + age * <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123; <span class="comment">//如果传的就是本对象,返回true</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; <span class="comment">//如果传空对象,返回false</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123; <span class="comment">//如果传的是Person类型,则进行强转</span></div><div class="line">		Person p = (Person) obj;</div><div class="line">		<span class="keyword">return</span> name.equals(p.name) &amp;&amp; age == p.age;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果传的不是Person类型对象,则返回false</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h4><pre><code>* 继承HashSet
* 自身特点: 
    1. 具有可预知顺序的集合(怎么存,怎么取,**有序**)
    2. 基于链表的哈希表实现, 线程不安全集合, 运行速度快
    3. 双向链表
* 链表采用对象地址记录
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; list = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</div><div class="line">list.add(<span class="string">"1"</span>);</div><div class="line">list.add(<span class="string">"2"</span>);</div><div class="line">list.add(<span class="string">"3"</span>);</div><div class="line">list.add(<span class="string">"4"</span>);</div><div class="line">list.add(<span class="string">"5"</span>);</div><div class="line">list.add(<span class="string">"6"</span>);</div><div class="line">list.add(<span class="string">"7"</span>);</div><div class="line">list.add(<span class="string">"8"</span>);</div><div class="line"></div><div class="line">System.out.println(list);</div><div class="line"><span class="comment">//打印结果为[1, 2, 3, 4, 5, 6, 7, 8],顺序与存储时一致</span></div></pre></td></tr></table></figure>
<h4 id="判断集合元素唯一的原理"><a href="#判断集合元素唯一的原理" class="headerlink" title="判断集合元素唯一的原理"></a>判断集合元素唯一的原理</h4><pre><code>* Arraylist集合, 判断元素是否唯一调用contains方法
  contains方法底层依赖于equals方法
* HashSet集合的add()方法和contains方法(),底层都依赖于hashCode()和equals()
* 8中基本数据类型的包装类和String类都重写了hashCode()和equals()
* **特别注意**: 
  使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，
  则判断重复时，使用的是地址值，
  如果想通过内容比较元素是否相同，需要重写该元素类的hashcode与equals方法。
</code></pre><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><pre><code>1. 如果两个对象的哈希值相同 p1.hashCode()==p2.hashCode()
   两个对象的equals一定返回true吗  p1.equals(p2) 一定是true吗
    正确答案:不一定 
    public int hashCode(){
        return 0;
    }
    public boolean equals(Object obj){
        return false;
    }//方法写死
2. 如果两个对象的equals方法返回true,p1.equals(p2)==true
   两个对象的哈希值一定相同吗
    正确答案: 一定
    //hashCode()相同才会调用equals()
    //而且官方API中规定了根据equals(),如果两个对象相等,则这两个对象中的每个对象调用的hashCode()必须生成相同的结果
</code></pre><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><pre><code>* 接口　Map&lt;K , V&gt;  ,K:键, V:值
* Map中的集合是双列集合, Map是双列集合顶层接口
* Map中是映射关系的键值对,键不可以重复,值可以重复
* 常用集合(Map的实现类):　
    1. HashMap: hash算法 ,针对的是键 ,无序
    2. LinkedHashMap : HashMap的子类, 可以保证有序
</code></pre><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>* V put(K,V): 将键值对存储到集合中, K:键的对象,V:值的对象 ,返回值是值的类型
  存储重复键时,会将原有的值覆盖,不会出现重键的情况
  方法的返回值一般情况下, 会返回null
  当存储重复键的时候, 返回被覆盖之前的值, 如果不出现键重复的情况, 返回值是null
* V get(K): 通过键对象, 获取值对象 ,V是值的类型
    * 若集合中没有这个键, 返回null
* V remove(K): 移除集合中的键值对 ,返回被移除以前的值
    * 若集合中没有这个键, 返回null
* putAll(Map)
* values()
* contaionsValue
* contaionsKey
</code></pre><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><pre><code>* 迭代器和增强for不能直接遍历Map
</code></pre><h5 id="方式一-利用键获取值"><a href="#方式一-利用键获取值" class="headerlink" title="方式一: 利用键获取值"></a>方式一: 利用键获取值</h5><pre><code>* Set&lt;&gt; keySet() : 得到Map集合中所有的键,装入Set集合
* 步骤: 
    1. map集合调用keySet, 所有键存入Set集合
    2. 遍历Set集合, 获取Set集合中所有的元素(Map中的键)
    3. 调用map集合中的get方法, 通过键获取到值
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 遍历方式一 , 利用键获取值</div><div class="line"> * 注意: 遍历的是Set集合</div><div class="line"> */</div><div class="line">Set&lt;Integer&gt; set = map.keySet();</div><div class="line"><span class="comment">//迭代器</span></div><div class="line">Iterator&lt;Integer&gt; it = set.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">	Integer key = it.next();</div><div class="line">	String value = map.get(key);</div><div class="line">	System.out.println(key+<span class="string">"..."</span>+value);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"-----------分割线-------------"</span>);</div><div class="line"><span class="comment">//增强for</span></div><div class="line"><span class="keyword">for</span>(Integer key : set)&#123;</div><div class="line">	String value = map.get(key);</div><div class="line">	System.out.println(key+<span class="string">"..."</span>+value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="方式二-entrySet方法"><a href="#方式二-entrySet方法" class="headerlink" title="方式二: entrySet方法"></a>方式二: entrySet方法</h5><pre><code>* Entry键值对对象
* 键值对映射关系
* Entry接口是Map接口的一个静态嵌套接口,可以通过Map.Entry调用
* 步骤: 
    1. map集合调用entrySet()将集合的映射关系对象,存储到Set集合, 返回值Set&lt; Entry&lt;K,V&gt; &gt; ,
        出现了泛型的嵌套
    2. 迭代Set集合
    3. 获取出的Set集合的元素, 是映射关系的对象 Map.Entry&lt;K,V&gt; 
    4. 通过映射关系对象的方法, getKey,getValue获取键值对
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 遍历方式二, entrySet()</div><div class="line"> */</div><div class="line"><span class="comment">//1.map集合调用entrySet()方法, 将映射关系对象存储到Set集合</span></div><div class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set2 = map.entrySet();</div><div class="line"><span class="comment">//迭代器-------------------</span></div><div class="line"><span class="comment">//2.迭代Set集合</span></div><div class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it1 = set2.iterator();</div><div class="line"><span class="keyword">while</span>(it1.hasNext())&#123;</div><div class="line">	<span class="comment">//3.获取set集合中的元素, 是映射关系对象</span></div><div class="line">	Map.Entry&lt;Integer, String&gt; entry = it1.next();</div><div class="line">	<span class="comment">//4.通过映射关系对象的getKey,getValue,获取键值</span></div><div class="line">	Integer key = entry.getKey();</div><div class="line">	String value = entry.getValue();</div><div class="line">	System.out.println(key+<span class="string">"..."</span>+value);</div><div class="line">	</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"-----------分割线-------------"</span>);</div><div class="line"><span class="comment">//注意: 增强for不能遍历Map, 因为只有Iterable接口的实现类才可以用增强for,</span></div><div class="line"><span class="comment">//Map接口,并不继承Iterable接口, 增强for可以遍历Set</span></div><div class="line"><span class="comment">//增强for</span></div><div class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; entry : set2)&#123; <span class="comment">//set2可以直接写成map.entrySet()</span></div><div class="line">	Integer key = entry.getKey();</div><div class="line">	String value = entry.getValue();</div><div class="line">	System.out.println(key+<span class="string">"..."</span>+value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="HashMap存储和遍历"><a href="#HashMap存储和遍历" class="headerlink" title="HashMap存储和遍历"></a>HashMap存储和遍历</h4><pre><code>* 使用HashMap存储自定义对象
* 自定义类对象可以作为键, 也可以作为值
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 自定义对象 作为键,为了保证键的唯一性,需要重写hashCode()和equals()</div><div class="line"> * 自定义对象 作为值,不需要保证唯一性, 因为值可以重复</div><div class="line"> * Person类中也重写了toString(), 以保证打印出来的是对象的内容, 而不是地址</div><div class="line"> */</div><div class="line">HashMap&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;Person,String&gt;();</div><div class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">11</span>) , <span class="string">"山东"</span>);</div><div class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">11</span>) , <span class="string">"山东"</span>);</div><div class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"张三3"</span>, <span class="number">11</span>) , <span class="string">"北京"</span>);</div><div class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"张三4"</span>, <span class="number">11</span>) , <span class="string">"上海"</span>);</div><div class="line"><span class="comment">//keySet()   增强for</span></div><div class="line"><span class="keyword">for</span>(Person key : map.keySet())&#123;</div><div class="line">	String value = map.get(key);</div><div class="line">	System.out.println(key+<span class="string">"..."</span>+value);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"-------分割线----------"</span>);</div><div class="line"><span class="comment">//entrySet()  增强for</span></div><div class="line"><span class="keyword">for</span>(Map.Entry&lt;Person, String&gt; entry : map.entrySet())&#123;</div><div class="line">	Person key = entry.getKey();</div><div class="line">	String value = entry.getValue();</div><div class="line">	System.out.println(key+<span class="string">"..."</span>+value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><pre><code>* 继承自HashMap
* 保证了迭代的顺序, 存取有序
* 都属于线程不安全集合
</code></pre><h4 id="Hashtable的特点"><a href="#Hashtable的特点" class="headerlink" title="Hashtable的特点"></a>Hashtable的特点</h4><pre><code>* Map接口的实现类
* 底层数据结构也是哈希表, 特点和HashMap一样
* JDk1.2后, 被HashMap取代
* HashMap和Hashtable的区别:
    * 共同点: 
        1. 底层都是哈希算法
        2. 都是双列集合
    * 区别一: 
        1. HashMap   JDk1.2出现, 线程不安全集合, 效率较高
        2. Hashtable JDk1.0出现, 线程安全集合,   效率较低 
    * 区别二: 
        1. HashMap 允许存储null键,null值
        2. Hashtable 不允许存储null键,null值
* Hashtable的子类 Properties, 用于IO流
</code></pre><h4 id="静态导入-了解"><a href="#静态导入-了解" class="headerlink" title="静态导入(了解)"></a>静态导入(了解)</h4><pre><code>* JDk1.5新特性
* 作用:　减少开发的代码量
* 实际用处一般
* 如import static java.lang.System.out;
</code></pre><h4 id="方法的可变参数"><a href="#方法的可变参数" class="headerlink" title="方法的可变参数"></a>方法的可变参数</h4><pre><code>*　JDK1.5新特性
*　前提: 方法参数数据类型确定, 参数个数任意
*　参数列表格式:  (数据类型...变量名)
*　可变参数的本质: 数组
*　一个参数不传, 打印变量名,得到是地址值
* 注意事项: 
    1. 如果要传递多个参数,需要把可变参数放在最后
    2. 一个方法里,只能有一个可变参数, 数据类型不同也不行
如: public static int getSum(int b, int...a){ }　，写成(int...a,int b)就接收不到b
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算多个数的和</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>...a)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : a)&#123;</div><div class="line">		sum += i;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h4><pre><code>* 由静态方法组成
</code></pre><h5 id="常用方法-静态"><a href="#常用方法-静态" class="headerlink" title="常用方法(静态)"></a>常用方法(静态)</h5><pre><code>1. sort(List&lt;&gt; list) : 对于List集合,进行升序排列
2. T binarySearch(List&lt;T&gt; list, Tkey) : 对应List集合进行二分查找, 传递List集合和被查找到元素
   找不到返回 (-插入点-1)
3. shuffle(List&lt;&gt; list) : 对List集合中的元素, 进行随机排列
</code></pre><h4 id="Map集合的嵌套"><a href="#Map集合的嵌套" class="headerlink" title="Map集合的嵌套"></a>Map集合的嵌套</h4><pre><code>* Map里面嵌套Map
</code></pre><h5 id="方式一-keySet"><a href="#方式一-keySet" class="headerlink" title="方式一: keySet()"></a>方式一: keySet()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建班级集合, 键是学号 , 值是姓名</span></div><div class="line">HashMap&lt;String, String&gt; javase = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">HashMap&lt;String, String&gt;	javaee = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line"></div><div class="line"><span class="comment">//向javase班添加学生信息</span></div><div class="line">javase.put(<span class="string">"001"</span>, <span class="string">"张三"</span>);</div><div class="line">javase.put(<span class="string">"002"</span>, <span class="string">"李四"</span>);</div><div class="line"></div><div class="line"><span class="comment">//向javaee班添加学生信息</span></div><div class="line">javaee.put(<span class="string">"001"</span>, <span class="string">"王五"</span>);</div><div class="line">javaee.put(<span class="string">"002"</span>, <span class="string">"赵六"</span>);</div><div class="line"></div><div class="line"><span class="comment">//创建传智播客集合, 键是班级名, 值是班级</span></div><div class="line">HashMap&lt;String, HashMap&lt;String, String&gt;&gt; czbk = <span class="keyword">new</span> HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">//向传智播客添加班级信息</span></div><div class="line">czbk.put(<span class="string">"基础班"</span>, javase);</div><div class="line">czbk.put(<span class="string">"就业班"</span>, javaee);</div><div class="line"><span class="comment">/*</span></div><div class="line"> * KeySet()</div><div class="line"> */</div><div class="line"><span class="comment">//增强for</span></div><div class="line"><span class="keyword">for</span>(String className : czbk.keySet())&#123;</div><div class="line">	HashMap&lt;String, String&gt; classMap = czbk.get(className);</div><div class="line">	<span class="keyword">for</span>(String id : classMap.keySet())&#123;</div><div class="line">		String name = classMap.get(id);</div><div class="line">		System.out.println(className+ <span class="string">"..."</span> + id+<span class="string">"..."</span>+name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"-----------分割线-----------"</span>);</div><div class="line"><span class="comment">//迭代器</span></div><div class="line"><span class="comment">//1.通过czbk的KeySet(), 把所有键即班级名存入classNameSet集合</span></div><div class="line">Set&lt;String&gt; classNameSet = czbk.keySet();</div><div class="line"><span class="comment">//2.遍历Set集合: 通过Set集合classNameSet,获取一个迭代器</span></div><div class="line">Iterator&lt;String&gt; classit = classNameSet.iterator();</div><div class="line"><span class="comment">//迭代器中是czbk集合的所有键</span></div><div class="line"><span class="keyword">while</span>(classit.hasNext())&#123;</div><div class="line">	<span class="comment">//classit.next()中就是班级名键</span></div><div class="line">	String classNameKey = classit.next();</div><div class="line">	<span class="comment">//3.通过czbk的get方法, 获取czbk集合的值, 即班级集合</span></div><div class="line">	HashMap&lt;String,String&gt; classMap = czbk.get(classNameKey);</div><div class="line">	<span class="comment">//4.通过班级集合classMap的keySet(),把所有键即学生ID存入stuSet集合</span></div><div class="line">	Set&lt;String&gt; stuSet = classMap.keySet();</div><div class="line">	<span class="comment">//5.遍历Set集合: stuSet集合调用iterator(),获取一个迭代器</span></div><div class="line">	Iterator&lt;String&gt; stuit = stuSet.iterator();</div><div class="line">	<span class="comment">//迭代器中存的是班级集合中的键,即学生id</span></div><div class="line">	<span class="keyword">while</span>(stuit.hasNext())&#123;</div><div class="line">		String stuIdKey = stuit.next();</div><div class="line">		<span class="comment">//6.通过班级集合的get方法, 获取班级集合classMap的值, 即学生名</span></div><div class="line">		String stuName = classMap.get(stuIdKey);</div><div class="line">		<span class="comment">//7.打印</span></div><div class="line">		System.out.println(classNameKey+<span class="string">".."</span>+stuIdKey+<span class="string">".."</span>+stuName);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="方式二-entrySet"><a href="#方式二-entrySet" class="headerlink" title="方式二: entrySet()"></a>方式二: entrySet()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * entrySet()</div><div class="line"> */</div><div class="line"><span class="comment">//增强for</span></div><div class="line"><span class="keyword">for</span>(Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt; classEntry : czbk.entrySet())&#123;</div><div class="line">	String className = classEntry.getKey();</div><div class="line">	HashMap&lt;String, String&gt; classMap = classEntry.getValue();</div><div class="line">	<span class="keyword">for</span>(Map.Entry&lt;String, String&gt; stuEntry : classMap.entrySet())&#123;</div><div class="line">		String id = stuEntry.getKey();</div><div class="line">		String name = stuEntry.getValue();</div><div class="line">		System.out.println(className+<span class="string">"..."</span>+id+<span class="string">"..."</span>+name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"-----------分割线-----------"</span>);</div><div class="line"><span class="comment">//迭代器</span></div><div class="line">Set&lt;Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt;&gt; classEntry = czbk.entrySet();</div><div class="line">Iterator&lt;Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt;&gt; classIt = classEntry.iterator();</div><div class="line"><span class="keyword">while</span>(classIt.hasNext())&#123;</div><div class="line">	Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt; classMap =  classIt.next();</div><div class="line">	String className = classMap.getKey();</div><div class="line">	HashMap&lt;String, String&gt; stuMap = classMap.getValue();</div><div class="line">	Set&lt;Map.Entry&lt;String, String&gt;&gt; stuEntry = stuMap.entrySet();</div><div class="line">	Iterator&lt;Map.Entry&lt;String, String&gt;&gt; stuIt = stuEntry.iterator();</div><div class="line">	<span class="keyword">while</span>(stuIt.hasNext())&#123;</div><div class="line">		Map.Entry&lt;String, String&gt; stu = stuIt.next();</div><div class="line">		String id = stu.getKey();</div><div class="line">		String name = stu.getValue();</div><div class="line">		System.out.println(className+<span class="string">"..."</span>+id+<span class="string">"..."</span>+name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[09.自定义类]]></title>
      <url>https://geekhoon.github.io/2017/01/15/09-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><pre><code>* 分两种,一种是JAVA提供的,一种是自定义类
* 类是用于描述事物的.
* 事物的特征叫属性
* 事物的功能叫方法
</code></pre><a id="more"></a> 
<h3 id="自定义类的格式"><a href="#自定义类的格式" class="headerlink" title="自定义类的格式"></a>自定义类的格式</h3><pre><code>* 使用类的形式,对现实中的事物进行描述。 

* 格式
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</div><div class="line">	属性定义(成员变量)</div><div class="line">	  修饰符 数据类型 变量名 = 值</div><div class="line">	</div><div class="line">	方法定义(成员方法)</div><div class="line">	  修饰符 返回值类型  方法名(参数列表)&#123;</div><div class="line">		  </div><div class="line">	  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义类的内存图"><a href="#自定义类的内存图" class="headerlink" title="自定义类的内存图"></a>自定义类的内存图</h3><p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170115/200111098.png" alt=""></p>
<p>注意一点: new一个对象后,类中的成员变量,一并进入堆内存,并被赋予默认值<br>new出来对象的属性,存在堆里面<br>根据内存图,可知,即使没被赋值,打印 类名.属性 ,也会有默认值</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[08.方法]]></title>
      <url>https://geekhoon.github.io/2017/01/13/08-%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="方法的概述"><a href="#方法的概述" class="headerlink" title="方法的概述"></a>方法的概述</h3><pre><code>* 提高代码的复用性  
* 完成特定功能的代码块。
</code></pre><a id="more"></a> 
<h3 id="方法的定义格式"><a href="#方法的定义格式" class="headerlink" title="方法的定义格式"></a>方法的定义格式</h3><pre><code>* 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {
        方法体语句;
        return 返回值; 
  } 
* 方法的格式说明
    * 参数：
        * 实际参数：就是实际参与运算的,调用方法时传递
        * 形式参数；就是方法定义上的，用于接收实际参数
    * return：
        * 将返回值返回给调用者
        * 结束方法
* 两个明确：
    返回值类型：结果的数据类型
    参数列表：参数的个数及对应的数据类型    
</code></pre><h3 id="调用方法执行流程"><a href="#调用方法执行流程" class="headerlink" title="调用方法执行流程"></a>调用方法执行流程</h3><pre><code>* 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。
* 方法的执行，是把实参传递给形参，从而来执行的。
* 方法只有被调用才会执行。
</code></pre><p>方法调用的内存图:</p>
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170113/200111183.bmp" alt=""></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><pre><code>* 方法不调用不执行
* 方法之间是平级关系，不能嵌套定义
* 方法返回值是void,方法中可以省略return 不写
       return 下面不能有代码
* 如果方法有明确的返回值类型，就必须有return语句返回。
* 方法在调用的时候，不用再传递数据类型
* 调用方法的时候,返回值是void, 不能写在输出语句中
* 不能重复定义(指的是方法名,参数列表都相同的不能在同一类中定义)
</code></pre><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><pre><code>* 在同一个类中，方法名相同，参数列表不同。    
* 参数列表不同：
    * 个数不同
    * 类型不同
    * 顺序不同(算重载)
</code></pre><h3 id="方法重载注意事项"><a href="#方法重载注意事项" class="headerlink" title="方法重载注意事项"></a>方法重载注意事项</h3><pre><code>* 参数列表必须不同
* 重载和参数变量名无关
* 重载和返回值类型无关
* 重载和修饰符无关

* 技巧: 重载看方法名和参数列表
</code></pre><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><pre><code>* 方法参数是基本数据类型时，传递的是值。
* 方法参数是引用数据类型时，传递的是内存地址值。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[07.数组]]></title>
      <url>https://geekhoon.github.io/2017/01/11/07-%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1. 数组概述"></a>1. 数组概述</h4><pre><code>* 存储同一种数据类型的多个元素的容器。
* 特点:
    (1)元素数据类型必须一致。
    (2)长度固定
</code></pre><a id="more"></a>
<h4 id="2-数组的定义"><a href="#2-数组的定义" class="headerlink" title="2. 数组的定义"></a>2. 数组的定义</h4><pre><code>* 格式:
    数据类型[] 数组名 = new 数据类型[元素个数或数组长度];
    数据类型 数组名[]  = new 数据类型[元素个数或数组长度];//也对
    * 举例:
        int[] x = new int[100];
* 索引(index)      
    每个元素都有自己的自动编号,叫作索引(index), 下标, 角标
    数组的最小索引是0, 最大索引数组.length-1
* 初始化默认值
    byte,short,int,long 0
    float,double        0.0
    char                &apos;\u0000&apos;
    boolean             false
    引用类型             null
</code></pre><h4 id="3-数组初始化"><a href="#3-数组初始化" class="headerlink" title="3. 数组初始化"></a>3. 数组初始化</h4><pre><code>* 动态初始化 : 只给长度，系统给出默认值
        类型[] 数组名 = new 类型[长度];
        int[] arr = new int[4];
* 静态初始化 : 给出值，系统决定长度
        (1) 类型[] 数组名 = new 类型[]{元素1，元素2，……};
        int[] arr = new int[]{1,2,3,4};
        //new int[],这个中括号中不能有任何内容,不要指明数组长度
        可以改写成:
            数组的声明: int[] arr;
            数组的赋值: arr = new int[]{1,2,3,4};
        (2) 类型[] 数组名 = {元素1，元素2，元素3，……};     
        int[] arr = { 1, 2, 3, 4 };
        //这种形式不能改成声明+赋值分开写的形式
</code></pre><h4 id="4-JVM内存划分"><a href="#4-JVM内存划分" class="headerlink" title="4. JVM内存划分"></a>4. JVM内存划分</h4><pre><code>* JVM对自己的内存划分为5个区域
      * 寄存器:内存和CPU之间
      * 本地方法区: JVM调用了系统中的功能
      * 方法区(方法和数据共享区): 运行时期class文件进入的地方
      * 方法栈:所有的方法运行的时候进入内存,进入的就是栈内存
          * main方法,压栈运行,第一个进栈,在栈最底部,最后释放
          * 存储局部变量
      * 堆内存:存储的是容器和对象,存储所有new出来的

    注意：
        a:局部变量 在方法定义中或者方法声明上定义的变量。
        b:栈内存和堆内存的区别
            栈：数据使用完毕，就消失。
            堆：每一个new出来的东西都有地址
        数据使用完毕后，在垃圾回收器空闲的时候回收。
</code></pre><h4 id="5-数组的内存"><a href="#5-数组的内存" class="headerlink" title="5. 数组的内存"></a>5. 数组的内存</h4><pre><code>*   int[] x;                // 声明一个int[]类型的变量
*    x = new int[100];        // 创建一个长度为100的数组
*    arr引用类型,保存的不是数据,是内存的地址,通常是十六进制保存.每次分配的内存地址不一定一样
    *    [:一维数组
    *    I:数据类型 int
    *    @:分隔符
    *    60e218:十六进制地址
</code></pre><p>数组在创建过程中内存的分配情况:</p>
<p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170112/081737153.bmp" alt=""></p>
<pre><code>1.程序运行时,.class文件进入方法区  
2.找到程序入口main方法,进入方法栈,main方法压栈运行
3.执行int[] arr = new int[3];在堆内存中,开辟一段连续空间,长度为3.
4.arr中保存开辟空间的首地址
</code></pre><h4 id="6-遍历数组"><a href="#6-遍历数组" class="headerlink" title="6. 遍历数组"></a>6. 遍历数组</h4><pre><code>* 依次访问数组中的每个元素
* 举例
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo04</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// 定义数组</span></div><div class="line">		<span class="comment">// 使用for循环遍历数组的元素</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">			System.out.println(arr[i]); <span class="comment">// 通过索引访问元素</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-逆序-反转"><a href="#7-逆序-反转" class="headerlink" title="7. 逆序(反转)"></a>7. 逆序(反转)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">方式<span class="number">1</span>：</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;arr.length/<span class="number">2</span>; x++) &#123;</div><div class="line">			<span class="keyword">int</span> temp = arr[x];</div><div class="line">			arr[x] = arr[arr.length-<span class="number">1</span>-x];</div><div class="line">			arr[arr.length-<span class="number">1</span>-x] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">方式<span class="number">2</span>：</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>,end=arr.length-<span class="number">1</span>; start&lt;=end; start++,end--) &#123;</div><div class="line">			<span class="keyword">int</span> temp = arr[start];</div><div class="line">			arr[start] = arr[end];</div><div class="line">			arr[end] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="8-数组中常见的异常"><a href="#8-数组中常见的异常" class="headerlink" title="8. 数组中常见的异常"></a>8. 数组中常见的异常</h4><pre><code>* 数组操作中,常见的两个异常
     数组的索引越界异常(ArrayIndexOutOfBoundsException)
      空指针异常(NullPointerException)

* 练习
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo_4</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//(1)数组的索引越界异常: 访问了数组中不存在的元素</span></div><div class="line">		<span class="comment">//int[] arr = &#123;5,2,1&#125;;</span></div><div class="line">		<span class="comment">//数组中3个元素,索引 0,1,2</span></div><div class="line">		<span class="comment">//System.out.println(arr[3]);</span></div><div class="line">		<span class="comment">//编译不报错,运行出错</span></div><div class="line">		<span class="comment">//java.lang.ArrayIndexOutOfBoundsException: 3</span></div><div class="line">		</div><div class="line">	<span class="comment">//(2)空指针异常</span></div><div class="line">		<span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</div><div class="line">		System.out.println(arr2[<span class="number">2</span>]);</div><div class="line">		arr2 = <span class="keyword">null</span>; <span class="comment">// arr2 不在保存数组的地址了</span></div><div class="line">		System.out.println(arr2[<span class="number">2</span>]);</div><div class="line">		<span class="comment">//编译不报错,运行出错</span></div><div class="line">		<span class="comment">//java.lang.NullPointerException</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="9-数组获取最值代码实现"><a href="#9-数组获取最值代码实现" class="headerlink" title="9. 数组获取最值代码实现"></a>9. 数组获取最值代码实现</h4><pre><code>* 数组获取最值的原理思想
    * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素
    * 为什么选择数组中的一个元素作为最大值,因为如果自己定义的一个数据比数组所有数据都大,那比较完,得不出数组最大值
* 代码实现
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo05</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] arr = &#123; <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span> &#125;; 	<span class="comment">// 定义一个数组</span></div><div class="line">		<span class="keyword">int</span> max = arr[<span class="number">0</span>]; 					<span class="comment">// 定义变量max用于记住最大数，首先假设第一个元素为最大值</span></div><div class="line">		<span class="comment">// 下面通过一个for循环遍历数组中的元素</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; arr.length; x++) &#123;</div><div class="line">			<span class="keyword">if</span> (arr[x] &gt; max) &#123; 			<span class="comment">// 比较 arr[x]的值是否大于max</span></div><div class="line">				max = arr[x]; 				<span class="comment">// 条件成立，将arr[x]的值赋给max</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"max="</span> + max); 	<span class="comment">// 打印最大值</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="1-二维数组的定义"><a href="#1-二维数组的定义" class="headerlink" title="1. 二维数组的定义"></a>1. 二维数组的定义</h4><pre><code>* 作用
    * 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？
    * 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。
* 格式
    * 第一种定义格式:
        *  int[][] arr = new int[3][4];
        *  上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组
    * 第二种定义格式
        *  int[][] arr = new int[3][];
        *  第二种方式和第一种类似，只是一维数组中每个元素的长度不确定
    * 第三种定义格式
        *      int[][] arr = {{1,2},{3,4,5,6},{7,8,9}};
        *      每个一维数组用大括号,不是小括号,别忽视了
        *      二维数组中定义了三个元素，这三个元素都是数组，分别为{1,2}、{3,4,5,6}、{7,8,9}
</code></pre><h4 id="2-二维数组元素的访问"><a href="#2-二维数组元素的访问" class="headerlink" title="2. 二维数组元素的访问"></a>2. 二维数组元素的访问</h4><pre><code>* 案例:
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo08</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	</div><div class="line">		<span class="comment">//定义二维数组的方式</span></div><div class="line">		<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>];</div><div class="line">		System.out.println( arr );</div><div class="line">		System.out.println(<span class="string">"二维数组的长度: "</span> + arr.length);</div><div class="line">		<span class="comment">//获取二维数组的3个元素</span></div><div class="line">		System.out.println( arr[<span class="number">0</span>] );</div><div class="line">		System.out.println( arr[<span class="number">1</span>] );</div><div class="line">		System.out.println( arr[<span class="number">2</span>] );</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"打印第一个一维数组的元素值"</span>);</div><div class="line">		System.out.println( arr[<span class="number">0</span>][<span class="number">0</span>] );</div><div class="line">		System.out.println( arr[<span class="number">0</span>][<span class="number">1</span>] );<span class="comment">//访问的为二维数组中第1个一维数组的第2个元素</span></div><div class="line">		System.out.println( arr[<span class="number">0</span>][<span class="number">2</span>] );</div><div class="line">		System.out.println( arr[<span class="number">0</span>][<span class="number">3</span>] );</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"打印第二个一维数组的元素值"</span>);</div><div class="line">		System.out.println( arr[<span class="number">1</span>][<span class="number">0</span>] );</div><div class="line">		System.out.println( arr[<span class="number">1</span>][<span class="number">1</span>] );</div><div class="line">		System.out.println( arr[<span class="number">1</span>][<span class="number">2</span>] );</div><div class="line">		System.out.println( arr[<span class="number">1</span>][<span class="number">3</span>] );</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"打印第三个一维数组的元素值"</span>);</div><div class="line">		System.out.println( arr[<span class="number">2</span>][<span class="number">0</span>] );</div><div class="line">		System.out.println( arr[<span class="number">2</span>][<span class="number">1</span>] );</div><div class="line">		System.out.println( arr[<span class="number">2</span>][<span class="number">2</span>] );</div><div class="line">		System.out.println( arr[<span class="number">2</span>][<span class="number">3</span>] );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-二维数组内存图"><a href="#3-二维数组内存图" class="headerlink" title="3. 二维数组内存图"></a>3. 二维数组内存图</h4><pre><code>* 举例:int[][] arr = new int[3][2];
* 外层数组在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值
* 每一个大内存空间里又开辟连续的两个小的内存空间.
</code></pre><p><img src="http://oj3s07yy0.bkt.clouddn.com/blog/20170112/095418411.png" alt=""></p>
<h4 id="4-二维数组的定义和访问"><a href="#4-二维数组的定义和访问" class="headerlink" title="4. 二维数组的定义和访问"></a>4. 二维数组的定义和访问</h4><pre><code>* 定义
    * 格式1: 
      int[][] arr = new int[3][]; 不推荐
    * 格式2
      int[][] arr = {{1,2,4},{4,7},{0,9,3}};       
* 访问
      举例:int[][] arr = {{1,2,4},{5,8,7},{0,9,3}};  
     想要打印数组中7这个元素需要先找到大的元素索引{5,8,7} 索引为1 ,在找7在{5,8,7}中的索引2
     那么结果为 arr[1][2]  [1]代表大数组中{5,8,7}这个元素索引,[2]代表{5,8,7}中7元素的索引
</code></pre><h4 id="5-二维数组的遍历"><a href="#5-二维数组的遍历" class="headerlink" title="5. 二维数组的遍历"></a>5. 二维数组的遍历</h4><pre><code>* 二维数组遍历
   int[][] arr = {{1,2,4},{4,7},{0,9,3}};
     先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组
   在外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素

*    举例
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayArrayDemo_2</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span>[][] arr = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">0</span>&#125; &#125;;</div><div class="line">		</div><div class="line">		<span class="comment">//外循环,遍历二维数组</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ;i++)&#123;</div><div class="line">			<span class="comment">//内循环,遍历每个一维数组 arr[0] arr[1] arr[i]</span></div><div class="line">			<span class="comment">//注意内层for的条件是,j&lt; 每个一维数组的长度</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; arr[i].length; j++)&#123;</div><div class="line">				System.out.print(arr[i][j]);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>* 累加求和
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo09</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	  	<span class="keyword">int</span>[][] arr2 = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125; &#125;;</div><div class="line">		<span class="keyword">int</span> sum2 = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr2.length; i++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr2[i].length; j++) &#123;</div><div class="line">                 <span class="comment">//System.out.println(arr2[i][j])</span></div><div class="line">				sum2 += arr2[i][j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"sum2= "</span>+ sum2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-二维数组的求和练习"><a href="#6-二维数组的求和练习" class="headerlink" title="6. 二维数组的求和练习"></a>6. 二维数组的求和练习</h4><pre><code>* 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示
   * 第一小组销售额为{11, 12}万元
   * 第二小组销售额为{21, 22, 23}万元
   * 第三小组销售额为{31, 32, 33, 34}万元。

* 代码实现
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo10</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][]; 			<span class="comment">// 定义一个长度为3的二维数组</span></div><div class="line">		arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">11</span>, <span class="number">12</span> &#125;; 			<span class="comment">// 为数组的元素赋值</span></div><div class="line">		arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span> &#125;;</div><div class="line">		arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span> &#125;;		</div><div class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>; 							<span class="comment">// 定义变量记录总销售额</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 遍历数组元素</span></div><div class="line">			<span class="keyword">int</span> groupSum = <span class="number">0</span>; <span class="comment">// 定义变量记录小组销售总额</span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123; <span class="comment">// 遍历小组内每个人的销售额</span></div><div class="line">				groupSum = groupSum + arr[i][j];</div><div class="line">			&#125;</div><div class="line">			sum = sum + groupSum; 			<span class="comment">// 累加小组销售额</span></div><div class="line">			System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"小组销售额为："</span> + groupSum + <span class="string">" 万元"</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"总销售额为: "</span> + sum + <span class="string">" 万元"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[06.流程控制语句]]></title>
      <url>https://geekhoon.github.io/2017/01/10/06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h3 id="选择结构if"><a href="#选择结构if" class="headerlink" title="选择结构if"></a>选择结构if</h3><h4 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1. if语句"></a>1. if语句</h4><pre><code>* 书写格式
    if(比较表达式) {
        语句体;
    }
</code></pre><a id="more"></a>
<pre><code>* 执行流程
    * 先计算比较表达式的值，看其返回值是true还是false。
    * 如果是true，就执行语句体；
    * 如果是false，就不执行语句体；
* 注意:如果写成这样:
    if(比较表达式); {
        语句体;
    }
    加上分号&quot;;&quot; ,则代表if语句已经结束,大括号内的内容不管if的比较表达式true或false都会执行
</code></pre><h4 id="2-if…else语句"><a href="#2-if…else语句" class="headerlink" title="2. if…else语句"></a>2. if…else语句</h4><pre><code>* 书写格式
    if(比较表达式) {
        语句体1;
    }else {
        语句体2;
    }
* 执行流程
    * 首先计算比较表达式的值，看其返回值是true还是false。
    * 如果是true，就执行语句体1；
    * 如果是false，就执行语句体2；
</code></pre><h4 id="3-if…else-if…else语句"><a href="#3-if…else-if…else语句" class="headerlink" title="3. if…else if…else语句"></a>3. if…else if…else语句</h4><pre><code>* 适合在程序中,实现多条件的判断
* 书写格式 
    if(比较表达式1) {
        语句体1;
    }else if(比较表达式2) {
        语句体2;
    }else if(比较表达式3) {
        语句体3;
    }
    ...
    else {
        语句体n+1;
    }
* 执行流程
    * 首先计算比较表达式1看其返回值是true还是false，
    * 如果是true，就执行语句体1，if语句结束。
    * 如果是false，接着计算比较表达式2看其返回值是true还是false，
    * 如果是true，就执行语句体2，if语句结束。
    * 如果是false，接着计算比较表达式3看其返回值是true还是false，
    * 如果都是false，就执行语句体n+1。
* 案例代码
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElseIfDemo</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="comment">//成绩判断要求 ,成绩&gt;80  成绩&gt;70  成绩&gt;60  不及格</span></div><div class="line">		<span class="comment">//定义变量,保存成绩</span></div><div class="line">		<span class="keyword">int</span> grade = <span class="number">75</span>;</div><div class="line">		<span class="comment">//使用if else if 语句对成绩判断</span></div><div class="line">		<span class="keyword">if</span>( grade &gt; <span class="number">80</span> )&#123;</div><div class="line">			System.out.println(grade+<span class="string">" 成绩是优"</span>);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> ( grade &gt; <span class="number">70</span>)&#123;</div><div class="line">			System.out.println(grade+<span class="string">" 成绩是良"</span>);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> ( grade &gt; <span class="number">60</span>)&#123;</div><div class="line">			System.out.println(grade+<span class="string">" 成绩是中"</span>);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			System.out.println(grade+<span class="string">" 成绩是差"</span>);</div><div class="line">		&#125;</div><div class="line">	 	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>* 注意: 只要有1个if的条件是true,其他的代码,不再执行
</code></pre><h4 id="4-if语句和三元运算符的互换"><a href="#4-if语句和三元运算符的互换" class="headerlink" title="4. if语句和三元运算符的互换"></a>4. if语句和三元运算符的互换</h4><pre><code>* 使用if语句还是三元表达式
    * 判断条件多,使用if
     * 三元,必须有结果的, if 可以没有结果的
* 三元运算符可以转换为if,但if不一定能转换为三元
* 案例代码
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElseDemo_1</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">15</span>;</div><div class="line">		<span class="keyword">int</span> j = <span class="number">6</span>;</div><div class="line">		<span class="comment">//使用if语句,判断出最大值</span></div><div class="line">		<span class="keyword">if</span>(i&gt;j)&#123;</div><div class="line">			System.out.println(i+<span class="string">" 是最大值"</span>);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			System.out.println(j+<span class="string">" 是最大值"</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//使用三元运算实现</span></div><div class="line">		<span class="keyword">int</span> k = i&gt;j ? i : j;</div><div class="line">		System.out.println(k+<span class="string">" 是最大值"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1. while循环"></a>1. while循环</h4><pre><code>* 使用格式
     初始化表达式；
     while(条件){
        循环体
     }
* 执行顺序     
    当条件是true,就执行循环体,执行完循环体后
    程序再次执行while中的条件,如果条件还是true,继续执行循环体
    直到条件是false的时候,循环就结束        
</code></pre><h4 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h4><pre><code>* 使用格式
    for(初始化表达式 ; 条件表达式 ; 循环后操作表达式){
            循环体;
    }

* 执行流程
    for（① ; ② ; ③）{
        ④
    }
    第一步，执行①,①终身只执行一次
    第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步
    第三步，执行④
    第四步，执行③，然后重复执行第二步
    第五步，退出循环

* for与while循环:
    1.for与while循环可以相互转换,但不建议转换
    2.for循环中的初始化表达式中变量的作用范围只在for语句中有效
    3.while初始化表达式是在while循环上边定义,作用范围大
</code></pre><h4 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3. do_while循环"></a>3. do_while循环</h4><pre><code>* 使用格式
    do{
         循环体;
      }while(条件);//别丢了这个分号
* 执行顺序
    先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体，
    如果条件为false，循环结束。
* 特点
    无条件先执行一次
</code></pre><h4 id="4-死循环"><a href="#4-死循环" class="headerlink" title="4. 死循环"></a>4. 死循环</h4><pre><code>* 概述
    * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环
* 格式
    * while(true){}
    * for(;;){}
    * for(;true;){}
* 注意:无限循环语句后面不允许再写代码,会编译失败.
    * 但不是没有机会执行,当程序满足一定条件(break),可以控制,让死循环停止,执行后面的代码
</code></pre><h4 id="5-嵌套for循环"><a href="#5-嵌套for循环" class="headerlink" title="5. 嵌套for循环"></a>5. 嵌套for循环</h4><pre><code>* 概述
    * 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。
    * while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套
* 嵌套循环的格式
    for(初始化表达式; 循环条件; 操作表达式) {
        ………
        for(初始化表达式; 循环条件; 操作表达式) {
            执行语句
            ………
        }
        ………
    }
* 执行顺序:
      1.外循环执行一次,
      2.内循环全部执行完,
      3.回到外循环,外循环继续执行一次
      4.内循环再全部执行完
      5.再回到外循环,重复1到5,直到外循环结束
* 各模块解释
    * 总的循环次数 =  内循环次数 * 外循环的次数
    * 内循环,是外循环的循环体

    * 外循环,控制的是行数
    * 内循环,控制的是每行的个数

* 案例
    *  打印正三角形
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForForDemo</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span> ; i++)&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i+<span class="number">1</span> ;j++)&#123;  <span class="comment">//++i</span></div><div class="line">				System.out.print(<span class="string">"* "</span>);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-break语句"><a href="#6-break语句" class="headerlink" title="6. break语句"></a>6. break语句</h4><pre><code>* 作用
    * 跳出当前所在的循环体
* 应用环境
    * 只能应用在循环语句和switch语句中
 * 注意
* 如果写在循环嵌套的内循环,结束的是内循环.除非在外循环前面加上循环标号,然后break 循环标号;
* 举例
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(i&gt;<span class="number">5</span>) &#123;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	System.out.println(“我爱Java”+i);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//会从0-5输出6次“我爱Java”</span></div></pre></td></tr></table></figure>
<pre><code>* break详细解释
    * a: 作用
    * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中，
        可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码，
        这些关键字一旦出现就可以跳转语句执行顺序。
    * b: 使用方式
        * 无法单独使用，必须将break关键字置于switch或循环语句中
    * c: 运行规律
        * 不需要判断任何条件，只要遇到break便直接跳出执行后续代码。会完全跳出选择或者循环结构
        * 只能跳出最近的代码块，不能跨越多级代码块

* 循环标号
    * a: 为什么使用循环标号
    * 当在双层循环或者循环内有switch选择语句时，我们发现
    使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了.
    * b: 使用方式
        * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。
          使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可
    * c: 运行规律
        * 当外层循环外定义了标号
          内层使用break，终止内外双层循环。
          内层使用continue，终止内层循环，继续外层循环。
</code></pre><h4 id="7-continue语句"><a href="#7-continue语句" class="headerlink" title="7. continue语句"></a>7. continue语句</h4><pre><code>* 作用
    * 提前结束本次循环，继续进行下次循环
* 应用环境
    * 无法单独使用，只能应用于循环中
* 运行规律
    * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环
* 案例代码
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinueDemo</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			System.out.println(i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//会把0-9之间所有的奇数打印到控制台上</span></div></pre></td></tr></table></figure>
<h4 id="8-switch语句"><a href="#8-switch语句" class="headerlink" title="8. switch语句"></a>8. switch语句</h4><pre><code>* switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。    
* 格式:
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">swtich(表达式)&#123;</div><div class="line"> <span class="keyword">case</span> 常量<span class="number">1</span> :</div><div class="line">   要执行的语句;</div><div class="line"> <span class="keyword">break</span>;</div><div class="line"> </div><div class="line"> <span class="keyword">case</span> 常量<span class="number">2</span> :</div><div class="line">   要执行的语句;</div><div class="line"> <span class="keyword">break</span>;</div><div class="line"> </div><div class="line"> <span class="keyword">case</span> 常量<span class="number">3</span> :</div><div class="line">   要执行的语句;</div><div class="line"> <span class="keyword">break</span>;</div><div class="line"> </div><div class="line"> <span class="keyword">default</span>:</div><div class="line">   要执行的语句;</div><div class="line"> <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>* 执行流程: 
   表达式和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,
   遇到break,就全结束.若都不匹配,执行default 
* 关键字: switch case default break
* 特别注意:
    1. case后,必须是常量
    2. 常量后,有冒号
    3. 要执行的语句可以是多条语句,包括循环都可以写
</code></pre><h4 id="9-switch语句接收的数据类型"><a href="#9-switch语句接收的数据类型" class="headerlink" title="9. switch语句接收的数据类型"></a>9. switch语句接收的数据类型</h4><pre><code>* switch语句中的表达式的数据类型,是有要求的

        JDK1.0 - 1.4  数据类型接受 byte short int char
        JDK1.5   数据类型接受 byte short int char enum(枚举)
        JDK1.7   数据类型接受 byte short int char enum(枚举), String    
</code></pre><h4 id="10-case穿透"><a href="#10-case穿透" class="headerlink" title="10. case穿透"></a>10. case穿透</h4><pre><code>* case穿透
    * 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，只需写一次。
* 举例:
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> week = <span class="number">2</span>;</div><div class="line">		<span class="keyword">switch</span>(week)&#123;</div><div class="line">			<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">			<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">			<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">			<span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">			<span class="keyword">case</span> <span class="number">5</span>:</div><div class="line">				System.out.println(<span class="string">"工作日"</span>);</div><div class="line">			<span class="keyword">break</span>; <span class="comment">//(1)</span></div><div class="line">			<span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">			<span class="keyword">case</span> <span class="number">7</span>:</div><div class="line">				System.out.println(<span class="string">"休息日"</span>);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//因为week=2,从case 2开始穿透,直到碰到break或switch的右大括号,</span></div><div class="line"><span class="comment">//如果(1)处没有break,继续穿透</span></div><div class="line"><span class="comment">//穿透期间,不会再判断case后面的值,还会执行case中的执行语句,即使default在中间,只要没有break,就继续穿透</span></div><div class="line">	*<span class="keyword">int</span> x = <span class="number">2</span>;</div><div class="line">	 <span class="keyword">int</span> y = <span class="number">3</span>;</div><div class="line">	<span class="keyword">switch</span>(x)&#123;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			y++;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">			y++;</div><div class="line">		<span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">			y++;</div><div class="line">		&#125;</div><div class="line">	System.out.println(<span class="string">"y="</span>+y);</div><div class="line"><span class="comment">//执行顺序: x=2先到case 3,不成立,到case 4,不成立,到了default,执行y++,break结束,输出y=4</span></div><div class="line"><span class="comment">//把default中的break删掉,执行顺序:case 3不成立,case 4不成立,default,执行y++,y=4了,穿透case3,执行y++,又穿透case 4,执行y++</span></div><div class="line"><span class="comment">//最后y=6</span></div></pre></td></tr></table></figure>
<pre><code>* 注意:
    1. default中一定要有break吗?
        //不一定,程序只要遇到break或者switch的右大括号,都结束
    2. 多个case后的常量可否相同?
        //不可以
    3. default一定要放在case之后吗?
        //不一定.不管放在哪,switch执行次序不变,都是从第一个case开始
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[05.引用数据类型]]></title>
      <url>https://geekhoon.github.io/2017/01/10/05-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="创建引用类型变量公式"><a href="#创建引用类型变量公式" class="headerlink" title="创建引用类型变量公式"></a>创建引用类型变量公式</h3><pre><code>* 引用数据类型的定义格式:
    数据类型  变量名  =  new 数据类型();
* 引用数据类型的使用:
    * 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。
    * 变量名.方法名();
</code></pre><a id="more"></a>
<h3 id="Scanner类的使用"><a href="#Scanner类的使用" class="headerlink" title="Scanner类的使用"></a>Scanner类的使用</h3><pre><code>* 作用: 在命令行中,接收键盘的输入
* 使用:
    (1) 导包   import java.util.Scanner;
    (2) 创建Scanner对象的变量 Scanner sc = new Scanner(System.in);
    (3) 读取键盘录入的一个整数
          int enterNumber = sc.nextInt();
    (4) 读取键盘录入的字符串,注意字符串不能有空格或tab
          String enterString = sc.next();
* 案例代码
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//特别注意:后面有分号,别丢掉</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Scanner</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line">	&#123;</div><div class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line"></div><div class="line">		<span class="keyword">int</span> enterNumber = sc.nextInt();</div><div class="line">		System.out.println(<span class="string">"用户输入的整数为"</span>+enterNumber);</div><div class="line"></div><div class="line">		String enterString = sc.next();</div><div class="line">		System.out.println(<span class="string">"用户输入的字符串为"</span>+enterString);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Random随机数类的使用"><a href="#Random随机数类的使用" class="headerlink" title="Random随机数类的使用"></a>Random随机数类的使用</h3><pre><code>* 作用: 生成随机数
* 使用:
    (1) import导包：所属包java.util. Random
    (2) 创建Random对象的变量：Random  random = new Random ();
    (3) 调用方法:
        * nextInt(int maxValue)    产生[0,maxValue)范围的随机数,包含0不包含maxValue
        * nextDouble()  //产生0.0-1.0之间的数(包括0.0不包括1.0)
        如：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Random  random = <span class="keyword">new</span> Random ();</div><div class="line"><span class="keyword">int</span>  myNumber = random.nextInt(<span class="number">100</span>);<span class="comment">//结果为0-99的一个数</span></div></pre></td></tr></table></figure>
<pre><code>* 随机数,也叫伪随机数,它是JVM根据人写好的算法,生成的
* 案例代码
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomDemo</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	   Random ran = <span class="keyword">new</span> Random();</div><div class="line">	   <span class="comment">// Random类中的,产生随机数的功能</span></div><div class="line">	   <span class="keyword">int</span> i = ran.nextInt(<span class="number">100</span>);</div><div class="line">	   System.out.println(i);  </div><div class="line">	   <span class="comment">//问题? 产生随机数,范围 1-100之间</span></div><div class="line">	   <span class="comment">// nextInt(100) 0-99 + 1</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础题目答案]]></title>
      <url>https://geekhoon.github.io/2017/01/09/%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE%E7%AD%94%E6%A1%88/</url>
      <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre><code>1. JAVA语言中的字符char可以存储一个中文汉字吗?原因?
   *可以.因为Java中字符占两个字节.一个中文汉字也占两个字节
   *Java采用的是Unicode编码
</code></pre><a id="more"></a>         
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>1.请写出该输出语句的结果    </p>
<pre><code>* hello98
  * 因为括号的优先级,(&apos;a&apos;+1)中的&quot;+&quot;依然执行加法,所以字符型根据Ascii转成97,第一个&quot;+&quot;为连接
* 若本题改成System.out.println(&quot;hello&quot;+&apos;a&apos;+1);
* 输出helloa1,两个+都是连接,有误区会输出hello&apos;a&apos;1,这是不对的,因为单引号只是证明a为字符型,输出还是要输出字符的值
</code></pre><p>2.请分别计算出a,b,c的值?<br><code>16  16  15</code></p>
<p>3.分析以下需求，并用代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> num = <span class="number">123</span>;</div><div class="line">		<span class="keyword">int</span> ge = num % <span class="number">10</span>;</div><div class="line">		<span class="keyword">int</span> shi = num / <span class="number">10</span> % <span class="number">10</span>;</div><div class="line">		<span class="keyword">int</span> bai = num / <span class="number">100</span> % <span class="number">10</span>;</div><div class="line">		System.out.println(<span class="string">"数字"</span>+num+<span class="string">"的个位数是 "</span>+ge+<span class="string">",十位数是 "</span>+shi+<span class="string">",百位数是 "</span>+bai);		</div><div class="line">	&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><p>1.(1)质数解法一:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prime</span></span>&#123;</div><div class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	<span class="comment">//定义一个计数变量</span></div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="comment">//遍历1-100之间的整数</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</div><div class="line">		<span class="comment">//分别让i % (2-----i-1),如果==0,就不是质数</span></div><div class="line">		<span class="keyword">int</span> j = <span class="number">2</span>;</div><div class="line">		<span class="keyword">for</span>( ;j &lt; i;j++)&#123;</div><div class="line">			<span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</div><div class="line">    <span class="comment">//当%j == 0,立刻跳出循环,判断j的值,如果i==j的值,说明i是质数</span></div><div class="line">	<span class="comment">//如果不等,说明i % (比i小的数)== 0,则i不是质数</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">	        &#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(i == j)&#123;</div><div class="line">			System.out.print(i+<span class="string">" "</span>);</div><div class="line">			count++;</div><div class="line">			<span class="keyword">if</span>(count % <span class="number">5</span> == <span class="number">0</span>)&#123;</div><div class="line">				System.out.println();	</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	System.out.println(<span class="string">"质数总数是: "</span>+count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1.(2)质数解法二:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prime</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="comment">//定义一个计数变量</span></div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="comment">//遍历2-100之间的整数,不从1遍历的原因是定义flag为true,默认都是质数,1不经过内层for,所以依然被认为是质数,所以要从2开始</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100</span>;i++)&#123;</div><div class="line">			<span class="comment">//默认都是质数</span></div><div class="line">			<span class="comment">//思考?把boolean flag = true;放在for外边,会怎样?</span></div><div class="line">			<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt; i;j++)&#123;</div><div class="line">				<span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</div><div class="line">			<span class="comment">//不满足质数条件,break </span></div><div class="line">			<span class="comment">//会有疑问?为什解法一在判断i==j,这里i==j,i % j==0,不就把质数整成false</span></div><div class="line">			<span class="comment">//其实,当j==i时,内层for条件已经不成立了,直接执行if(flag)了</span></div><div class="line">					flag = <span class="keyword">false</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;	</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//flag为true,就是质数</span></div><div class="line">			<span class="keyword">if</span>(flag)&#123;</div><div class="line">				System.out.print(i+<span class="string">" "</span>);</div><div class="line">				count++;</div><div class="line">				<span class="keyword">if</span>(count % <span class="number">5</span> == <span class="number">0</span>)&#123;</div><div class="line">					System.out.println();	</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"质数总数是: "</span>+count);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.珠峰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhuFeng</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> high = <span class="number">8848</span>;</div><div class="line">		<span class="keyword">double</span> hou = <span class="number">0.01</span>;</div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span>(hou &lt; high)&#123;</div><div class="line">			hou *= <span class="number">2</span>;</div><div class="line">			count++;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"折叠"</span>+count+<span class="string">"次"</span>);</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.打印非9</p>
<p>做法一:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaYin9</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</div><div class="line">			<span class="keyword">if</span>(i/<span class="number">10</span>==<span class="number">9</span> || i%<span class="number">10</span>==<span class="number">9</span>)&#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">	    	System.out.print(i+<span class="string">" "</span>);</div><div class="line">			count++;</div><div class="line">			<span class="keyword">if</span>(count % <span class="number">5</span>==<span class="number">0</span>)&#123;</div><div class="line">			System.out.println();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法二:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="comment">// 1. 定义四个变量</span></div><div class="line">		<span class="keyword">int</span> ge, shi, bai, count=<span class="number">0</span>;</div><div class="line">		<span class="comment">// 2.获取数据1-100 for循环</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num=<span class="number">1</span>; num&lt;=<span class="number">100</span>; num++)&#123;</div><div class="line">		<span class="comment">// 3. 获取数据中的所有位数(个位、十位、百位)</span></div><div class="line">			ge = num % <span class="number">10</span>;</div><div class="line">			shi = num / <span class="number">10</span> % <span class="number">10</span>;</div><div class="line">			bai = num / <span class="number">100</span> % <span class="number">10</span>;</div><div class="line">		<span class="comment">// 判断每个位数上边的数字是否与7相等</span></div><div class="line">			<span class="keyword">if</span>(ge==<span class="number">7</span> || shi==<span class="number">7</span> || bai==<span class="number">7</span>)&#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">				count++;</div><div class="line">			System.out.print(num + <span class="string">" "</span>);</div><div class="line">			<span class="keyword">if</span>(count % <span class="number">5</span> == <span class="number">0</span>)&#123;</div><div class="line">				System.out.println();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.九九乘法表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JiuJiu</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">9</span>;i++)&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;</div><div class="line">				<span class="keyword">int</span> ji = j * j;</div><div class="line">				System.out.print(j+<span class="string">"*"</span>+j+<span class="string">"="</span>+ji+<span class="string">"  "</span>);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">7</span>,<span class="number">18</span>&#125;;</div><div class="line">	<span class="comment">//本题的关键是找到最大,最小元素的索引位置,而不是找到最大最小值,只要知道位置了,就可以进行交换了</span></div><div class="line">		<span class="comment">//定义max,min,记录最大元素和最小元素的索引位置</span></div><div class="line">		<span class="keyword">int</span> max = <span class="number">0</span>,min = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">			<span class="keyword">if</span>(arr[max] &lt; arr[i])&#123;</div><div class="line">				max = i;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(arr[min] &gt; arr[i])&#123;</div><div class="line">				min = i;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length;i++)&#123;</div><div class="line">			System.out.print(arr[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">		<span class="comment">//通过arr[max]和arr[min]可以取到了最大,最小值,定义一个第三方变量,用于交换</span></div><div class="line">		<span class="keyword">int</span> temp = arr[max];</div><div class="line">		arr[max] = arr[arr.length-<span class="number">1</span>];</div><div class="line">		arr[arr.length-<span class="number">1</span>] = temp;</div><div class="line">		<span class="comment">//</span></div><div class="line">		temp = arr[min];</div><div class="line">		arr[min] = arr[<span class="number">0</span>];</div><div class="line">		arr[<span class="number">0</span>] = temp;</div><div class="line">		<span class="comment">//</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length;i++)&#123;</div><div class="line">			System.out.print(arr[i]+<span class="string">" "</span>);</div><div class="line">		&#125;	</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	<span class="comment">//1.利用一个for循环,录入用户输入的6个数据,置于数组中</span></div><div class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)&#123;</div><div class="line">			System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"个整数:"</span>);</div><div class="line">			arr[i] = sc.nextInt() ;</div><div class="line">		&#125;</div><div class="line">	<span class="comment">//2.实现反转</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>,end = arr.length-<span class="number">1</span>;start &lt; end;start++,end--)&#123;</div><div class="line">			<span class="keyword">int</span> temp = arr[start];</div><div class="line">			arr[start] = arr[end];</div><div class="line">			arr[end] = temp;</div><div class="line">		&#125;</div><div class="line">	<span class="comment">//3.将翻转后的数组角标为奇数的互相交换 1和3换, 3和5换,以此类推</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j =<span class="number">3</span>;i &lt; arr.length &amp;&amp; j &lt; arr.length;i+=<span class="number">2</span>,j+=<span class="number">2</span>)&#123;</div><div class="line">			<span class="keyword">int</span> temp = arr[i];</div><div class="line">			arr[i] = arr[j];</div><div class="line">			arr[j] = temp;</div><div class="line">		&#125;</div><div class="line">	<span class="comment">//4.最后将数组最后一个角标为奇数的元素 和数组中第一个角标为奇数的元素交换</span></div><div class="line">	<span class="comment">//判断最后一个角标为奇数,需要先知道数组长度,根据数组长度的奇偶性,最后一个角标为奇数的索引不同</span></div><div class="line">		<span class="keyword">int</span> lastIndex = (arr.length % <span class="number">2</span> == <span class="number">0</span> ? arr.length-<span class="number">1</span> : arr.length-<span class="number">2</span>);</div><div class="line">		<span class="keyword">int</span> temp = arr[<span class="number">1</span>];</div><div class="line">		arr[<span class="number">1</span>] = arr[lastIndex];</div><div class="line">		arr[lastIndex] = temp;</div><div class="line">	<span class="comment">//</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++ )&#123;</div><div class="line">			System.out.print(arr[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println();	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ASCII编码及char类型的存储"><a href="#ASCII编码及char类型的存储" class="headerlink" title="ASCII编码及char类型的存储"></a>ASCII编码及char类型的存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//法一:</span></div><div class="line">	<span class="keyword">char</span> i,j;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">65</span>; i &lt;= <span class="number">90</span>; i++) &#123;</div><div class="line">		j = (<span class="keyword">char</span>) (i + <span class="number">32</span>);</div><div class="line">		System.out.print(<span class="string">"大写: "</span>+i+<span class="string">" 小写: "</span>+j);</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line"><span class="comment">//法二:</span></div><div class="line"><span class="keyword">char</span> daXie = <span class="string">'A'</span>;</div><div class="line">	<span class="keyword">char</span> xiaoXie = <span class="string">'a'</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</div><div class="line">		System.out.println(<span class="string">"大写: "</span>+daXie+<span class="string">" 小写: "</span>+xiaoXie);</div><div class="line">		daXie++;</div><div class="line">		xiaoXie++;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="comment">//私有空参构造方法</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//设置静态Student类型共享变量 stu</span></div><div class="line">	<span class="comment">//能用static的原因是此时并没有创建对象,只是定义一个Student类型的成员变量</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Student stu;    </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getStudent</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//第一次调用该方法,stu为引用变量,存的默认值null</span></div><div class="line">		<span class="keyword">if</span> (stu == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Student();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> stu;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">		<span class="comment">//静态方法,直接用类名.调用   </span></div><div class="line">		Student stu = Student.getStudent();</div><div class="line">		System.out.println(stu);</div><div class="line">		System.out.println(stu);</div><div class="line">		System.out.println(stu);</div><div class="line">		System.out.println(stu);</div><div class="line">		System.out.println(stu);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//打印的地址值一模一样,说明Student对象只被new了一次</span></div></pre></td></tr></table></figure></p>
<p>2.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Phone类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGame</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//NewPhone</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">IGame</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"打游戏"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;			</div><div class="line">&#125;</div><div class="line"><span class="comment">//OldPhone</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Test</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//采用匿名内部类, 其实创建的是NewPhone的子类</span></div><div class="line">		<span class="comment">//NewPhone的子类直接调用NewPhone的playGame()	</span></div><div class="line">		<span class="keyword">new</span> NewPhone()&#123;</div><div class="line"></div><div class="line">		&#125;.playGame();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//局部变量i , 生命周期是随着方法弹栈而消亡</span></div><div class="line">		<span class="comment">//function弹栈后, Inner类并没有被回收</span></div><div class="line">		<span class="comment">//要想访问i,需要将i设为常量,进入常量池中,局部内部类就可以访问到</span></div><div class="line">		fianl <span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">		<span class="comment">//局部内部类在方法内</span></div><div class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">			<span class="keyword">int</span> j = i;  <span class="comment">//不加final,会报错</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">				syso(j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//创建内部类对象,调用method方法</span></div><div class="line">		<span class="comment">//如果不创建,没法执行method方法</span></div><div class="line">		<span class="keyword">new</span> Inner().method();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </div><div class="line">		Outer o = <span class="keyword">new</span> Outer();</div><div class="line">		o.function();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="comment">//私有成员内部类</span></div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"私有成员内部类"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//为私有成员内部类创建public方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Heart <span class="title">getHeart</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Heart();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHeartMethod</span><span class="params">(Heart h)</span></span>&#123;</div><div class="line">		h.h();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//静态成员内部类</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Shen</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"静态成员内部类"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//默认成员内部类</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Fei</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"默认成员内部类"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//局部内部类</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Gan</span></span>&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</div><div class="line">				System.out.println(<span class="string">"局部内部类"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">new</span> Gan().g();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//调用默认成员内部类</span></div><div class="line">		Person.Fei f = <span class="keyword">new</span> Person().new Fei();</div><div class="line">		f.f();</div><div class="line">		<span class="comment">//调用静态成员内部类</span></div><div class="line">		<span class="keyword">new</span> Person.Shen().s();</div><div class="line">		<span class="comment">//调用私有成员内部类</span></div><div class="line">		<span class="keyword">new</span> Person().getHeartMethod(<span class="keyword">new</span> Person().getHeart());</div><div class="line">		<span class="comment">//调用局部内部类</span></div><div class="line">		<span class="keyword">new</span> Person().method();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果:</span></div><div class="line"><span class="comment">//默认成员内部类</span></div><div class="line"><span class="comment">//静态成员内部类</span></div><div class="line"><span class="comment">//私有成员内部类</span></div><div class="line"><span class="comment">//局部内部类</span></div></pre></td></tr></table></figure></p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>1.</p>
<p>做法一:(我的第一遍做法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	String[] str = &#123; <span class="string">"010"</span>, <span class="string">"3223"</span>, <span class="string">"666"</span>, <span class="string">"7890987"</span>, <span class="string">"123123"</span>,<span class="string">"5233425"</span> &#125;;</div><div class="line">	System.out.println(<span class="string">"对称字符串的个数: "</span> + getCount(str));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String[] str)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (; j &lt; str[i].length(); j++) &#123;</div><div class="line">			<span class="keyword">if</span> (str[i].charAt(j) != str[i].charAt(str[i].length() - j - <span class="number">1</span>)) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (j == str[i].length()) &#123;</div><div class="line">			count++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法二:判断是否对称,定义为方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	String[] str = &#123; <span class="string">"010"</span>, <span class="string">"3223"</span>, <span class="string">"666"</span>, <span class="string">"7890987"</span>, <span class="string">"123123"</span>, <span class="string">"523325"</span> &#125;;</div><div class="line">	System.out.println(<span class="string">"对称字符串的个数: "</span> + getCount(str));</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDuiCheng</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span>[] cArr = str.toCharArray();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cArr.length; i++) &#123;</div><div class="line">		<span class="keyword">if</span> (cArr[i] != cArr[cArr.length - i - <span class="number">1</span>]) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String[] str)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">		<span class="keyword">if</span> (isDuiCheng(str[i])) &#123;</div><div class="line">			count++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法三:用StringBuffer<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	String[] str = &#123; <span class="string">"010"</span>, <span class="string">"3223"</span>, <span class="string">"666"</span>, <span class="string">"7890987"</span>, <span class="string">"123123"</span>, <span class="string">"523325"</span> &#125;;</div><div class="line">	System.out.println(<span class="string">"对称字符串的个数: "</span> + getCount(str));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String[] str)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	StringBuffer sb ;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">		<span class="comment">//每次要new一个StringBuffer对象,确保每次只有一个元素被反转</span></div><div class="line">		sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">		<span class="comment">//sb.append(str[i]).reverse()每次添加一个元素进行反转</span></div><div class="line">		<span class="keyword">if</span> (sb.append(str[i]).reverse().toString().equals(str[i])) &#123;</div><div class="line">			count++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.</p>
<p>做法一:(我的第一遍做法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"请输入一个字符串,结束请输入end"</span>);</div><div class="line">			String str = sc.next();</div><div class="line">			<span class="keyword">if</span> (str.equals(<span class="string">"end"</span>)) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//注意,只有char类型的数组可以直接打印</span></div><div class="line">			System.out.println(change(str));</div><div class="line">			</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"结束"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] change(String str) &#123;</div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">char</span>[] cArr = str.toCharArray();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cArr.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (cArr[i] &gt;= <span class="string">'A'</span> &amp;&amp; cArr[i] &lt;= <span class="string">'Z'</span>) &#123;</div><div class="line">				cArr[i] = (<span class="keyword">char</span>) (cArr[i] + <span class="number">32</span>);</div><div class="line">				count++;</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (cArr[i] &gt;= <span class="string">'a'</span> &amp;&amp; cArr[i] &lt;= <span class="string">'z'</span>) &#123;</div><div class="line">				cArr[i] = (<span class="keyword">char</span>) (cArr[i] - <span class="number">32</span>);</div><div class="line">				count++;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				cArr[i] = <span class="string">'*'</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"字母的个数: "</span>+count);</div><div class="line">		<span class="keyword">return</span> cArr;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>做法二: 使用StringBuilder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			System.out.println(<span class="string">"请输入一个字符串,结束请输入end"</span>);</div><div class="line">			String str = sc.next();</div><div class="line">			<span class="keyword">if</span> (str.equals(<span class="string">"end"</span>)) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			change(str);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">char</span>[] cArr = str.toCharArray();</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cArr.length; i++) &#123;</div><div class="line">			<span class="keyword">char</span> c = cArr[i];</div><div class="line">			<span class="keyword">if</span> (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &#123;</div><div class="line">				sb.append((<span class="keyword">char</span>) (c + <span class="number">32</span>));</div><div class="line">				count++;</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) &#123;</div><div class="line">				sb.append((<span class="keyword">char</span>) (c - <span class="number">32</span>));</div><div class="line">				count++;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				sb.append(<span class="string">'*'</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"转换后："</span>+sb);</div><div class="line">		System.out.println(<span class="string">"总共"</span>+count+<span class="string">"个字母"</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>3.</p>
<p>做法一:(我的第一遍做法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">		System.out.println(<span class="string">"请输入一个字符串str1:(结束请输入end)"</span>);</div><div class="line">		String str1 = sc.next();</div><div class="line">		String str2 = <span class="string">""</span>;</div><div class="line">		<span class="keyword">if</span> (str1.equals(<span class="string">"end"</span>) || str2.equals(<span class="string">"end"</span>)) &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"请输入一个字符串str2:(结束请输入end)"</span>);</div><div class="line">		str2 = sc.next();</div><div class="line">		</div><div class="line">		Object[] o = deleteSubString(str1,str2);</div><div class="line">		System.out.println(<span class="string">"最终的字符串:"</span>+o[<span class="number">0</span>]);</div><div class="line">		System.out.println(<span class="string">"删除的str2的个数:  "</span>+o[<span class="number">1</span>]);</div><div class="line">	&#125;</div><div class="line">	System.out.println(<span class="string">"结束!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object[] deleteSubString(String str1, String str2) &#123;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	String str = str1;</div><div class="line">	<span class="keyword">while</span>(str1.contains(str2))&#123;</div><div class="line">		str1 = str1.substring(str1.indexOf(str2)+str2.length());</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	Object[] o = <span class="keyword">new</span> Object[<span class="number">2</span>];</div><div class="line">	o[<span class="number">0</span>] = str.replace(str2, <span class="string">""</span>);</div><div class="line">	o[<span class="number">1</span>] = count;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法二: 使用String类的replaceFirst方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">		System.out.println(<span class="string">"请输入一个字符串str1:(结束请输入end)"</span>);</div><div class="line">		String str1 = sc.next();</div><div class="line">		String str2 = <span class="string">""</span>;</div><div class="line">		<span class="keyword">if</span> (str1.equals(<span class="string">"end"</span>) || str2.equals(<span class="string">"end"</span>)) &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"请输入一个字符串str2:(结束请输入end)"</span>);</div><div class="line">		str2 = sc.next();</div><div class="line">		</div><div class="line">		Object[] o = deleteSubString(str1,str2);</div><div class="line">		System.out.println(<span class="string">"最终的字符串:"</span>+o[<span class="number">0</span>]);</div><div class="line">		System.out.println(<span class="string">"删除的str2的个数:  "</span>+o[<span class="number">1</span>]);</div><div class="line">	&#125;</div><div class="line">	System.out.println(<span class="string">"结束!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object[] deleteSubString(String str1, String str2) &#123;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(str1.contains(str2))&#123;</div><div class="line">		str1 = str1.replaceFirst(str2, <span class="string">""</span>);</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	Object[] o = <span class="keyword">new</span> Object[<span class="number">2</span>];</div><div class="line">	o[<span class="number">0</span>] = str1;</div><div class="line">	o[<span class="number">1</span>] = count;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	System.out.println(<span class="string">"请输入月份:"</span>);</div><div class="line">	<span class="keyword">int</span> month = sc.nextInt();</div><div class="line">	ArrayList&lt;BigInteger&gt; list = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</div><div class="line">	list.add(<span class="number">0</span>, <span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</div><div class="line">	list.add(<span class="number">1</span>,<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</div><div class="line"></div><div class="line">	BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; month+<span class="number">1</span>; i++) &#123;</div><div class="line">		list.add(i,<span class="keyword">new</span> BigInteger((list.get(i-<span class="number">1</span>).add(list.get(i-<span class="number">2</span>))).toString()));</div><div class="line">		 b = list.get(i);</div><div class="line">	&#125;</div><div class="line">	System.out.println(<span class="string">"第"</span>+month+<span class="string">"个月繁殖"</span>+b.toString()+<span class="string">"对兔子"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.<br>做法一:(我的第一遍做法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSingleString</span><span class="params">(String str)</span></span>&#123;</div><div class="line">	String newStr =<span class="string">""</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length() ; ) &#123;</div><div class="line">		<span class="keyword">char</span> c = str.charAt(<span class="number">0</span>);</div><div class="line">		newStr = newStr + c;</div><div class="line">		str = str.substring(i+<span class="number">1</span>);</div><div class="line">		String c1 = c+<span class="string">""</span>;</div><div class="line">		str = str.replaceAll(c1, <span class="string">""</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> newStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法二:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSingleString</span><span class="params">(String str)</span></span>&#123;</div><div class="line">	<span class="keyword">char</span>[] chars = str.toCharArray();</div><div class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;chars.length;i++) &#123;</div><div class="line">		<span class="keyword">if</span>(!sb.toString().contains(chars[i]+<span class="string">""</span>)) &#123;</div><div class="line">			sb.append(chars[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>1.<br>做法一:(我的第一遍做法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Random ran = <span class="keyword">new</span> Random();</div><div class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"><span class="keyword">int</span> ranNum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">	ranNum = ran.nextInt(<span class="number">10</span>)+<span class="number">1</span>;</div><div class="line">	list.add(i, ranNum);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">		<span class="keyword">if</span> (list.get(j) == ranNum) &#123;</div><div class="line">			list.remove(i);</div><div class="line">			i--;		</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure></p>
<p>做法二:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Random ran = <span class="keyword">new</span> Random();</div><div class="line">	ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">	<span class="keyword">while</span>(list.size()&lt;<span class="number">10</span>)&#123;</div><div class="line">		<span class="keyword">int</span> num = ran.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (!list.contains(num)) &#123;</div><div class="line">			list.add(num);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	System.out.println(list);	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.<br>做法一:(我的第一遍做法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">	print(list);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	System.out.println(<span class="string">"要输入几位数: "</span>);</div><div class="line">	<span class="keyword">int</span> num = sc.nextInt();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</div><div class="line">		System.out.println(<span class="string">"请输入一个0-9之间的数字:"</span>);</div><div class="line">		<span class="keyword">int</span> inputNum = sc.nextInt();</div><div class="line">		<span class="keyword">if</span> (inputNum &gt;= <span class="number">0</span> &amp;&amp; inputNum &lt;= <span class="number">9</span>) &#123;</div><div class="line">			list.add(i, inputNum);</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">				<span class="keyword">if</span> (list.get(i) == list.get(j)) &#123;</div><div class="line">					System.out.println(<span class="string">"输入重复,请重新输入"</span>);</div><div class="line">					list.remove(i);</div><div class="line">					i--;</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (i == num - <span class="number">1</span>) &#123;</div><div class="line">				System.out.println(<span class="string">"输入正确,输入结束"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			System.out.println(<span class="string">"输入错误,重新输入"</span>);</div><div class="line">			i--;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	sort(list);</div><div class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">		<span class="keyword">if</span> (list.get(i) == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		s: <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size(); j++) &#123;</div><div class="line">			<span class="keyword">if</span> (j == i) &#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; list.size(); k++) &#123;</div><div class="line">				<span class="keyword">if</span> (k == i || k == j) &#123;</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				&#125;</div><div class="line">				sb.append(list.get(i)).append(list.get(j)).append(list.get(k));</div><div class="line">				count++;</div><div class="line">				<span class="keyword">continue</span> s;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">char</span>[] cArr = sb.toString().toCharArray();</div><div class="line">	System.out.println(<span class="string">"总共"</span> + count + <span class="string">"种"</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cArr.length; i++) &#123;</div><div class="line">		System.out.print(cArr[i] + <span class="string">""</span>);</div><div class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>) &#123;</div><div class="line">			System.out.print(<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size() - i - <span class="number">1</span>; j++) &#123;</div><div class="line">			<span class="keyword">if</span> (list.get(j) &gt; list.get(j + <span class="number">1</span>)) &#123;</div><div class="line">				<span class="keyword">int</span> temp = list.get(j);</div><div class="line">				list.set(j, list.get(j + <span class="number">1</span>));</div><div class="line">				list.set(j + <span class="number">1</span>, temp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法二:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//1、定义一个方法，从控制台获取用户输入的3个任意0-9之间的数字(3个数字不重复)</span></div><div class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">		ArrayList&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();	<span class="comment">//存放每种组合的集合</span></div><div class="line">		saveList(sc,list);</div><div class="line">		System.out.println(list);</div><div class="line">		<span class="comment">//2、并将其拼接为完全不重复的三位数。</span></div><div class="line">		printZuHe(list,newList);</div><div class="line">		<span class="comment">//3、对newList集合进行排序</span></div><div class="line">		sortList(newList);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; newList.size(); i++) &#123;</div><div class="line">			<span class="keyword">int</span> num = newList.get(i);	<span class="comment">//拿到每一个数字</span></div><div class="line">			<span class="keyword">if</span>(num &lt; <span class="number">100</span>) &#123;</div><div class="line">				System.out.print(<span class="string">"0"</span> + num + <span class="string">" "</span>);</div><div class="line">			&#125;<span class="keyword">else</span> &#123;</div><div class="line">				System.out.print(num + <span class="string">" "</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 对集合进行排序</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortList</span><span class="params">(ArrayList&lt;Integer&gt; newList)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; newList.size(); i++) &#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newList.size()-<span class="number">1</span>-i; j++) &#123;</div><div class="line">				<span class="keyword">int</span> num1 = newList.get(j);</div><div class="line">				<span class="keyword">int</span> num2 = newList.get(j+<span class="number">1</span>);</div><div class="line">				<span class="keyword">if</span>(num1 &gt; num2) &#123;</div><div class="line">					<span class="comment">//交换位置</span></div><div class="line">					newList.set(j, num2);</div><div class="line">					newList.set(j+<span class="number">1</span>, num1);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 获取三个数字不重复的组合</div><div class="line">	 * 先将数字拆分成：个位、十位、百位</div><div class="line">	    		遍历集合，拿到每一个数字。先对个位数进行赋值</div><div class="line">	    		遍历集合，拿到每一个数字。再对十位数进行赋值(在赋值之前，先判断获取到的数字和个位数不相同)</div><div class="line">	    		遍历集合，拿到每一个数字。再对百位数进行赋值(在赋值之前，先判断获取到的数字和个位、十位数都不相同)</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printZuHe</span><span class="params">(ArrayList&lt;Integer&gt; list,ArrayList&lt;Integer&gt; newList)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> ge = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> shi = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> bai = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; list.size(); i++) &#123;</div><div class="line">			ge = list.get(i);	<span class="comment">//对个位数进行赋值</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; list.size(); j++) &#123;</div><div class="line">				<span class="comment">//如果获取到的数字，和个位数的数字不相同。赋值</span></div><div class="line">				<span class="keyword">if</span>(list.get(j) != ge) &#123;</div><div class="line">					shi = list.get(j);	<span class="comment">//对十位数进行赋值</span></div><div class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; list.size(); k++) &#123;</div><div class="line">						<span class="comment">//先判断获取到的数字和个位、十位数都不相同</span></div><div class="line">						<span class="keyword">if</span>(list.get(k) != ge &amp;&amp; list.get(k) != shi) &#123;</div><div class="line">							bai = list.get(k);	<span class="comment">//对百位数进行赋值</span></div><div class="line">							<span class="comment">//System.out.println(""+ge + shi + bai);</span></div><div class="line">							String strNum = <span class="string">""</span> + ge + shi + bai;</div><div class="line">							newList.add(Integer.parseInt(strNum));</div><div class="line">							count++;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"组合一共有："</span> + count + <span class="string">"种"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 键盘录入三个数字。不能重复。存入集合</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveList</span><span class="params">(Scanner sc, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"请录入3个任意0-9之间的数字："</span>);</div><div class="line">		<span class="comment">//如果集合的长度不等于3个</span></div><div class="line">		<span class="keyword">while</span>(list.size() != <span class="number">3</span>) &#123;</div><div class="line">			<span class="comment">//一直存入</span></div><div class="line">			<span class="keyword">int</span> num = sc.nextInt();	<span class="comment">//接收键盘录入的数字</span></div><div class="line">			<span class="keyword">if</span>(list.contains(num)) &#123;</div><div class="line">				System.out.println(<span class="string">"集合中已经包含此数字,请继续输入！"</span>);</div><div class="line">			&#125;<span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">//可以存入</span></div><div class="line">				list.add(num);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>3.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</div><div class="line">	<span class="comment">//使用选择排序思想，对集合进行排序</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; list.size(); i++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; list.size();j++) &#123;</div><div class="line">			String str1 = list.get(i);		<span class="comment">//获取第一个字符串</span></div><div class="line">			String str2 = list.get(j);		<span class="comment">//获取第二个字符串</span></div><div class="line">			<span class="keyword">if</span>(str1.compareTo(str2) &gt; <span class="number">0</span>) &#123;	<span class="comment">//compareTo  如果返回的是正整数(升序)   返回的是负整数(降序)  返回0(相等)</span></div><div class="line">				<span class="comment">//交换位置</span></div><div class="line">				list.set(i, str2);</div><div class="line">				list.set(j, str1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">	System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"个的姓名:"</span>);</div><div class="line">	String name = sc.next();</div><div class="line">	System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"个的年龄:"</span>);</div><div class="line">	<span class="keyword">int</span> age = sc.nextInt();</div><div class="line">	list.add(<span class="keyword">new</span> Person(name, age));</div><div class="line">&#125;</div><div class="line">Set&lt;Person&gt; list1 = <span class="keyword">new</span> LinkedHashSet&lt;Person&gt;();</div><div class="line">list1.addAll(list);</div><div class="line">list.clear();</div><div class="line">list.addAll(list1);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++) &#123;</div><div class="line">		Person p1 = list.get(i);</div><div class="line">		Person p2 = list.get(j);</div><div class="line">		<span class="keyword">if</span> (p1.getAge() &lt; p2.getAge()) &#123;</div><div class="line">			list.set(i, p2);</div><div class="line">			list.set(j, p1);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println(list);</div></pre></td></tr></table></figure></p>
<p>5.<br>做法一:(我的第一遍做法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">replaceStr</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</div><div class="line">		<span class="keyword">if</span> (str.charAt(i) == <span class="string">'z'</span>) &#123;</div><div class="line">			sb.append(<span class="string">'a'</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		sb.append((<span class="keyword">char</span>)(str.charAt(i)+<span class="number">1</span>));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法二:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>[] arr = str.toCharArray();</div><div class="line"><span class="comment">//遍历字符数组</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">	<span class="keyword">if</span>(arr[i] == <span class="string">'z'</span>) &#123;	<span class="comment">//如果当前字符是z</span></div><div class="line">		<span class="comment">//将当前字符赋值为a</span></div><div class="line">		arr[i] = <span class="string">'a'</span>;</div><div class="line">	&#125;<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">//将每个字符+1即可</span></div><div class="line">		arr[i] = (<span class="keyword">char</span>) (arr[i]+<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveList</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">	<span class="comment">//创建随机数对象</span></div><div class="line">	Random r = <span class="keyword">new</span> Random();</div><div class="line">	<span class="comment">//只要集合长度小于8个，那么就一直生成随机数进行存储</span></div><div class="line">	<span class="keyword">while</span>(list.size() != <span class="number">8</span>) &#123;</div><div class="line">		<span class="comment">//生成一个随机数</span></div><div class="line">		<span class="keyword">int</span> num = r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</div><div class="line">		<span class="comment">//如果这个随机数是奇数</span></div><div class="line">		<span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">			<span class="comment">//存入集合</span></div><div class="line">			list.add(num);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>7.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	list.add(<span class="string">"a"</span>);</div><div class="line">	list.add(<span class="string">"f"</span>);</div><div class="line">	list.add(<span class="string">"b"</span>);</div><div class="line">	list.add(<span class="string">"b"</span>);</div><div class="line">	list.add(<span class="string">"b"</span>);</div><div class="line">	list.add(<span class="string">"b"</span>);</div><div class="line">	list.add(<span class="string">"b"</span>);</div><div class="line">	list.add(<span class="string">"c"</span>);</div><div class="line">	list.add(<span class="string">"a"</span>);</div><div class="line">	list.add(<span class="string">"d"</span>); </div><div class="line">	</div><div class="line">	<span class="comment">//利用HashSet对list集合去重(最终结果:list中没有重复元素)</span></div><div class="line">	HashSet&lt;String&gt; hs = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">	hs.addAll(list);	<span class="comment">//将list集合中的内容全部添加到HashSet集合中</span></div><div class="line">	list.clear();		<span class="comment">//将list集合清空</span></div><div class="line">	list.addAll(hs);	<span class="comment">//将去重后的集合全部添加到list集合中		</span></div><div class="line">	</div><div class="line">	<span class="comment">/*ArrayList&lt;String&gt; newList = new ArrayList&lt;String&gt;();</span></div><div class="line">	for(int i = 0 ; i &lt; list.size(); i++) &#123;</div><div class="line">		//如果新集合中不包含此元素，则存入</div><div class="line">		if(!newList.contains(list.get(i))) &#123;</div><div class="line">			newList.add(list.get(i));</div><div class="line">		&#125;</div><div class="line">	&#125;*/</div><div class="line">	System.out.println(list);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>8.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * ArrayList嵌套ArrayList</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//创建一个学科集合</span></div><div class="line">	ArrayList&lt;ArrayList&lt;Student&gt;&gt; classRoom = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="comment">//创建基础班集合</span></div><div class="line">	ArrayList&lt;Student&gt; javase = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</div><div class="line">	javase.add(<span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="number">23</span>));</div><div class="line">	javase.add(<span class="keyword">new</span> Student(<span class="string">"李四"</span>, <span class="number">24</span>));</div><div class="line">	</div><div class="line">	<span class="comment">//创建就业班集合</span></div><div class="line">	ArrayList&lt;Student&gt; javaee = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</div><div class="line">	javaee.add(<span class="keyword">new</span> Student(<span class="string">"王五"</span>, <span class="number">25</span>));</div><div class="line">	javaee.add(<span class="keyword">new</span> Student(<span class="string">"赵六"</span>, <span class="number">26</span>));</div><div class="line">	</div><div class="line">	<span class="comment">//将基础班集合和就业班集合添加到学科集合中</span></div><div class="line">	classRoom.add(javase);</div><div class="line">	classRoom.add(javaee);</div><div class="line">	</div><div class="line">	<span class="comment">//使用迭代器遍历集合</span></div><div class="line">	print1(classRoom);</div><div class="line">	<span class="comment">//使用增强for遍历集合</span></div><div class="line">	print2(classRoom);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">(ArrayList&lt;ArrayList&lt;Student&gt;&gt; classRoom)</span> </span>&#123;</div><div class="line">	<span class="comment">//第一层循环，获取的是班级集合</span></div><div class="line">	<span class="keyword">for</span>(ArrayList&lt;Student&gt; list : classRoom) &#123;</div><div class="line">		<span class="comment">//第二层循环，获取的是学生对象</span></div><div class="line">		<span class="keyword">for</span>(Student stu : list) &#123;</div><div class="line">			System.out.println(stu);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">(ArrayList&lt;ArrayList&lt;Student&gt;&gt; classRoom)</span> </span>&#123;</div><div class="line">	<span class="comment">//获取学科迭代器</span></div><div class="line">	Iterator&lt;ArrayList&lt;Student&gt;&gt; it = classRoom.iterator();</div><div class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">		<span class="comment">//获取到每个班级集合</span></div><div class="line">		ArrayList&lt;Student&gt; list = it.next();</div><div class="line">		<span class="comment">//通过班级集合获取迭代器</span></div><div class="line">		Iterator&lt;Student&gt; it2 = list.iterator();</div><div class="line">		<span class="keyword">while</span>(it2.hasNext()) &#123;</div><div class="line">			<span class="comment">//获取每一个学生对象</span></div><div class="line">			Student stu = it2.next();</div><div class="line">			<span class="comment">//打印学生对象</span></div><div class="line">			System.out.println(stu);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>9.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//将A-Z,a-z,0-9这些字符存入一个List中</span></div><div class="line">	List&lt;Character&gt; list = getList();</div><div class="line">	<span class="comment">//System.out.println(list);</span></div><div class="line">	<span class="comment">//获得生成字符串集合</span></div><div class="line">	HashSet&lt;String&gt; stringSet= getSet(list);</div><div class="line">	<span class="comment">//遍历输出</span></div><div class="line">	<span class="keyword">for</span>(String s : stringSet)&#123;</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;String&gt; <span class="title">getSet</span><span class="params">(List&lt;Character&gt; list)</span> </span>&#123;</div><div class="line">	<span class="comment">//创建两个HashSet集合,第一个用来存10个不重复的字符串,第二个用来存10个字符不重复的字符</span></div><div class="line">	HashSet&lt;String&gt; stringSet = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</div><div class="line">	HashSet&lt;Character&gt; charSet = <span class="keyword">new</span> LinkedHashSet&lt;Character&gt;();</div><div class="line">	<span class="comment">//定义随机数对象, 来获取随机数</span></div><div class="line">	Random ran = <span class="keyword">new</span> Random();</div><div class="line">	<span class="comment">//当字符串集合长度&lt;10</span></div><div class="line">	<span class="keyword">while</span>(stringSet.size()&lt;<span class="number">10</span>)&#123;</div><div class="line">		<span class="comment">//当字符集合长度&lt;10</span></div><div class="line">		<span class="keyword">while</span>(charSet.size()&lt;<span class="number">10</span>)&#123;</div><div class="line">			<span class="comment">//生成0-61的随机数</span></div><div class="line">			<span class="keyword">int</span> ranNum = ran.nextInt(list.size());</div><div class="line">			<span class="comment">//获取List集合中该元素</span></div><div class="line">			<span class="keyword">char</span> c = list.get(ranNum);</div><div class="line">			<span class="comment">//向charSet集合中添加</span></div><div class="line">			charSet.add(c);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//此时获得的charSet是一个长度为10的字符集合</span></div><div class="line">		<span class="comment">//要向stringSet里添加,需要先转成字符串</span></div><div class="line">		<span class="comment">//遍历charSet</span></div><div class="line">		String str = <span class="string">""</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> c : charSet)&#123;</div><div class="line">			str+=c;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//此时获得了一个长度为10的字符串,添加至stringSet</span></div><div class="line">		stringSet.add(str);</div><div class="line">		<span class="comment">//将charSet清空,否则再次执行,charSet长度为10,不再进内层while</span></div><div class="line">		charSet.clear();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> stringSet;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Character&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</div><div class="line">	ArrayList&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'A'</span>; i &lt;= <span class="string">'Z'</span>; i++) &#123;</div><div class="line">		list.add(i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; i++) &#123;</div><div class="line">		list.add(i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'0'</span>; i &lt;= <span class="string">'9'</span>; i++) &#123;</div><div class="line">		list.add(i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>10.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//创建一个List集合,存储字符串元素</span></div><div class="line">	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	<span class="comment">//创建一盒Map集合, 键存字符, 值存字符个数, 使用双列集合的原因是 键不重复, 添加相同键时, 会被覆盖掉</span></div><div class="line">	<span class="comment">//定一个LinkedHashMap,而不是HashMap的原因是 : 输出格式中, 按照存储顺序进行打印,所以使用存取有序的LinkedHashMap</span></div><div class="line">	LinkedHashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;Character, Integer&gt;();</div><div class="line">	<span class="comment">//list集合添加元素</span></div><div class="line">	list.add(<span class="string">"abc"</span>);</div><div class="line">	list.add(<span class="string">"bcd"</span>);</div><div class="line">	<span class="comment">//遍历list集合,拿出每一个元素</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">		String str = list.get(i);</div><div class="line">		<span class="comment">//将字符串str传成char数组</span></div><div class="line">		<span class="keyword">char</span>[] arr = str.toCharArray();</div><div class="line">		<span class="comment">//遍历char数组,判断map集合中是否存在当前的键</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</div><div class="line">			<span class="comment">//如果不存在, 添加字符,值为1</span></div><div class="line">			<span class="keyword">if</span> (!map.containsKey(arr[j])) &#123;</div><div class="line">				map.put(arr[j], <span class="number">1</span>);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="comment">//如果存在,根据键获取当前字符的值, 即个数 ,进行加1操作, 再添加</span></div><div class="line">				map.put(arr[j], map.get(arr[j])+<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//按照指定格式,遍历打印map</span></div><div class="line">	<span class="comment">//keySet增强for</span></div><div class="line">	Set&lt;Character&gt; charSet =  map.keySet();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> key : charSet)&#123;</div><div class="line">		<span class="keyword">int</span> value = map.get(key);</div><div class="line">		System.out.println(key+<span class="string">" = "</span>+value);</div><div class="line">	&#125;</div><div class="line">	System.out.println(<span class="string">"--------分割线----------"</span>);</div><div class="line">	<span class="comment">//entrySet增强for</span></div><div class="line">	Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet();</div><div class="line">	<span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : entrySet)&#123;</div><div class="line">		<span class="keyword">char</span> key = entry.getKey();</div><div class="line">		<span class="keyword">int</span> value = entry.getValue();</div><div class="line">		System.out.println(key+<span class="string">" = "</span>+value);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>11.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//定义List集合存商品名</span></div><div class="line">	ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	list1.add(<span class="string">"苹果"</span>);</div><div class="line">	list1.add(<span class="string">"香蕉"</span>);</div><div class="line">	list1.add(<span class="string">"西瓜"</span>);</div><div class="line">	list1.add(<span class="string">"橘子"</span>);</div><div class="line">	<span class="comment">//定义List集合存商品号</span></div><div class="line">	<span class="comment">//备注: 惯性思维, 存储不重复的元素, 定义HashSet</span></div><div class="line">	<span class="comment">//但这里定义成ArrayList的原因是: </span></div><div class="line">	<span class="comment">//因为要把商品号添加至双列集合,HashSet没有索引,要想双列集合添加,</span></div><div class="line">	<span class="comment">//还要新建一个List集合存HashSet里面的商品号,再用List集合往双列集合填,比较麻烦</span></div><div class="line">	<span class="comment">//直接定义成List集合,然后加一个contains判断, 也可达到HashSet去重的目的</span></div><div class="line">	ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	Random ran = <span class="keyword">new</span> Random();</div><div class="line">	<span class="keyword">while</span>(list2.size()&lt;<span class="number">4</span>)&#123;</div><div class="line">		String num = <span class="string">""</span>;</div><div class="line">		<span class="keyword">while</span>(num.length()!=<span class="number">8</span>)&#123;</div><div class="line">			num += ran.nextInt(<span class="number">10</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//判断商品号集合中是否包含此号, 不含则添加</span></div><div class="line">		<span class="keyword">if</span> (!list2.contains(num)) &#123;</div><div class="line">			list2.add(num);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将商品号,与商品信息添加值双列集合</span></div><div class="line">	LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</div><div class="line">	<span class="comment">//遍历List集合,向map中添加商品信息</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.size(); i++) &#123;</div><div class="line">		map.put(list2.get(i), list1.get(i));</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//遍历双列集合,显示商品信息</span></div><div class="line">	Set&lt;String&gt; keySet = map.keySet();</div><div class="line">	<span class="keyword">for</span>(String key : keySet)&#123;</div><div class="line">		String value = map.get(key);</div><div class="line">		System.out.println(<span class="string">"商品号:"</span> + key+<span class="string">" | 商品: "</span>+value);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//提示用户输入商品</span></div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	System.out.println(<span class="string">"请输入商品号进行查询: "</span>);</div><div class="line">	String str = sc.next();</div><div class="line">	<span class="keyword">if</span> (map.containsKey(str)) &#123;</div><div class="line">		System.out.println(<span class="string">"根据商品号："</span>+str+<span class="string">"，查询到对应的商品为："</span>+map.get(str));</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		System.out.println(<span class="string">"查无此商品"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//键盘录入一个整数</span></div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	System.out.println(<span class="string">"请输入一个整数: "</span>);</div><div class="line">	<span class="comment">//求二进制</span></div><div class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">		String num = sc.nextLine();</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			<span class="comment">//合适整数则进行求二进制运算,并打印</span></div><div class="line">			String binaryNum = Integer.toBinaryString(Integer.parseInt(num));</div><div class="line">			System.out.println(binaryNum);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="comment">//如果可以将这个数存入BigInteger中,说明整数过大</span></div><div class="line">				<span class="keyword">new</span> BigInteger(num);</div><div class="line">				<span class="comment">//提醒用户重新录入</span></div><div class="line">				System.out.println(<span class="string">"录入的整数过大请重新录入一个整数"</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="comment">//如果可以将这个数存入BigDecimal中.说明为小数</span></div><div class="line">					<span class="keyword">new</span> BigDecimal(num);</div><div class="line">					<span class="comment">//提醒用户重新录入</span></div><div class="line">					System.out.println(<span class="string">"录入的是小数,请重新录入一个整数"</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">					<span class="comment">//不是大整数, 不是小数, 判定为其他字符,提示用户</span></div><div class="line">					System.out.println(<span class="string">"录入的是非法字符,请重新录入一个整数"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//获得一个File型路径</span></div><div class="line">	File file = getDir();</div><div class="line">	<span class="comment">//获得文件夹大小</span></div><div class="line">	<span class="keyword">long</span> length = getDirLength(file);</div><div class="line">	System.out.println(<span class="string">"文件夹大小是"</span>+length);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 统计文件夹大小</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getDirLength</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">	<span class="comment">//定义大小变量</span></div><div class="line">	<span class="keyword">long</span> length = <span class="number">0</span>;</div><div class="line">	<span class="comment">//拿到file文件夹下的所有路径,存入File数组</span></div><div class="line">	File[] subFiles = file.listFiles();</div><div class="line">	<span class="comment">//遍历前必加的判断</span></div><div class="line">	<span class="keyword">if</span> (subFiles != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//遍历</span></div><div class="line">		<span class="keyword">for</span>(File subFile : subFiles)&#123;</div><div class="line">			<span class="keyword">if</span> (subFile.isFile()) &#123; <span class="comment">//如果是文件</span></div><div class="line">				<span class="comment">//length加上文件的大小</span></div><div class="line">				length += subFile.length();</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(subFile.isDirectory())&#123; <span class="comment">//如果是文件夹</span></div><div class="line">				<span class="comment">//递归调用统计大小的方法。将统计好的字节数和之前方法统计好的进行累加</span></div><div class="line">				<span class="comment">//这步很容易忽视length+= ,切记</span></div><div class="line">				<span class="comment">//其他计数问题, 道理类似时, 别忽视这个点</span></div><div class="line">				length += getDirLength(subFile);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> length;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 获得一个文件夹路径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getDir</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//创建输入对象</span></div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	<span class="comment">//直到录入正确为止,设置死循环,当录入正确时, 跳出循环</span></div><div class="line">	System.out.println(<span class="string">"请输入一个文件夹路径: "</span>);</div><div class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">		String path = sc.next();</div><div class="line">		<span class="comment">//将一个String类型的路径封装成File型</span></div><div class="line">		File file = <span class="keyword">new</span> File(path);</div><div class="line">		<span class="comment">//判断File路径是否存在</span></div><div class="line">		<span class="keyword">if</span> (!file.exists()) &#123;</div><div class="line">			System.out.println(<span class="string">"您录入的路径不存在,请重新录入: "</span>);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</div><div class="line">			System.out.println(<span class="string">"你录入的路径是文件路径,请重新录入: "</span>);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> file;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	File file = <span class="keyword">new</span> File(<span class="string">"D:\\demo1"</span>);</div><div class="line">	<span class="keyword">int</span> count = getHiddenCount(file);</div><div class="line">	System.out.println(count);</div><div class="line">	</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 统计D盘下有多少个隐藏的文件夹(包括子文件夹)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHiddenCount</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="comment">//拿出路径下所有文件 存入File型数组中</span></div><div class="line">	File[] subFiles = file.listFiles();</div><div class="line">	<span class="comment">//遍历</span></div><div class="line">	<span class="keyword">if</span> (subFiles != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">for</span>(File subFile : subFiles)&#123;</div><div class="line">			<span class="comment">//思路一:</span></div><div class="line">			<span class="comment">//如果是文件夹且是隐藏的,计数器+1,然后进入隐藏文件夹继续统计</span></div><div class="line">			<span class="comment">//别忘记要count+= ,之前统计好的要加上</span></div><div class="line">			<span class="keyword">if</span> (subFile.isDirectory() &amp;&amp; subFile.isHidden()) &#123;</div><div class="line">				count++;</div><div class="line">				count += getHiddenCount(subFile);</div><div class="line">			<span class="comment">//如果不是隐藏的,但却是文件夹,也要进行统计,也是别忽视了count+=</span></div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (subFile.isDirectory()) &#123;</div><div class="line">				count += getHiddenCount(subFile);</div><div class="line">			&#125;</div><div class="line">			<span class="comment">/*思路二:</span></div><div class="line">				//如果当前内容是文件夹的话</div><div class="line">				if(subFile.isDirectory()) &#123;</div><div class="line">					//递归调用</div><div class="line">					count += getHiddenCount(subFile);</div><div class="line">					//如果是文件夹、并且是隐藏的</div><div class="line">					if(subFile.isDirectory() &amp;&amp; subFile.isHidden()) &#123;</div><div class="line">						//计数器自增</div><div class="line">						count++;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			*/</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.<br>做法一:(我的第一遍做法)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//获得两个文件夹路径</span></div><div class="line">	File file1 = getDirPath();</div><div class="line">	File file2 = getDirPath();</div><div class="line">	<span class="keyword">if</span>(file1.equals(file2))&#123;</div><div class="line">		System.out.println(<span class="string">"源文件夹是目标文件的子文件夹！无法复制。"</span>);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="comment">//一个文件夹中(包含内容)拷贝到另一个文件夹中</span></div><div class="line">		copyDirToOther(file1,file2);</div><div class="line">		System.out.println(<span class="string">"拷贝完成!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 一个文件夹中(包含内容)拷贝到另一个文件夹中</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyDirToOther</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//将file1文件夹内所有内容封装到File类型数组中</span></div><div class="line">	File[] subFiles = file1.listFiles();</div><div class="line">	<span class="comment">//遍历files文件夹</span></div><div class="line">	<span class="keyword">if</span> (subFiles != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">for</span>(File subFile : subFiles)&#123;</div><div class="line">			<span class="keyword">if</span> (subFile.isFile()) &#123;<span class="comment">//如果是文件</span></div><div class="line">				String path = file2.toString()+ <span class="string">"\\"</span>+ subFile.getName();</div><div class="line">				File file = <span class="keyword">new</span> File(path);</div><div class="line">				file.createNewFile();</div><div class="line">				<span class="comment">//创建字节流对象</span></div><div class="line">				FileInputStream fis = <span class="keyword">new</span> FileInputStream(subFile);</div><div class="line">				FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(path));</div><div class="line">				<span class="comment">//创建字节数组作为缓冲</span></div><div class="line">				<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">				<span class="comment">//定义变量接收read返回值</span></div><div class="line">				<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">				<span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</div><div class="line">					fos.write(bytes, <span class="number">0</span>, len);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//释放资源</span></div><div class="line">				fis.close();</div><div class="line">				fos.close();</div><div class="line">				</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (subFile.isDirectory()) &#123; <span class="comment">//如果是文件夹</span></div><div class="line">				String path = file2.toString()+ <span class="string">"\\"</span>+ subFile.getName();</div><div class="line">				File file = <span class="keyword">new</span> File(path);</div><div class="line">				file.mkdirs();</div><div class="line">				copyDirToOther(subFile,<span class="keyword">new</span> File(path));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回一个文件夹路径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getDirPath</span><span class="params">()</span> </span>&#123;</div><div class="line">	System.out.println(<span class="string">"请输入一个文件夹路径:"</span>);</div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	String dir = <span class="string">""</span>;</div><div class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">		dir = sc.next();</div><div class="line">		File file = <span class="keyword">new</span> File(dir);</div><div class="line">		<span class="keyword">if</span> (!file.exists()) &#123;</div><div class="line">			System.out.println(<span class="string">"传入的路径不存在,请重新输入一个文件夹路径:"</span>);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</div><div class="line">			System.out.println(<span class="string">"传入的路径是文件路径,请输入一个文件夹路径:"</span>);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> file;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法二: 使用小数组缓冲<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyDirToOther</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//将file1文件夹内所有内容封装到File类型数组中</span></div><div class="line">	File[] subFiles = file1.listFiles();</div><div class="line">	<span class="comment">//遍历files文件夹</span></div><div class="line">	<span class="keyword">if</span> (subFiles != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">for</span>(File subFile : subFiles)&#123;</div><div class="line">			<span class="keyword">if</span> (subFile.isFile()) &#123;<span class="comment">//如果是文件</span></div><div class="line">				<span class="comment">//创建字节流对象</span></div><div class="line">				FileInputStream fis = <span class="keyword">new</span> FileInputStream(subFile);</div><div class="line"><span class="comment">//这里注意一下,FileOutputStream构造方法FileOutputStream(File file)中,如果传一个File型文件路径,如果文件不存在,会自动创建</span></div><div class="line"><span class="comment">//File构造方法File(File parent, String child) ,传递File型父路径,String型子路径,可以实现自动拼接为完整File类型路径</span></div><div class="line">				FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(file2, subFile.getName()));</div><div class="line">				<span class="comment">//创建字节数组作为缓冲</span></div><div class="line">				<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">				<span class="comment">//定义变量接收read返回值</span></div><div class="line">				<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">				<span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</div><div class="line">					fos.write(bytes, <span class="number">0</span>, len);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//释放资源</span></div><div class="line">				fis.close();</div><div class="line">				fos.close();</div><div class="line">				</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (subFile.isDirectory()) &#123; <span class="comment">//如果是文件夹</span></div><div class="line">			<span class="comment">//File构造方法中,有传递父路径与子路径参数的方法,返回值就是将路径封装成File类型</span></div><div class="line">				File file = <span class="keyword">new</span> File(file2, subFile.getName());</div><div class="line">				<span class="comment">//创建文件夹</span></div><div class="line">				file.mkdirs();</div><div class="line">				<span class="comment">//递归调用copy方法</span></div><div class="line">				copyDirToOther(subFile,file);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法三: 使用字节缓冲流+小数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyDirToOther</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//将file1文件夹内所有内容封装到File类型数组中</span></div><div class="line">	File[] subFiles = file1.listFiles();</div><div class="line">	<span class="comment">//遍历files文件夹</span></div><div class="line">	<span class="keyword">if</span> (subFiles != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">for</span>(File subFile : subFiles)&#123;</div><div class="line">			<span class="keyword">if</span> (subFile.isFile()) &#123;<span class="comment">//如果是文件</span></div><div class="line">				<span class="comment">//创建字节缓冲流对象</span></div><div class="line">				BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(subFile));</div><div class="line">				BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(file2,subFile.getName())));</div><div class="line">				<span class="comment">//创建字节数组作为缓冲</span></div><div class="line">				<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  <span class="comment">//使用缓冲流+小数组的形式, 1024时速度最佳</span></div><div class="line">				<span class="comment">//定义变量接收read返回值</span></div><div class="line">				<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">				<span class="keyword">while</span>((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</div><div class="line">					bos.write(bytes, <span class="number">0</span>, len);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//释放资源</span></div><div class="line">				bis.close();</div><div class="line">				bos.close();</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (subFile.isDirectory()) &#123; <span class="comment">//如果是文件夹</span></div><div class="line">				<span class="comment">//File构造方法中,有传递父路径与子路径参数的方法,返回值就是将路径封装成File类型</span></div><div class="line">				File file = <span class="keyword">new</span> File(file2, subFile.getName());</div><div class="line">				<span class="comment">//创建文件夹</span></div><div class="line">				file.mkdirs();</div><div class="line">				<span class="comment">//递归调用copy方法</span></div><div class="line">				copyDirToOther(subFile,file);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.<br>做法一:使用字符输出流,因为可以写字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(<span class="keyword">int</span>[] arr, File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//创建输出流对象</span></div><div class="line">	FileWriter fw = <span class="keyword">new</span> FileWriter(file);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">		fw.write(arr[i]+<span class="string">" "</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//关闭流</span></div><div class="line">	fw.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做法二:使用字节输出流,但要使用getBytes()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(<span class="keyword">int</span>[] arr, File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">//创建输出流对象</span></div><div class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">	<span class="comment">//getBytes()可以将字符串先编码,再解码,比如写入78,文件中查看也是78</span></div><div class="line">		fos.write((arr[i]+<span class="string">" "</span>).getBytes());</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//关闭流</span></div><div class="line">	fos.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	System.out.println(<span class="string">"请输入源文件夹:"</span>);</div><div class="line">	File src = getDir();</div><div class="line">	System.out.println(<span class="string">"请输入目的文件夹:"</span>);</div><div class="line">	File desc = getDir();</div><div class="line">	copyJava(src,desc);</div><div class="line">	System.out.println(<span class="string">"复制成功"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 使用缓冲流将第一个文件夹中的所有.java文件复制到第二个文件夹中</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyJava</span><span class="params">(File src, File dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 分析:操作的是文本文件,使用字符缓冲流</div><div class="line">	 */</div><div class="line">	<span class="comment">//1.将数据源下的所有内容,封装到File数组中</span></div><div class="line">	File[] subFiles = src.listFiles();</div><div class="line">	<span class="keyword">if</span> (subFiles != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//遍历:</span></div><div class="line">		<span class="keyword">for</span> (File subFile : subFiles) &#123;</div><div class="line">			<span class="keyword">if</span> (subFile.isFile() &amp;&amp; subFile.getName().toLowerCase().endsWith(<span class="string">".java"</span>)) &#123;</div><div class="line">				<span class="comment">//创建字符缓冲流</span></div><div class="line">				BufferedReader bfr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(subFile));</div><div class="line">				BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(dest, subFile.getName())));</div><div class="line">				String line = <span class="keyword">null</span>;</div><div class="line">				<span class="keyword">while</span>((line = bfr.readLine()) != <span class="keyword">null</span>)&#123;</div><div class="line">					bfw.write(line);</div><div class="line">					bfw.newLine();</div><div class="line">					bfw.flush();</div><div class="line">				&#125;</div><div class="line">				bfw.close();</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (subFile.isDirectory()) &#123;</div><div class="line">				<span class="comment">//如果文件夹内没有java文件,则不创建该文件夹</span></div><div class="line">				<span class="comment">//返回true,代表有java文件</span></div><div class="line">				<span class="keyword">if</span> (myCompare(subFile)) &#123;</div><div class="line">					File newDir = <span class="keyword">new</span> File(dest, subFile.getName());</div><div class="line">					newDir.mkdirs();</div><div class="line">					copyJava(subFile,newDir);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 判断当前文件夹下有无java文件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">myCompare</span><span class="params">(File subFile)</span> </span>&#123;</div><div class="line">	<span class="comment">//1.获取传入文件夹下所有的内容</span></div><div class="line">	File[] subFiles = subFile.listFiles();</div><div class="line">	<span class="keyword">if</span> (subFiles != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//2.遍历文件数组，拿到每一个元素(有可能是文件、有可能文件夹)</span></div><div class="line">		<span class="keyword">for</span> (File file : subFiles) &#123;</div><div class="line">			<span class="comment">//3.如果当前元素是文件、并且是符合条件的文件   那么直接返回true</span></div><div class="line">			<span class="keyword">if</span> (file.isFile() &amp;&amp; file.getName().toLowerCase().endsWith(<span class="string">".java"</span>)) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory()) &#123;</div><div class="line">				<span class="comment">//4.如果当前元素是文件夹、继续递归调用myCompare方法</span></div><div class="line">				<span class="keyword">boolean</span> b = myCompare(file);</div><div class="line">				<span class="keyword">if</span> (b == <span class="keyword">false</span>) &#123; <span class="comment">//当前文件夹没有java文件的话,继续遍历subFiles的其他文件</span></div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				&#125;<span class="keyword">else</span>&#123;</div><div class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回一个文件夹路径</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getDir</span><span class="params">()</span> </span>&#123;</div><div class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">		File file = <span class="keyword">new</span> File(sc.next());</div><div class="line">		<span class="keyword">if</span> (!file.exists()) &#123;</div><div class="line">			System.out.println(<span class="string">"您输入的路径不存在,请重新输入"</span>);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</div><div class="line">			System.out.println(<span class="string">"您输入的路径是文件路径,请重新输入"</span>);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> file;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.创建字符输出缓冲流</span></div><div class="line">BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"D:\\count.txt"</span>));</div><div class="line"><span class="comment">//定义字符串</span></div><div class="line">String str = <span class="string">"If you want to change your fate I think you must come here to learn java"</span>;</div><div class="line"><span class="comment">//2.将字符串切割,将元素装入一个字符串数组</span></div><div class="line">String[] strArr = str.split(<span class="string">" +"</span>);</div><div class="line"><span class="comment">//3.创建双列集合,数组元素做键,个数做值,保证键的不重复</span></div><div class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</div><div class="line"><span class="comment">//4.遍历字符串数组,判断双列集合中是否含该键,有的话,当前个数加1,没有的话,个数为1</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArr.length; i++) &#123;</div><div class="line">	<span class="keyword">if</span> (map.containsKey(strArr[i])) &#123;</div><div class="line">		map.put(strArr[i],map.get(strArr[i])+<span class="number">1</span>);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		map.put(strArr[i],<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">//遍历双列集合</span></div><div class="line">Set&lt;String&gt; mapSet = map.keySet();</div><div class="line"><span class="keyword">for</span> (String string : mapSet) &#123;</div><div class="line">	<span class="keyword">int</span> count = map.get(string);</div><div class="line">	bfw.write(string+<span class="string">"="</span>+count);</div><div class="line">	<span class="comment">//换行</span></div><div class="line">	bfw.newLine();</div><div class="line">	<span class="comment">//刷新</span></div><div class="line">	bfw.flush();</div><div class="line">&#125;</div><div class="line"><span class="comment">//关闭流对象</span></div><div class="line">bfw.close();</div></pre></td></tr></table></figure></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> allCount = <span class="number">100</span>;</div><div class="line">	<span class="comment">//定义实体店售卖个数</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count1 = <span class="number">0</span>;</div><div class="line">	<span class="comment">//定义官网售卖个数</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//循环打印,设置死循环</span></div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="comment">//同步代码块包住共享数据allCount</span></div><div class="line">			<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">				<span class="comment">//个数为0,break;</span></div><div class="line">				<span class="keyword">if</span> (allCount &lt;= <span class="number">0</span>) &#123;<span class="comment">//0处</span></div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//个数大于0</span></div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">100</span>);</div><div class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"卖出第"</span>+(<span class="number">100</span>-allCount+<span class="number">1</span>)+<span class="string">"个,总共剩余"</span>+--allCount+<span class="string">"个"</span>);</div><div class="line">					<span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"实体店"</span>)) &#123;</div><div class="line">						count1++;</div><div class="line">						<span class="keyword">this</span>.notify();<span class="comment">//唤醒官网线程</span></div><div class="line">						<span class="keyword">this</span>.wait();<span class="comment">//实体店线程等待, 注意最后一次,如果是实体点卖出最后一个包,当前allCount为0</span></div><div class="line">						<span class="comment">//执行这一步后,实体店线程进入等待,唤醒了官网,官网线程执行1处,打印总共卖的个数</span></div><div class="line">						<span class="comment">//当前实体店线程还在等待,程序并未停止,所以要唤醒所有线程</span></div><div class="line">						<span class="comment">//allCount--的原因:唤醒实体店线程后,实体店线程从等待处唤醒并开始执行,即本句</span></div><div class="line">						<span class="comment">//并没有运行0处,并没有break,所以如果allCount没有减减,allCount还等于0,还会执行1处</span></div><div class="line">						<span class="comment">//打印一遍总共售卖信息,所以--后,allCOunt = -1,就不执行1处了,只打印一遍</span></div><div class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"官网"</span>)) &#123;</div><div class="line">						count2++;</div><div class="line">						<span class="keyword">this</span>.notify();</div><div class="line">						<span class="keyword">this</span>.wait();</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (allCount == <span class="number">0</span>) &#123;<span class="comment">//1处</span></div><div class="line">					System.out.println(<span class="string">"实体店总共卖了"</span>+count1+<span class="string">"个"</span>);</div><div class="line">					System.out.println(<span class="string">"官网总共卖了"</span>+count2+<span class="string">"个"</span>);</div><div class="line">					<span class="keyword">this</span>.notifyAll();</div><div class="line">					allCount--;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SubRunnable sr = <span class="keyword">new</span> SubRunnable();</div><div class="line">		<span class="keyword">new</span> Thread(sr, <span class="string">"实体店"</span>).start();</div><div class="line">		<span class="keyword">new</span> Thread(sr, <span class="string">"官网"</span>).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础题目]]></title>
      <url>https://geekhoon.github.io/2017/01/09/%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</url>
      <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre><code>1. JAVA语言中的字符char可以存储一个中文汉字吗?原因?
</code></pre><a id="more"></a>       
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><pre><code>1. 请写出该输出语句的结果

System.out.println(&quot;hello&quot;+(&apos;a&apos;+1));

2. 请分别计算出a,b,c的值? 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">15</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">15</span>;</div><div class="line"><span class="keyword">int</span> c = <span class="number">15</span>;</div><div class="line"></div><div class="line">a = ++b;		</div><div class="line">c = a--;			</div><div class="line">b = ++a;		</div><div class="line">a = c--;</div></pre></td></tr></table></figure>
<pre><code>3. 分析以下需求，并用代码实现：  
    (1)已知一个三位数，请分别获取该三位数上每一位的数值
    (2)例如：123的个位、十位、百位，分别是3、2、1
    (3)打印格式&quot;数字123的个位是 3, 十位是 2, 百位是 1&quot;
</code></pre><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><pre><code>1. 计算1-100之间的质数有多少个？将质数以及质数总数打印在控制台。每5个数换行

2. 我国最高山峰是珠穆朗玛峰，8848米。现在我有一张足够大的纸，它的厚度是0.01米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度。

3. 分析以下需求，并用代码实现：
    打印1到100之内的整数，但数字中包含9的要跳过
    每行输出5个满足条件的数，之间用空格分隔。如：1 2 3 4 5 

4. 利用嵌套循环，在控制台打印九九乘法表
</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code>1. 分析以下需求，并用代码实现：
    (1)定义一个int类型的一维数组，内容为{6,2,9,15,1,5,20,7,18}
    (2)将数组最大元素与最后一位元素进行交换,最小元素与第一位元素进行交换，并打印数组

2. 分析以下需求，并用代码实现：
    (1)键盘录入6个int类型的数据存数数组arr中
    (2)将arr数组中的内容反转(逆序)
    (3)将翻转后的数组角标为奇数的互相交换 1和3换, 3和5换,以此类推
    (4)最后将数组最后一个角标为奇数的元素 和数组中第一个角标为奇数的元素交换
    (5)打印最终的数组(实现了1-4步之后的数组)
    (6)如：用户输入的6个int数字为[1,2,3,4,5,6],最后输出的结果为[6, 5, 4, 1, 2, 3]
</code></pre><h3 id="ASCII编码及char类型的存储"><a href="#ASCII编码及char类型的存储" class="headerlink" title="ASCII编码及char类型的存储"></a>ASCII编码及char类型的存储</h3><pre><code>* American Standard Code for Information Interchange，美国标准信息交换代码
     ASCII编码，统一规定了常用符号用哪些二进制数来表示。
        数字0-9对应ASCII编码十进制为48-57
        字母A-Z对应ASCII编码十进制为65-90
        字母a-z对应ASCII编码十进制为97-122

* 取值范围
    * short:占两个字节,是有符号数据,取值范围-32768-32767
    * char: 占两个字节,是无符号数据,取值范围0-65535
* 题目:
    输出所有英文字母
</code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><pre><code>1. Student类中有一个私有化空参构造方法, 写一个方法来new一个Student对象,且只能被创建一次
2.  请编写一个抽象类Phone,两个抽象方法,call()  sendMessage()
       两个子类OldPhone 和 NewPhone , 其中NewPhone想添加一个玩游戏的功能. 
       请根据接口的思想实现,并用匿名内部类的方式调用玩游戏的功能.
3. 局部内部类访问局部变量, 该局部变量必须使用哪个关键子修饰,为什么
4. 内部类完整测试,包括各种内部类类型,及使用public,默认类型,private,访问内部类方式
</code></pre><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre><code>1.分析以下需求，并用代码实现：
    (1)定义数字字符串数组{&quot;010&quot;,&quot;3223&quot;,&quot;666&quot;,&quot;7890987&quot;,&quot;123123&quot;}
    (2)判断该数字字符串数组中的数字字符串是否是对称(第一个数字和最后一个数字相等，第二个数字和倒数第二个数字是相等的，依次类推)的，并逐个输出
    (3)如：010 是对称的，3223 是对称的，123123 不是对称的
    (4)最终打印该数组中对称字符串的个数

    提示：循环获取字符串的每一个字符，依次比较第一个和最后一个，第二个和倒数第二个。。。
2.分析以下需求，并用代码实现：
    (1)从键盘循环录入录入一个字符串,输入&quot;end&quot;表示结束
    (2)将字符串中大写字母变成小写字母，小写字母变成大写字母，其它字符用&quot;*&quot;代替,并统计字母的个数
        举例:
            键盘录入：Hello12345World
            输出结果：hELLO*****wORLD
                      总共10个字母
3.分析以下需求，并用代码实现：
    (1)从键盘循环录入录入一个字符串,输入&quot;end&quot;表示结束
    (2)定义一个方法
        public Object[] deleteSubString(String str1,String str2) {

        }
    (3)方法功能描述:从str1中删除所有的str2,并返回删除后的结果,返回结果为Object[]数组
        * 该数组的第一个元素为删除所有的str2后的最终的字符串
        * 该数组的第二个元素为删除的str2的个数    
4.关于String类的练习题，分析运行结果？
public class Test01 {    
    public static void main(String[] args) {
        //demo1();
        //demo2();
        //demo3();
        //demo4();
        demo5();
    }
    private static void demo5() {
        String s1 = &quot;ab&quot;;
        String s2 = &quot;abc&quot;;
        String s3 = s1 + &quot;c&quot;;       //只要是变量+ 字符串 ,就会创建一个新对象
        System.out.println(s3 == s2);        //flase
        System.out.println(s3.equals(s2));         //
    }
    private static void demo4() {
        //byte b = 3 + 4;                        //在编译时就变成7,把7赋值给b,常量优化机制
        String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;//java中有常量优化机制,在编译时期就能确定s2的值为&quot;abc&quot;,所以编译时期,在常量池中创建&quot;abc&quot;
        String s2 = &quot;abc&quot;;//执行到这里时常量池中已经有了&quot;abc&quot;,所以就不再创建,所以s1和s2指向的是常量池中同一个字符串常量&quot;abc&quot;
        System.out.println(s1 == s2);             //java中有常量优化机制    
        System.out.println(s1.equals(s2));         //
    }
    private static void demo3() {//==比较的是地址值
        String s1 = new String(&quot;abc&quot;);            //录的是堆内存对象的地址值        
        String s2 = &quot;abc&quot;;                        //记录的是常量池中的地址值
        System.out.println(s1 == s2);             //
        System.out.println(s1.equals(s2));         //
    }
    private static void demo2() {
        //创建几个对象
        //创建两个对象,一个在常量池中,一个在堆内存中
        String s1 = new String(&quot;abc&quot;);        
        System.out.println(s1);
    }
    private static void demo1() {                //常量池中没有这个字符串对象,就创建一个,如果有直接用即可
        String s1 = &quot;abc&quot;;
        String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);             //==号比较的是地址值
        System.out.println(s1.equals(s2));         //比较的是字符串的内容:
    }
}
5.用循环实现不死神兔
    故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。
    在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔，
    再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡，
    问：一对刚出生的兔子，第100个月繁殖多少对兔子?(利用BigInteger完成)
     1 1 2 3 5 8 13 21    
     0 1 2 3 4 5  6  7  
6.去除给定的参数字符串中的重复字符（重复字符只保留一个），将新的字符串返回
</code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><pre><code>1.生成10个1至100之间的随机整数(不能重复)，存入一个List集合
2.定义一个方法，从控制台获取用户输入的3个任意0-9之间的数字(3个数字不重复),并将其拼接为完全不重复的三位数。
  统计一共多少种组合、并且将每种组合进行排序输出。
3.有如下代码：
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;b&quot;);
        list.add(&quot;f&quot;);
        list.add(&quot;e&quot;);
        list.add(&quot;c&quot;);
        list.add(&quot;a&quot;);
        list.add(&quot;d&quot;);
        定义sort方法。对集合内容排序
        sort(list);
        System.out.println(list);    // a, b, c, d, e, f
4.完成如下需求：
    1、创建一个Person类。属性：姓名、年龄  生成对应的方法
    2、创建一个测试类，在测试类中创建四个Person对象。姓名和年龄要求通过键盘录入(至少录入一个相同的姓名和年龄)。
    3、将四个Person对象存储到一个List集合中，并打印集合
    4、要求通过Set集合对List集合进行去除重复。打印去重后的List集合(按照年龄从大到小的顺序打印)
5.一个小写的字符串,替换字符串中字母，然后输出
              a 替换成 b
              b 替换成 c
              .....
            z 替换成 a
6.随机生成8个1-100之间的奇数，存放到合适的集合中
7.有如下代码：
    public static void main(String[] args) {
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;a&quot;);
        list.add(&quot;f&quot;);
        list.add(&quot;b&quot;);
        list.add(&quot;c&quot;);
        list.add(&quot;a&quot;);
        list.add(&quot;d&quot;); 
    }
    利用HashSet对list集合去重(最终结果:list中没有重复元素)
8.ArrayList嵌套ArrayList
9.按需求完成指定功能，题目如下：
    产生10个长度为10的字符串，并遍历打印输出
    要求：
     1.每个字符串中只能包含大写字母或者小写字母或者0-9的数字
     2.每个字符串中的10个字符不能重复
     3.10个字符串也不能重复
10.按需求完成指定功能，题目如下：
    定义一个List集合,泛型为String类型。统计整个集合中所有字符（注意，不是字符串）的个数。例如：    
    集合中有”abc”、”bcd”两个元素
    程序最终输出结果为:
    a = 1
    b = 2
    c = 2
    d = 1
11.按需求完成指定功能，题目如下：
    有四种水果(苹果，香蕉，西瓜，橘子)
     1、给每种水果设定一个商品号，商品号是8个0-9的随机数，商品号码不能重复
     2、根据商品号查询对应的商品。
    如果查不到输出：“查无此商品”
    如果能查到打印：”根据商品号：12345678，查询到对应的商品为：西瓜”
</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><pre><code>1.键盘录入一个int类型的整数,对其求二进制表现形式
       要求使用捕获异常的方式对录入的数据进行判断
     * 如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数
     * 如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数
     * 如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数
</code></pre><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><pre><code>1.从键盘接收一个文件夹路径(录入的有可能是文件路径或者文件夹路径不存在，要进行判断)。
    直到录入正确为止,统计该文件夹大小。
2.统计D盘下有多少个隐藏的文件夹(包括子文件夹)
3.从键盘接收两个文件夹路径,把其中一个文件夹中(包含内容)拷贝到另一个文件夹中
4.该int数组中的数字写入到本地文件number.txt中
5.从键盘录入两个文件夹路径，要判断是否符合是文件夹路径
    使用缓冲流将第一个文件夹中的所有.java文件复制到第二个文件夹中
    如果其中的某个文件夹内没有java文件,则不创建这个文件夹
6.用代码实现以下需求
    (1)有如下字符串&quot;If you want to change your fate I think you must come here to learn java&quot;(用空格间隔)
    (2)打印格式：
        to=3
        think=1
        you=2
        //........
    (3)按照上面的打印格式将内容写入到D:\\count.txt文件中(要求用高效流)
</code></pre><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><pre><code>1.有100个限量版的包包，但是只能通过实体店和官网才能进行购买
    (1)请用线程进行模拟并设置线程名称用来代表售出途径，再将信息打印出来。 比如（实体店卖出第1个，总共剩余n个..）,要求交替打印
    (2)并且分别统计卖了多少个。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用快捷键]]></title>
      <url>https://geekhoon.github.io/2017/01/09/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<h3 id="1-Dos"><a href="#1-Dos" class="headerlink" title="1.Dos"></a>1.Dos</h3><pre><code>* Shift + 右键    : 当前文件夹下打开dos
* Tab             : 注意dos下,&quot;Tab键&quot;的使用,可方便输入
* 标记 + 右键/回车 : dos下复制
* &quot;↑&quot;和&quot;↓&quot;        : dos未关闭前提下,使用之前的命令
* 复制路径后,dos下右键,可以粘贴
* Ctrl + c        :强行停止命令行
</code></pre><a id="more"></a>
<h3 id="2-notepad"><a href="#2-notepad" class="headerlink" title="2.notepad++"></a>2.notepad++</h3><pre><code>* Ctrl + D           : 复制该行
* Ctrl + Shift + ↑/↓ :移动该行
* Ctrl + L           : 删除该行
* shift + Tab        :选中部分整体左移
* tab                 :选中部分整体右移
* Ctrl + Q           : 注释/取消 单行注释
</code></pre><h3 id="3-xmind"><a href="#3-xmind" class="headerlink" title="3.xmind"></a>3.xmind</h3><pre><code>* Tab : 新建分支
*  F4 : 添加备注
</code></pre><h3 id="4-eclipse"><a href="#4-eclipse" class="headerlink" title="4.eclipse"></a>4.eclipse</h3><pre><code>* Ctrl + /          :单行注释
* Ctrl + Shift + /  :多行注释
* Ctrl + Shift + \  :取消多行注释
* Alt  + /            :自动补全
* Ctrl + 1            :快速修复
* Ctrl + D            :删掉当前行
* Ctrl+Alt+↓        :复制当前行到下一行(复制增加)
* Ctrl+Alt+↑         :复制当前行到上一行(复制增加)
* Alt+↓             :当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)
* Alt+↑             :当前行和上面一行交互位置(同上)
* Ctrl+T            :选择一个类, 显示当前类的继承结构
* Ctrl+Shift+F        :格式化当前代码
* Ctrl+点击 / F3        :查看源码
* Ctrl+Shift+S        :生成构造方法,get/set
* Ctrl+Shift+O        :导包
* Ctrl+2(松手) 再L    :写完方法后,自动接收返回值
* Alt+Shift+R        :统一修改同名变量名
* Alt+Shift+M        :选择一段代码封装成方法
* Alt+Shift+Z        :选择一段代码添加try/catch
* Alt+Shift+ ←/→    :快速选中一行
* Ctrl + F11        :运行
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[04.运算符]]></title>
      <url>https://geekhoon.github.io/2017/01/08/04-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><pre><code>* 注意事项
    1.&quot;+&quot;在连接字符串时要注意，只有直接与字符串相加才会转成字符串.
        字符串后面的&quot;+&quot;为&quot;连接&quot;,字符串前面的&quot;+&quot;还是加法
        如:
            System.out.println(5+5+&quot;=&quot;+5+5);这个输出的是10=55
    2.&quot;/&quot;除法运算符,整数与整数除,结果为整数;整数与小数除,结果是小数类型
</code></pre><a id="more"></a>
<pre><code>    3.&quot;%&quot;取模,取余运算符
              -5  % 5 = 0;
              -10 % 5 = 0;
              -7  % 5 = -2;
               10 % 5 = 0;
               2  % 5 = 2;
              -2  % 5 = -2;
        结论:
        (1)正负符号位取得是左边,与右边无关
        (2)如果左边的绝对值是右边绝对值的整数倍,结果为0
        (3)如果左边的绝对值大于右边的绝对值,结果为余数(正常取余就行,注意正负号)
        (4)如果左边的绝对值小于右边的绝对值,结果为左边
        (5)任何一个整数%2,结果不是0就是1,可以用来当作切换条件

* ++和--放前放后区别:
    *符号放前放后,在变量自己独立计算时,没有区别
    *在与其他运算符同时计算时会有区别             
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">    <span class="keyword">int</span>  i = <span class="number">5</span>;</div><div class="line">    <span class="keyword">int</span>  j = i++;</div><div class="line">    System.out.println(i);</div><div class="line">    System.out.println(j);</div><div class="line">	<span class="comment">//结果为i=6,j=5.</span></div><div class="line">	<span class="comment">//因为int  j = i++;相当于(1)int j = i;(2)i++;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">    <span class="keyword">int</span>  m = <span class="number">5</span>;</div><div class="line">    <span class="keyword">int</span>  n = ++m;</div><div class="line">    System.out.println(m);</div><div class="line">    System.out.println(n);</div><div class="line">	<span class="comment">//结果为m=6,n=6.</span></div><div class="line">	<span class="comment">//因为int  n = ++m;相当于(1)++m;(2)int n = m;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> 			<span class="keyword">int</span> x = <span class="number">4</span>;</div><div class="line"> 			<span class="keyword">int</span> y = (--x)+(x--)+(x*<span class="number">10</span>);</div><div class="line"> 			System.out.println(<span class="string">"x = "</span> + x + <span class="string">",y = "</span> + y);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"><span class="comment">//思维误区:不要以为(--x)+(x--)+(x*10),都有各自括号,就互不影响</span></div><div class="line"><span class="comment">//执行完(--x),x为3,再执行(x--)后,x为2,(x*10)为20,所以输出x为2,但是y=3+3+20=26,第二个3是因为先赋值,再自减</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">			<span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">			<span class="keyword">if</span>(a++ &gt; <span class="number">1</span>)&#123;</div><div class="line">				System.out.println(<span class="string">"用2在判断"</span>);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				System.out.println(<span class="string">"用1在判断"</span>);</div><div class="line">			&#125;</div><div class="line">			System.out.println(<span class="string">"a="</span>+a);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"><span class="comment">//本题证明了(a++ &gt; 1)是用a=1与1做大小判断,而不是2,说明a先比较,再自增.但最终输出a的大小都是2</span></div></pre></td></tr></table></figure>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><pre><code>* 有 =  +=  -=  *=  /=  %=  
* 注意:
     如：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	 <span class="keyword">byte</span>  b = <span class="number">1</span>;               <span class="comment">//(1)</span></div><div class="line">	 b = b + <span class="number">1</span>;                 <span class="comment">//(2)</span></div><div class="line">	 System.out.println(b);     <span class="comment">//(3)</span></div><div class="line"><span class="comment">//编译会报错,因为(1)中b为byte型,占1个字节,(2)中1为int类型,占4个字节,它们相加之后,是4字节.然后赋值给1字节大小的b,会损失精度.</span></div><div class="line"><span class="comment">//将(2)改成b =(byte) (b + 1);或者b += 1;都对.这两句等价</span></div></pre></td></tr></table></figure>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><pre><code>* 也叫关系运算符
* 有 ==  !=  &gt;  &lt;  &gt;=  &lt;=  
* 注意:
     如：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">int</span>  i = <span class="number">3</span>;</div><div class="line">   <span class="keyword">int</span>  j = <span class="number">4</span>;</div><div class="line">   System.out.println(i=j);</div><div class="line">   System.out.println(i==j);</div><div class="line"><span class="comment">//结果分别为4和true,因为程序自上而下执行,第一句输出语句执行完之后,i变为4.别忽视了输出语句中,赋值语句对变量在整个作用区间内也起作用.</span></div></pre></td></tr></table></figure>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><pre><code>* 对两个布尔数据进行计算,结果也是布尔类型
* 有 &amp;与  |或  !非  ^异或  &amp;&amp;短路与  ||短路或
    *^异或: 两边相同为false,不同为true
     如：
                true^flase 为    true 
                true^true  为   false
    *&amp;&amp;短路与: 左边结果为false,右边不执行
     如：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">int</span>  i = <span class="number">3</span>;</div><div class="line">   <span class="keyword">int</span>  j = <span class="number">4</span>;</div><div class="line">   System.out.println(i == j &amp;&amp; ++i &gt; <span class="number">3</span>);</div><div class="line">   System.out.println(i);</div><div class="line">   System.out.println(j);</div><div class="line"><span class="comment">//结果为3和4.   i == j 为flase, 所以++i &gt; 3并没有执行</span></div></pre></td></tr></table></figure>
<pre><code>*||短路或: 左边结果为true,右边不执行
* 短路与 和 短路或 可以提高程序运行效率
</code></pre><h3 id="三元-目-运算符"><a href="#三元-目-运算符" class="headerlink" title="三元(目)运算符"></a>三元(目)运算符</h3><pre><code>* 公式:    布尔表达式 ? 结果1 : 结果2
*注意:这里的结果1和2,不能是输出语句,必须是确定的结果
</code></pre><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><pre><code>优先级    描述          运算符
1    括号           ()、[]
2    正负号           +、-
3    自增自减，非     ++、--、!
4    乘除，取余      *、/、%
5    加减            +、-
6    移位运算       &lt;&lt;、&gt;&gt;、&gt;&gt;&gt;
7    大小关系       &gt;、&gt;=、&lt;、&lt;=
8    相等关系       ==、!=
9    按位与            &amp;
10    按位异或       ^
11    按位或            |
12    逻辑与            &amp;&amp;
13    逻辑或            ||
14    条件运算        ?:
15    赋值运算        =、+=、-=、*=、/=、%=
16    位赋值运算       &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[03.数据]]></title>
      <url>https://geekhoon.github.io/2017/01/08/03-%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><pre><code>* 程序=数据+逻辑
* 数据类型包括 
    * 1.基本数据类型:整数、小数、字符、布尔 
    * 2.引用数据类型:数组、类、接口
</code></pre><a id="more"></a>
<h4 id="2-常量"><a href="#2-常量" class="headerlink" title="2.常量"></a>2.常量</h4><pre><code>* 程序在运行过程中,其值不会发生变化的量
* 整数类型 
    * 十进制
    * 二进制:以0b(0B)开头,只有0和1  
    * 十六进制:以0x(0X)开头,0-9和A-F,F表示15 
    * 八进制:以0开头,最大数为7
* 小数类型(浮点类型)
* 布尔类型:true和flase为关键字
* 字符类型:单引号中仅能包含一个字符,不能不写字符,可以用一个空格
* 字符串类型:可以写0-n个字符  
</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="1-变量概述"><a href="#1-变量概述" class="headerlink" title="1.变量概述"></a>1.变量概述</h4><pre><code>* 什么是变量?
    * 变量是内存中装载数据的小盒子，你只能用它来存数据和取数据
    * 在程序运行过程中,其值可以发生改变的量
</code></pre><h4 id="2-计算机存储单元"><a href="#2-计算机存储单元" class="headerlink" title="2.计算机存储单元"></a>2.计算机存储单元</h4><pre><code>* 计算机中最小信息单元是?
    * 位(bit),也叫比特位.用b表示
    * 8个位,表示一个数据
* 计算机中储存和运算的最小单位是?
    * 一个字节,也就是一个byte.用B表示            
    * 常用储存单位
        *1B（字节） = 8bit
        *1KB = 1024B
        *1MB = 1024KB
        *1GB = 1024MB
        *1TB = 1024GB
        *1PB = 1024TB
</code></pre><h4 id="3-Java中数据类型四类八种"><a href="#3-Java中数据类型四类八种" class="headerlink" title="3.Java中数据类型四类八种"></a>3.Java中数据类型四类八种</h4><pre><code>* 数据类型四类八种
    * 四类    八种    字节数    数据表示范围
    * 整型    byte    1    -128～127
            short     2    
             int     4    
             long     8    
    * 浮点型    float    4    
              double   8    
    * 字符型    char    2    表示一个字符，如(&apos;a&apos;，&apos;A&apos;，&apos;0&apos;，&apos;家&apos;)
    * 布尔型    boolean    1    只有两个值true与false,默认是false
</code></pre><h4 id="4-常量和数据类型"><a href="#4-常量和数据类型" class="headerlink" title="4.常量和数据类型"></a>4.常量和数据类型</h4><pre><code>* 常量
    * 常量是程序在运行过程中,其值不会发生改变的量
    * 整型常量默认是int类型.
    * 定义长整型数据如果值超过int取值范围后面要+&quot;L&quot;,凡添加了&quot;L&quot;,都是long类型
    * 浮点常量默认是double类型,没有后缀或以&quot;D&quot;为后缀,都是double型
    * 定义float类型的数据后面要+&quot;F&quot; 否则默认是double
* 写法:
    * long l = 1000; 对
    * long l = 12345678901; 错
    * long l = 12345678901L; 对 
    * float f = 1.0; 错
    * float f = 1.0F; 对
    * float f = 10; 对
</code></pre><h4 id="5-定义变量"><a href="#5-定义变量" class="headerlink" title="5.定义变量"></a>5.定义变量</h4><pre><code>* 语法格式：
    数据类型  变量名  =  变量值;
     int        a    =  100;        
* 代码:
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line">		<span class="keyword">double</span> b = <span class="number">3.14</span>;</div><div class="line">		<span class="keyword">char</span> c = <span class="string">'z'</span>;</div><div class="line">		String s = <span class="string">"i love java"</span>;</div><div class="line">		System.out.println(a);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>* 注意:
    a.字符串String属于引用类型(类),不属于基本类型,
    b.变量定义后,不赋值,能编译通过,但运行时会报错.不赋值不能使用。
    c.变量使用时有作用域的限制。(所在的大括号范围内)
    d.变量不允许重复定义
    如：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	    &#123;</div><div class="line">            <span class="keyword">int</span> j = <span class="number">10</span>;</div><div class="line">		&#125;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//这是对的,因为第一个j声明的作用区间为它所在的大括号,第二个j再声明,和它就不冲突</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="number">2</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> </span>&#123;</div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		    <span class="keyword">int</span> j = <span class="number">10</span>;  </div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> j = <span class="number">10</span>;</div><div class="line">			&#125;</div><div class="line"> &#125;</div><div class="line"><span class="comment">//这是错的,因为第一个j声明的作用区间为它所在的大括号,即整个main方法,第二个j再在main方法中声明,就产生了冲突</span></div></pre></td></tr></table></figure>
<h4 id="6-数据类型转换"><a href="#6-数据类型转换" class="headerlink" title="6.数据类型转换"></a>6.数据类型转换</h4><pre><code>* 自动类型转换：(也叫自动类型提升,或叫隐式转换)
    *取值范围小的与取值范围大的数据数据类型做运算时,取值范围小的类型会自动提升为取值范围大的数据类型
    *表示范围小的数据类型转换成范围大的数据类型,如byte转成int
    *自动类型转换格式：
        范围大的数据类型 变量 = 范围小的数据类型值；
        如：
                double d = 1000;
        或
                int i = 100;
                double d2 = i;
* 强制类型转换：
    * 表示范围大的数据类型转换成范围小的数据类型
     *强制类型转换格式：
        范围小的数据类型  变量 = (范围小的数据类型) 范围大的数据类型值;
        如：
                int  i = (int)6.718;   //i的值为6
        或
                double  d = 3.14;
                int  i2 = (int)d;     //i2的值为3
* 注意：
    *布尔类型不参与类型转换
    *byte &lt; short &lt; int &lt; long &lt; float &lt; double
    *
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)<span class="number">200</span>;</div><div class="line">System.out.println(b);<span class="comment">//注意输出结果不是127,因为会损失精度</span></div></pre></td></tr></table></figure>
<pre><code>*
    byte b = 10;这是对的.不要以为10为int类型,赋值给byte就需要强制转换.   
    只要需要赋值的数据值,在byte范围(-128-127)内,就是对的,不需要强制转换.因为java中常量优化机制,只要在范围内自己转换
*
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b1=<span class="number">3</span>,b2=<span class="number">4</span>;</div><div class="line">   <span class="keyword">byte</span> b = b1+b2;<span class="comment">// 错</span></div></pre></td></tr></table></figure>
<pre><code>    因为b1和b2都是byte类型变量,在参加运算时要先转成int类型,所以b1+b2的结果为int类型,把int类型的数据赋值给byte类型的b,就会损失精度,导致编译报错
    byte b = 3+4;//对 
    解释一:3和4都是int类型的常量,java虚拟机有常量优化机制,编译时就能确实3+4的结果为7,然后把7赋值给byte类型的b,7正好在byte数据范围内,会有一个隐式类型转换,可以赋值成功
    解释二:给出了固定值,和不超过范围.由java底层常量优化机制,即可自动转换.如果是byte b = 300+4;那就错了
*
     char c = 98;这是对的,不要以为没加&apos;&apos;,就不是字符.由Ascii码表,只要数字范围i在(0-65535),就可以Ascii为单个字符
*
    long可以自动类型变换至float的原因: 
    (1)它们底层的存储结构不同
    (2)遵循IEEE-754格式标准,float类型的指数可从-126到128.float表示的数据范围比long型的范围要大
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[02.注释、关键字、标识符]]></title>
      <url>https://geekhoon.github.io/2017/01/08/02-%E6%B3%A8%E9%87%8A%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>* 编译时,编译器会忽略注释
* 包含
    * 单行注释:// 
    * 多行注释:/*....*/ 
    * 文档注释:/**...*/ 
* 多行注释不能嵌套多行注释
</code></pre><a id="more"></a>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><pre><code>* 被JAVA赋予特殊含义,具有专门用途的单词
* JAVA中关键字均为小写
* main不是关键字
</code></pre><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><pre><code>* JAVA中,程序员自己定义的内容
* 规则: 
    * 1.组成:字母52个(a-z,A-Z)、数字(0-9)、下划线_、美元符$
    * 2.注意:不能以数字开头、不能是关键字、标识符不能有空格、严格区分大小写
    * 3.类的名字:首字母大写,第二个单词开始首字母大写
    * 4.方法名字与变量名一样:首字母小写,第二个单词开始首字母大写 
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[01.JAVA开发概述及HelloWorld]]></title>
      <url>https://geekhoon.github.io/2017/01/08/01-JAVA%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0%E5%8F%8AHelloWorld/</url>
      <content type="html"><![CDATA[<h3 id="JAVA环境搭建"><a href="#JAVA环境搭建" class="headerlink" title="JAVA环境搭建"></a>JAVA环境搭建</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><pre><code>* 创始团队:詹姆斯-高斯林
* sun开发,已被oracle收购.
* 版本(平台)
    * JAVASE(标准版):开发简单桌面应用,不能开发大型项目.也叫J2SE 
    * JAVAEE(企业版或Web版):可做电商、企业级应用(如ERP、CRM、BOS、OA等)，也叫J2EE
    * JAVAME（嵌入式开发）：也叫J2ME
</code></pre><a id="more"></a>
<h4 id="2-常用DOS命令"><a href="#2-常用DOS命令" class="headerlink" title="2.常用DOS命令"></a>2.常用DOS命令</h4><pre><code>* 清屏：cls(clear screen)
* 切换盘符：盘符:
* 进入指定目录：cd（change directory）
* 返回上一级目录：cd..
* 返回盘符根目录：cd\
* 进入其他盘符文件夹：cd 盘符:\文件夹名
* 显示当前目录下的文件和子目录信息：dir
</code></pre><h4 id="3-开发环境"><a href="#3-开发环境" class="headerlink" title="3.开发环境"></a>3.开发环境</h4><pre><code>* JDK(JAVA Development Kit):java开发工具包
* JDK包含
    * JRE(JAVA Runtime Environment):JAVA运行环境
    * JAVA开发工具
</code></pre><h4 id="4-跨平台特性"><a href="#4-跨平台特性" class="headerlink" title="4.跨平台特性"></a>4.跨平台特性</h4><pre><code>* 平台指操作系统(Windows/Linux/mac)
* 一次编写,到处运行
* 跨平台特性依赖于JVM(JAVA Virtual Machine)
* JRE包含
    * JVM 
    * 类库  
</code></pre><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><pre><code>* 源文件:  .java 
* 编译(编译器):    .java   →    .class(字节码文件)
* 运行(解释器):    运行.class
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"HelloWorld"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意:</strong><br><strong>1.class前加上public,类名(HelloWorld)要与文件名(HelloWorld.java)一致,不加public,类名可换成其他</strong><br><strong>2.主方法是程序的入口,被虚拟机调用,它能保证程序的独立运行</strong><br>编译:<code>javac HelloWorld.java</code><br>编译时HelloWorld.java可以写成helloworld.java,因为对源文件来说HellWorld.java和helloworld.java所指的源文件是唯一的<br>运行:<code>java HelloWorld</code><br>运行时HelloWorld是类名,不能写成helloworld</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA基础题]]></title>
      <url>https://geekhoon.github.io/2017/01/05/JAVA%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>1.Java注释有3种，单行注释、多行注释和文档注释，下列有关注释的说法，不正确的是（）</p>
<p>A. 注释指的是用来对程序的某个功能或者某行代码进行解释说明<br>B. 注释只在Java源文件中有效<br>C. 在多行注释中，能够嵌套多行注释<br>D. 注释不会被编译到class字节码文<br><a id="more"></a><br>2.下面哪种类型的文件可以在Java虚拟机中运行？（）</p>
<p>A. .java<br>B. .jre<br>C. .exe<br>D. .class</p>
<p>3.下列关于变量和常量的说法正确的是（）</p>
<p>A. 常量表示不能被改变的值，例如1、2、“abc”都是常量<br>B. 常量表示常见的变量<br>C. int x = 0;代码中，x表示常量，0表示变量<br>D. 在同一个大括号｛｝内，定义的变量不能够重名</p>
<p>4.下列定义变量格式，错误的是（）</p>
<p>A. float x,y=0;<br>B. float f = 1999.99F;<br>C. String str = 字符串;<br>D. char x = ‘0’;</p>
<p>5.下列各种符号的定义格式，那种在java语言中是错误的变量定义（）</p>
<p>A. int myVal =1;<br>B. char $myVal =1;<br>C. byte _myVal =1;<br>D.float 3.14myVal=1;</p>
<p>6.Java语言中的int及char数据类型的长度分别为（）</p>
<p>A. 16位和8位<br>B. 8位和16位<br>C. 32位和16位<br>D. 32位和8位</p>
<p>7.语句System.out.println(1+2+”java”+3+4)输出的结果是（）</p>
<p>A. 3java34<br>B. 12java34<br>C. 3java7<br>D. 12java7</p>
<p>8.下列关于Java函数的说法不正确的是（）</p>
<p>A.函数也叫方法，函数就是定义在类中，具有特定功能的一段小程序<br>B.方法体中不能有任何代码（抽象函数除外）<br>C.函数必须先定义，才能被调用<br>D.函数（构造函数除外）要有返回值类型</p>
<p>9.以下关于函数重载的说法正确的有（）</p>
<p>A. 方法名必须一样<br>B. 与返回值类型无关<br>C. 参数个数或者顺序不一样<br>D. 参数类型不一样</p>
<p>10.关于数组的说法，正确的是（）</p>
<p>A. 数组里面存放的是相同类型的数据<br>B. 获取数组的长度使用length属性<br>C. 获取数组的大小使用size方法<br>D. 数组的长度是可变的</p>
<p>11.想要结果输出为0，则可以做哪些修改？（）</p>
<pre><code>int [] arr = new int[1];
arr[0] = 3;               
System.out.println( arr[1] )
</code></pre><p>A. 2修改为<code>arr[3] = 0;</code><br>B. 3修改为<code>System.out.println(0)</code><br>C. 1修改为<code>int [ ] arr = new int[2];</code><br>D. 不用修改了，结果就是0会报错</p>
<p>12.下列二维数组定义错误的是（）</p>
<pre><code>A.int[][] arr = new int[3][2];
B.int arr[][] = new int[3][]; 
C.int[][] arr = {{1,2,3},{4,5},{6,7,8,9}};
D.int arr[][] ={{2,3},{6},9};
</code></pre><p>13.下面代码的运行结果是（）</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
    <span class="keyword">int</span> x = <span class="number">80</span>;
    x ++;
    <span class="keyword">switch</span>(x){
        <span class="keyword">case</span> <span class="number">80</span>:
        System.out.println(<span class="number">80</span>);
        <span class="keyword">case</span> <span class="number">81</span>:
        System.out.println(<span class="number">81</span>);
        <span class="keyword">default</span>:
        System.out.println(<span class="number">82</span>);
    }
}
</code></pre>
<p>A. 80<br>B. 80 81<br>C. 81<br>D. 81 82</p>
<p>14.下面程序运行的结果是（）</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
    <span class="keyword">int</span> a = <span class="number">1</span>;
    <span class="keyword">if</span>(a++&gt;<span class="number">1</span>){
        System.out.println(a);
    }<span class="keyword">else</span>{
        System.out.println(a);
    }
}
</code></pre>
<p>A.1<br>B.2<br>C.0<br>D.编译报错</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>答案:1~5:C,D,AD,C,D 6~10:C,A,B,ABCD,AB 11~14:BC,D,D,B</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[致自己]]></title>
      <url>https://geekhoon.github.io/2017/01/01/%E8%87%B4%E8%87%AA%E5%B7%B1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>做一件事,如果过程中你就怕了,退缩了,那不论结果成功还是失败,你都已经输了。</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
