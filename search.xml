<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaWeb_05.XML]]></title>
      <url>%2F2017%2F03%2F31%2FJavaWeb-05-XML%2F</url>
      <content type="text"><![CDATA[概述1.概念XML(Extensible Markup Language),是可扩展的标记语言.标记—–由标签组成可扩展—标签可以自定义2.与HTMl的区分HTML – 存储页面内容(写页面)XML — 作为配置文件,作为数据传输的载体 语法1.后缀名是.xml,使用浏览器可以查看2.头部是xml的声明,声明必须位于第一行第一列 声明的属性:version(版本:1.0),encoding(编码集)3.元素(标签)严格区分大小写不能使用空格和冒号,冒号某些情况下可用不建议使用XML,xml,Xml..等等做标签名其余语法规则和HTML一样4.属性除了自定义的,其余和HTML规则一样5.注释6.转义字符一些特殊符号不能直接使用必须使用转义字符空格需要使用全角输入法录入空格 - 小于号: &amp;lt; - 大于号: &amp;gt; - 双引号: &amp;quot; - 单引号: &amp;apos; - 与符号: &amp;amp; 转义字符少用,因为大量使用会影响XML的解析效率,且易读性差7.转义字符使用的替换方案语法:&lt;![CDATA[存储任意内容]]&gt;,可以保证内容原样输出解析时,只获取[]中的内容 XML的解析解析就是获得XML中标签的属性或内容解析方案:(使用第三方实现) 解析算法1.DOM解析方式: 将标签全部加载进内存,形成Dom树2.SAX解析方式: 一行一行读取,当前行前面的数据已经销毁了比较:(1)内存角度,SAX解析方式占的内存更小(2)功能角度,DOM方式可以根据当前标签进行上下推导,功能更强大使用: XML比较小时使用DOM,比较大时使用SAX解析基于上述两种解析实现,有不同的第三方封装:(1)JAXP — JDK内置的解析实现,不常用(2)JDOM — 只用到类,没使用接口,灵活性差(3)DOM4J – 相对应JDOM使用了接口,扩展性更好(4)JSOUP – 专门解析HTML,HTML可以理解为特殊的XML 解析优化如果标签纵深比较多,那么要获取该标签对象,得逐级获取,代码实现比较麻烦,dom4j解析层级结构复杂的标签时,进行了优化：优化方案是使用选择器(与 CSS 中，JQuery 中的选择器类似) DOM4J使用1.导jar包 - dom4j-1.6.1.jar - jaxen-1.1-beta-6.jar 2.步骤:(1)创建一个文件输入流(2)创建DOM4J的解析器,读流SAXReader r = new SAXReader();(3)解析器读流,生成DOM树Document doc = r.read(in);(4)解析DOM树 — 获取配置信息 - 获取根元素对应的对象: Element root = doc.getRootElement() - 操作元素相关API - attributeValue(&quot;属性名&quot;); ---- 返回属性值 - elements(&quot;标签名&quot;) ----------- 获取所有指定名称的子级标签,可以不指定名称 - element(&quot;标签名&quot;) ------------ 获取第一个有指定名称的标签,可以不指定名称 - getText() ------------------- 获取标签的文本内容体 - 优化:如果标签有2级,获取子级标签的文本内容 - 方案1: 先获取子级标签对象,调用 getText() --- 获取文本 - 方案2: 父级标签.elementText(&quot;子级标签名&quot;) --- 简化代码 DOM4J常规使用案例配置文件animals.xml写法1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;animals version="1.0"&gt; &lt;animal id="1.1"&gt; &lt;name&gt;猫&lt;/name&gt; &lt;age&gt;2&lt;/age&gt; &lt;/animal&gt; &lt;animal&gt; &lt;name&gt;狗&lt;/name&gt; &lt;age&gt;3&lt;/age&gt; &lt;/animal&gt;&lt;/animals&gt; 测试类1234567891011121314151617181920212223242526272829303132333435363738public class DOM4JDemo &#123; public static void main(String[] args) throws Exception &#123; //1.关联文件,创建一个文件输入流 InputStream in = DOM4JDemo.class.getClassLoader().getResourceAsStream("animals.xml"); //2.创建dom4j的解析器 SAXReader r = new SAXReader(); //读流,创建一个dom树 Document doc = r.read(in); //关流 in.close(); //3.解析Dom树,获取配置信息 //3.1获取根元素对应的对象 Element root = doc.getRootElement(); //获取属性 String value = root.attributeValue("version"); System.out.println(value);//1.0 //3.2内容体 //获取所有名字为animal的子级标签 List es = root.elements("animal"); System.out.println(es.size());//2 //获取第一个animal子级标签 Element first = root.element("animal"); //获取first的id属性 String value2 = first.attributeValue("id"); System.out.println("id: "+value2); //获取name这个子级标签 Element name = first.element("name"); //获取name文本内容 String text = name.getText(); System.out.println("文本:"+text); //优化:(代码简单) System.out.println(first.elementText("name")); &#125;&#125; 模拟servletServlet是在服务器上运行的小程序.创建JavaEEServlet和AndroidServlet,假设它们是服务器上的两个小程序,导入官方web.xml配置文件,进行对应更改.需求：1.控制台录入访问路径2.编写相关的实现程序（Servlet）3.录入路径后，会执行相应的程序 Servlet小程序1234567891011121314151617181920212223242526public class JavaEEServlet &#123; public void init()&#123; System.out.println("JavaEE Servlet 创建了...."); &#125; public void service()&#123; System.out.println("JavaEE servlet 生成EE课程的 HTML 代码，发送回客户端"); &#125; public void destory()&#123; System.out.println("JavaEE Servlet 销毁....."); &#125;&#125;public class AndroidServlet &#123; public void init()&#123; System.out.println("Android Servlet 创建了...."); &#125; public void service()&#123; System.out.println("Android servlet 生成安卓课程的 HTML 代码，发送回客户端"); &#125; public void destory()&#123; System.out.println("Android Servlet 销毁....."); &#125;&#125; web.xml配置文件12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;ee&lt;/servlet-name&gt; &lt;servlet-class&gt;com.geekhoon.demo.JavaEEServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ee&lt;/servlet-name&gt; &lt;url-pattern&gt;/JavaEE&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;an&lt;/servlet-name&gt; &lt;servlet-class&gt;com.geekhoon.demo.AndroidServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;an&lt;/servlet-name&gt; &lt;url-pattern&gt;/Android&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Use &#123; public static void main(String[] args) throws Exception &#123; System.out.println("请输入一个路径:"); Scanner sc = new Scanner(System.in); String url = sc.next(); //1.创建文件输入流 InputStream in = Use.class.getClassLoader().getResourceAsStream("web.xml"); //2.创建解析器 SAXReader r = new SAXReader(); //3.读流,生成dom树 Document doc = r.read(in); in.close(); //4.解析dom树 Element root = doc.getRootElement(); //创建map集合存name和class Map&lt;String,String&gt; nameClass = new HashMap&lt;String,String&gt;(); List&lt;Element&gt; es = root.elements("servlet");-----------------------------------------------------使用XPath优化:使用选择器 List&lt;Element&gt; es = root.selectNodes("//servlet"); for (Element e : es) &#123; String name = e.elementText("servlet-name"); String clazz = e.elementText("servlet-class"); nameClass.put(name, clazz); &#125; //创建map集合存name和url Map&lt;String,String&gt; nameUrl = new HashMap&lt;String,String&gt;(); List&lt;Element&gt; es2 = root.elements("servlet-mapping");-----------------------------------------------------使用XPath优化:使用选择器 List&lt;Element&gt; es2 = root.selectNodes("//servlet-mapping"); for (Element e2 : es2) &#123; String name = e2.elementText("servlet-name"); String urlpattern = e2.elementText("url-pattern"); nameUrl.put(name, urlpattern); &#125; //整合上面两个数组,获得全类名及url Map&lt;String,String&gt; urlClass = new HashMap&lt;String,String&gt;(); Set&lt;String&gt; keys = nameUrl.keySet(); for (String key : keys) &#123; String clazz = nameClass.get(key); String urlpattern = nameUrl.get(key); urlClass.put(urlpattern, clazz); &#125; //根据用户输入的url,查询对应的value String className = urlClass.get(url); //System.out.println(className); if(className != null)&#123; //反射,获得字节码对象 Class clazz = Class.forName(className); //获取构造方法 Constructor con = clazz.getConstructor(); //创建对象 Object obj = con.newInstance(); //获取方法 Method init = clazz.getMethod("init"); Method service = clazz.getMethod("service"); Method destory = clazz.getMethod("destory"); //执行方法 init.invoke(obj); service.invoke(obj); destory.invoke(obj); &#125;else&#123; System.out.println("路径不存在"); &#125; &#125;&#125; 约束限制XML可以使用的标签的名称,属性及内容体,规范XML的书写]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[装饰者设计模式---设计模式(1)]]></title>
      <url>%2F2017%2F03%2F31%2F%E8%A3%85%E9%A5%B0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[DBUtils]]></title>
      <url>%2F2017%2F03%2F30%2F22-DBUtils%2F</url>
      <content type="text"><![CDATA[概述1.是JDBC的简化开发工具包,简化数据库相关操作2.需要导入jar包: commons-dbutils-1.6.jar QueryRunner实现增删改方法: update(Connection conn,String sql,Object…params): 执行增删改 其中Object…params: 可变参数,Object类型,当SQL语句中出现?占位符时使用DBUTils中补齐SQL语句的参数使用了可变参数,可以传递一个具体的数组,也可以直接传递数组元素,如果是后者,编译后直接将这些元素再组织成一个数组 添加123456789101112131415161718192021public class Test &#123; //获取数据库连接 private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException &#123; insert(); //update(); //delete(); &#125; private static void insert() throws SQLException &#123; //创建QueryRunner类对象 QueryRunner qr = new QueryRunner(); String sql = "INSERT INTO sort (sname,sprice,sdesc) VALUES (?,?,?)"; //将三个占位符的实际参数, 写在数组中 Object[] params = &#123;"体育用品",289.32,"购买体育用品"&#125;; //调用QueryRunner类的方法update执行sql语句 int row = qr.update(con, sql, params); System.out.println(row); //调用DBUtils释放资源 DbUtils.closeQuietly(con); &#125;&#125; 修改1234567891011private static void update() throws SQLException &#123; //创建QueryRunner类对象 QueryRunner qr = new QueryRunner(); String sql = "UPDATE sort SET sname = ?,sprice = ?,sdesc = ? WHERE sid = ?"; //定于Object数组,存取实际参数 Object[] params = &#123;"花卉",100.88,"情人节玫瑰",4&#125;; int row = qr.update(con, sql, params); System.out.println(row); //调用DBUtils释放资源 DbUtils.closeQuietly(con);&#125; 删除12345678private static void delete() throws SQLException&#123; //创建QueryRunner对象 QueryRunner qr = new QueryRunner(); String sql = "DELETE FROM sort WHERE sid = ?"; int row = qr.update(con, sql, 9); System.out.println(row); DbUtils.closeQuietly(con);&#125; QueryRunner实现查询用来完成表数据的查询操作方法: query(Connection conn, String sql, ResultSetHandler rsh, Object… params):ResultSetHandler rsh: 结果集的处理方式,传递的是ResultSetHandler接口的实现类注意: query()的返回值是泛型类型T JavaBean1.概念一个普通Java类,在开发中常用封装数据,一般数据库的一张表对应一个Java类,类名对应表名,类中的字段对应表中的字段2.创建JavaBean时,必须得遵循一定的规范 A、必须有包,所有数据表对应的类存放同一文件夹下 B、声明类时必须实现序列化接口,实现serializable(但是好多JavaBean实现没有遵守此规范) C、属性私有，提供公共的set/get方法,让属性的数据赋值更为安全 D、必须提供无参构造 场景1：如果当前类没有自定义构造方法，这是系统默认提供 场景2：如果自定义了一个有参构造，这时，我们必须自己提供一个无参构造 ResultSetHandler结果集处理类8种结果集的处理方式:1.ArrayHandler——- 将第一条结果的每一个字段都当成数组的一个元素,组织成一个数组,即结果的字段个数就是数组长度2.ArrayListHandler— 将每一条结果组织成一个数组，再将数组存储进集合3.BeanHandler——– 将查询结果的第一条记录组织成一个 JavaBean 对象4.BeanListHandler—- 将每一条记录组织成一个 JavaBean 对象，然后将对象存入集合5.ColumnListHandler– 将结果集中某一列的数据存放到List中(List)6.ScalarHandler—— 获取单个结果，一般结合聚合函数使用7.MapHandler——— 将第一条记录组织成一个 map 集合，键是字段名，值是字段对应的值8.MapListHandler—– 将每一条记录组织成一个 map 集合，这些map 集合再存入 List ArrayHandler与ArrayListHandler查询1.ArrayHandler: 将结果集的第一行存储到对象数组中Object[]不管查询到几行,只存储第一行数组长度不等于0,代表查询到内容了2.ArrayListHandler: 将结果集的每一行封装到对象数组中,出现很多对象数组,将对象数组存储到list集合返回值: 存储很多对象数组的List集合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Test &#123; //获取数据库连接 private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException &#123; arrayHandler(); //arrayListHandler(); //调用DBUtils释放资源 DbUtils.closeQuietly(con); &#125;&#125;ArrayHandler:private static void arrayHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort";//query方法传递的参数有://连接对象,sql语句,结果集处理方式的实现类,有占位符的话还有加上实际参数 Object[] result = qr.query(con, sql, new ArrayHandler()); if (result.length != 0) &#123; for (Object obj : result) &#123; System.out.print(obj+"\t"); &#125; &#125;else&#123; System.out.println("没有查询到数据"); &#125;&#125;ArrayListHandler:private static void arrayListHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort";//query方法传递的参数有://连接对象,sql语句,结果集处理方式的实现类,有占位符的话还有加上实际参数 List&lt;Object[]&gt; result = qr.query(con, sql, new ArrayListHandler()); if (result.size() != 0) &#123; //遍历集合 for (Object[] objs : result) &#123; //遍历对象数组 for (Object obj : objs) &#123; System.out.print(obj+"\t"); &#125; System.out.println(); &#125; &#125;else&#123; System.out.println("没有查询到数据"); &#125; &#125; BeanHandler与BeanListHandler查询1.BeanHandler: 将结果集的第一行数据,封装成JavaBean对象注意: 将数据封装到JavaBean对象, Sort类必须有空参构造2.BeanListHandler: 将结果集的每一行数据,封装成JavaBean对象多个JavaBean对象,封装到List集合123456789101112131415161718192021BeanHandler:private static void beanHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //调用方法,传递结果实现类BeanHandler //BeanHandler(Class&lt;T&gt; type) Sort s = qr.query(con, sql, new BeanHandler&lt;Sort&gt;(Sort.class)); System.out.println(s); &#125;BeanListHandler:private static void beanListHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //调用方法传递结果集的实现类BeanListHandler List&lt;Sort&gt; list = qr.query(con, sql, new BeanListHandler&lt;Sort&gt;(Sort.class)); for (Sort s : list) &#123; System.out.println(s); &#125;&#125; ColumnListHandler与ScalarHandler查询1.ColumnListHandler: 将结果集指定列的数据存储到List集合List: 集合泛型是Object2.ScalarHandler: 适用于查询后只有一个结果(聚合函数的结果)123456789101112131415161718192021ColumnListHandler:private static void columnListHandler()throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //调用方法query,传递结果集实现类ColumnListHandler //实现类构造方法中,使用字符串的列名 List&lt;Object&gt; list = qr.query(con, sql, new ColumnListHandler&lt;Object&gt;("sname")); for (Object obj : list) &#123; System.out.println(obj); &#125;&#125;ScalarHandler:private static void scalarHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT COUNT(*) FROM sort"; //qr.query(con, sql, new ScalarHandler&lt;Object&gt;()); //如果已知结果为int, 泛型直接写成long, 不知道的话使用Object Long count = qr.query(con, sql, new ScalarHandler&lt;Long&gt;()); System.out.println(count);&#125; MapHandler与MapListHandler查询1.MapHandler: 将结果集的第一行数据,封装到map集合键: 查询的列名值: 对应列的数据2.MapListHandler: 将结果集每一行存储到Map集合,键:列名,值:数据Map集合过多,存储到List集合1234567891011121314151617181920212223MapHandler:private static void mapHandler() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //返回值是一个Map集合 Map&lt;String, Object&gt; map = qr.query(con, sql, new MapHandler()); for (String key : map.keySet()) &#123; System.out.println(key+" "+map.get(key)); &#125;&#125;MapListHandler:private static void mapListHandler()throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //返回值是List集合, 存储的是Map集合 List&lt;Map&lt;String, Object&gt;&gt; list = qr.query(con, sql, new MapListHandler()); for (Map&lt;String, Object&gt; map : list) &#123; for (String key : map.keySet()) &#123; System.out.print("\t"+key+"\t"+map.get(key)+"\t"); &#125; System.out.println(); &#125;&#125; 测试类对连接池对象进行测试:12345678910111213141516171819202122232425262728293031323334353637383940414243441.工具类返回的是一个DataSource接口的数据源2.QueryRunner类的构造方法中可以直接接收DataSource接口的实现类import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayListHandler;public class Test2 &#123; //QueryRunner类对象,写在类成员位置 private static QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource()); public static void main(String[] args) &#123; //insert(); select(); &#125; //定义方法,实现数据的查询 private static void select() &#123; String sql = "SELECT * FROM sort"; try &#123; List&lt;Object[]&gt; list = qr.query(sql, new ArrayListHandler()); for (Object[] objs : list) &#123; for (Object obj : objs) &#123; System.out.print(obj+"\t"); &#125; System.out.println(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException("查询数据失败"); &#125; &#125; //定义方法,实现数据的添加 public static void insert()&#123; String sql = "INSERT INTO sort (sname,sprice,sdesc) VALUES (?,?,?)"; Object[] params = &#123;"水果",100.00,"香蕉 "&#125;; try &#123; int row = qr.update(sql, params); System.out.println(row); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException("添加数据失败"); &#125; &#125;&#125; 几个易混淆概念1.JDBC:Java提供的访问数据库规范2.JDBCUtils:JDBC工具类,用于获得连接对象或连接池对象3.JDBC连接池:作用在程序与数据库连接的中间环节,侧重于连接(Connection)的创建与管理实现资源复用,提高执行效率4.DBCP:一种实现JDBC连接池的第三方形式5.DBUtils:作用与程序端,侧重于SQL语句操作的优化封装功能实现,简化代码书写备注:(1)JDBCUtils和DBUtils,前者获取连接对象或连接池对象,后者可以对数据库中数据进行增删改查(2)DBUtils不是只在有连接池的情况下才能使用,只要是有数据库连接对象,就可以使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC连接池]]></title>
      <url>%2F2017%2F03%2F30%2F21-%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[概述连接池是存放连接的容器,如果频繁地获得连接和释放资源,非常消耗资源,通过连接池,共享连接,可以解决此类问题.当需要数据库连接时,通过池来获取Connection对象,用完后,调用Connection的close()回收对象,对象回到连接池中,并没有真正关闭.优点:1.实现了资源复用2.效率更高 连接池实现方式1.DBCP(第三方实现)2.C3P0(第三方实现)3.自定义连接池 DataSource接口Java为数据库连接提供了公共的接口,数据库厂商需要让自己的连接池实现这个接口 BasicDataSource类数据源的规范接口javax.sql.DataSource的实现类在org.apache.commons.dbcp中方法: - setXXX(参数): setDriverClassName,setUrl,setUsername,setPassword - getConnection(): 获取数据库连接 常见配置项1.必须项2.基本项: - maxActive: 最大连接数量 - minidle: 最小空闲连接 - maxidle: 最大空闲连接 - initialSize: 初始化连接 DBCP实现连接池1.导jar包 - mysql-connector-java-5.1.37-bin.jar - commons-dbcp-1.4.jar - commons-pool-1.5.6.jar 2.使用DBCP创建数据库连接池对象 - 创建语法: 1DataSource ds = BasicDataSourceFactory.createDatasource("存储连接信息的 properties 集合"); 3.使用DataSource,可以调用连接池对象的getConnection()获得Connection对象区别:con.close()时,之前是直接释放连接,但是现在是存储回连接池（详情看自定义连接池实现） 配置文件代码实现dbcpconfig.properties放于src目录下注意:工具类—方式2中只要4个必须配置项与配置文件匹配就可以,但是方式3和方式4中,因为是createDataSource(pro集合),直接进行加载,需要保证配置文件中4个必须项名字必须为driverClassName,url,username,password1234567891011121314151617181920212223242526272829303132#连接设置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybaseusername=rootpassword=root#&lt;!-- 初始化连接 --&gt;initialSize=10#最大连接数量maxActive=50#&lt;!-- 最大空闲连接 --&gt;maxIdle=20#&lt;!-- 最小空闲连接 --&gt;minIdle=5#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;maxWait=60000#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] #注意："user" 与 "password" 两个属性会被明确地传递，因此这里不需要包含他们。connectionProperties=useUnicode=true;characterEncoding=gbk#指定由连接池所创建的连接的自动提交（auto-commit）状态。defaultAutoCommit=true#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLEdefaultTransactionIsolation=READ_UNCOMMITTED JDBCUtils工具类代码实现工具类—方式1: 使用DataSource的setXXX方法进行赋值1234567891011121314151617181920212223public class JDBCUtils &#123; //创建BasicDataSource类对象 private static BasicDataSource datasource = new BasicDataSource(); //静态代码块,对BasicDataSource对象进行配置 static&#123; //必须项 datasource.setDriverClassName("com.mysql.jdbc.Driver"); datasource.setUrl("jdbc:mysql://localhost:3306/mybase"); datasource.setUsername("root"); datasource.setPassword("root"); //自定义基本项,可选配置 datasource.setInitialSize(10);//初始化的连接数 datasource.setMaxActive(8);//最大连接数量 datasource.setMaxIdle(5);//最大空闲数 datasource.setMinIdle(1);//最小空闲数 &#125; //定义静态方法,返回BasicDataSource类的对象 public static DataSource getDataSource()&#123; return datasource; &#125;&#125; 工具类—方式2: 读取配置文件,使用DataSource的setXXX方法进行赋值12345678910111213141516171819202122232425262728293031323334353637public class JDBCUtilsConfig &#123; private static BasicDataSource dataSource = new BasicDataSource(); private static String driverClass; private static String url; private static String username; private static String password; static&#123; try &#123; readConfig(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); &#125; catch (Exception e) &#123; //e.printStackTrace(); System.out.println(e); throw new RuntimeException("数据库连接失败"); &#125; &#125; private static void readConfig() throws Exception &#123; InputStream in = JDBCUtilsConfig.class.getClassLoader().getResourceAsStream("database.properties"); Properties pro = new Properties(); pro.load(in); driverClass = pro.getProperty("driverClass"); url = pro.getProperty("url"); username = pro.getProperty("username"); password = pro.getProperty("password"); &#125; public static DataSource getDataSource()&#123; return dataSource; &#125; &#125; 工具类—方式3: (这种方式只是与方式4进行对比,并不会使用,因为效率极低)读取配置文件,使用BasicDataSourceFactory.createDatasource()方法创建数据库连接池对象,但是每调用一次 getDs 方法,就创建一个新的连接池对象123456789101112131415161718public class JDBCUtils &#123; public static DataSource getDs()&#123; DataSource ds = null; try &#123; //创建DBCP的数据库连接池对象 //1、获取配置文件对应的输入流 InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream("dbcpconfig.properties"); //2、将流中数据读入集合 Properties pro = new Properties(); pro.load(in); ds = BasicDataSourceFactory.createDataSource(pro); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; return ds; &#125;&#125; 工具类—方式4: 读取配置文件,使用BasicDataSourceFactory.createDatasource()方法创建数据库连接池对象,但只创建一个连接池对象123456789101112131415161718192021public class JDBCUtils &#123; private static DataSource ds; //DatatSource 对象只会创建一个 static &#123; try &#123; //创建DBCP的数据库连接池对象 //1、获取配置文件对应的输入流 InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream("dbcpconfig.properties"); //2、将流中数据读入集合 Properties pro = new Properties(); pro.load(in); ds = BasicDataSourceFactory.createDataSource(pro); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; &#125; public static DataSource getDs()&#123; return ds; &#125;&#125; 测试类代码实现12345678910111213141516171819public class Test &#123; public static void main(String[] args) throws Exception &#123; //获取连接对象 Connection con = JDBCUtils.getDs().getConnection(); //获取执行者对象 PreparedStatement ps = con.prepareStatement("select * from teacher"); //执行sql ResultSet rs = ps.executeQuery(); //处理结果集 while(rs.next())&#123; System.out.println(rs.getString(1) + "\t" + rs.getString(2)); &#125; //关闭 rs.close(); ps.close(); //和以前不同,连接池中取出的con调用close()没有真正关闭,而是存回连接池 con.close(); &#125;&#125; C3P0实现连接池1.导jar包 - 驱动:mysql-connector-java-5.1.39-bin.jar - c3p0-0.9.2-pre5.jar - mchange-commons-java-0.2.3.jar 2.使用C3P0创建对应的数据库连接池对象1DataSource ds = new ComboPooledDataSource(); 注意:1)、虽然有配置文件,但是配置文件并没有自己读取,new对象时,c3p0会自动读取配置文件,此过程隐藏2)、保证配置文件存在的路径在src下,其实复制到bin目录下,读取时是从bin目录下查找的3)、配置文件的文件名必须固定— c3p0-config.xml3.具体的连接对象使用与DBCP、JDBC一样.con.close()不是真的释放,而是存储回连接池4.C3P0配置信息默认配置(default-config)与命名配置(named-config) - 一般一个程序对应一个数据库，但是可能一个程序对应多个数据库 - 使用 default-config 配置最常用的数据库,使用 named-config 配置其余数据库 - new ComboPooledDataSource() 根据默认配置创建一个连接池 - new ComboPooledDataSource(&quot;name值&quot;) 根据指定的配置创建一个连接池 配置文件代码实现c3p0-config.xml放于src目录下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置，如果没有指定则使用这个配置 默认配置最常用 建议放在最开头。 放其他地方也没问题 --&gt; &lt;default-config&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://127.0.0.1:3306/mybase&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;30000&lt;/property&gt; &lt;property name="idleConnectionTestPeriod"&gt;30&lt;/property&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;property name="maxIdleTime"&gt;30&lt;/property&gt; &lt;property name="maxPoolSize"&gt;100&lt;/property&gt; &lt;property name="minPoolSize"&gt;10&lt;/property&gt; &lt;property name="maxStatements"&gt;200&lt;/property&gt; &lt;user-overrides user="test-user"&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;property name="minPoolSize"&gt;1&lt;/property&gt; &lt;property name="maxStatements"&gt;0&lt;/property&gt; &lt;/user-overrides&gt; &lt;/default-config&gt; &lt;!-- 命名的配置 一般的大型项目中，使用最多是命名配置 --&gt; &lt;named-config name="geekhoon"&gt; &lt;!-- 连接数据库的4项基本参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://127.0.0.1:3306/geekhoon&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 如果池中数据连接不够时一次增长多少个 --&gt; &lt;property name="acquireIncrement"&gt;5&lt;/property&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name="initialPoolSize"&gt;20&lt;/property&gt; &lt;!-- 最小连接受 --&gt; &lt;property name="minPoolSize"&gt;10&lt;/property&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxPoolSize"&gt;40&lt;/property&gt; &lt;!-- -JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量 --&gt; &lt;property name="maxStatements"&gt;0&lt;/property&gt; &lt;!-- 连接池内单个连接所拥有的最大缓存statements数 --&gt; &lt;property name="maxStatementsPerConnection"&gt;5&lt;/property&gt; &lt;/named-config&gt; &lt;named-config name="geek"&gt; &lt;!-- 连接数据库的4项基本参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://127.0.0.1:3306/geek&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!-- 如果池中数据连接不够时一次增长多少个 --&gt; &lt;property name="acquireIncrement"&gt;5&lt;/property&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name="initialPoolSize"&gt;20&lt;/property&gt; &lt;!-- 最小连接受 --&gt; &lt;property name="minPoolSize"&gt;10&lt;/property&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxPoolSize"&gt;40&lt;/property&gt; &lt;!-- -JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量 --&gt; &lt;property name="maxStatements"&gt;0&lt;/property&gt; &lt;!-- 连接池内单个连接所拥有的最大缓存statements数 --&gt; &lt;property name="maxStatementsPerConnection"&gt;5&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; JDBCUtils工具类代码实现工具类—方式1: 读取默认配置123456public class JDBCUtils &#123; private static DataSource ds = new ComboPooledDataSource(); public static DataSource ds()&#123; return ds; &#125;&#125; 工具类—方式2: 读取命名配置123456public class JDBCUtils &#123; private static DataSource ds = new ComboPooledDataSource("geekhoon"); public static DataSource ds()&#123; return ds; &#125;&#125; 测试类代码实现12345678910111213public class Test &#123; public static void main(String[] args) throws Exception &#123; Connection con = JDBCUtils.ds().getConnection(); PreparedStatement ps = con.prepareStatement(&quot;select * from 表名&quot;); ResultSet rs = ps.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString(1) + &quot;\t&quot; + rs.getString(2)); &#125; rs.close(); ps.close(); con.close(); &#125;&#125; 自定义连接池三个步骤:1.定义一个集合,存储若干连接2.提供一个方法,获取相关连接,再将连接移出给调用者3.提供一个方法,使用完连接时,再将连接存回该连接池 自定义连接池写法1写法1中,当使用完连接对象存回的时候,需要调用MyPool.close(Connection con);123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyPool&#123; //1.定义集合,存储连接 //由于增删频繁,因此使用 LinkedList 而不是 ArrayList public static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;(); //一旦创建,集合预先存储一些连接 static &#123; //存储三个连接 for(int i = 0; i &lt; 3; i++)&#123; pool.add(getCon()); &#125; &#125; private static Connection getCon()&#123; Connection con = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); con = DriverManager.getConnection("jdbc:mysql://localhost:3306/geekhoon", "root", "root"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; return con; &#125; //2.提供一个方法,获取相关连接,再将连接移出给调用者 public static Connection getConByPool()&#123; //从集合取出一个连接 ---- 获取并移出 /* * remove 和 get 区别： * 前者是获取并从集合移出 * 后者只是获取,不移除 * */ //版本1 //return pool.remove(); //版本2优化 ---- 判断是不是连接都被占用者，如果是，新建连接 if(!pool.isEmpty())&#123; return pool.remove(); &#125; else &#123; return getCon(); &#125; &#125; //3.提供一个方法,使用完连接时,再将连接存回该连接池 public static void close(Connection con)&#123; pool.add(con); &#125;&#125; 测试类代码实现测试类1: 获取连接后,打印连接对象地址,然后存回连接池,由于连接池只有三个连接对象,当获取第四个连接对象时,由于之前的连接对象使用完后,已经存回了,所以con4打印的对象地址和con1的对象地址一样,实现了连接池的功能1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; //获取连接 Connection con1 = MyPool.getConByPool(); System.out.println(con1); MyPool.close(con1); Connection con2 = MyPool.getConByPool(); System.out.println(con2); MyPool.close(con2); Connection con3 = MyPool.getConByPool(); System.out.println(con3); MyPool.close(con3); Connection con4 = MyPool.getConByPool(); System.out.println(con4); MyPool.close(con4); System.out.println(MyPool.pool);//打印的是3个元素,con4并没有创建新的连接对象 &#125;&#125; 测试类2: 获取连接对象,打印对象地址后,并不存回,当获取第四个连接对象时,池中并没有连接,所以创建了新的连接,所以打印的四个对象地址都不相同,注意代码中1,2,3处打印,1处打印0个元素的集合,2处也打印0个元素的集合,3处打印4个元素的集合12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) &#123; Connection con1 = MyPool.getConByPool(); System.out.println(con1); Connection con2 = MyPool.getConByPool(); System.out.println(con2); Connection con3 = MyPool.getConByPool(); System.out.println(con3); //1 System.out.println(MyPool.pool); Connection con4 = MyPool.getConByPool(); System.out.println(con4); //2 System.out.println(MyPool.pool); MyPool.close(con1); MyPool.close(con2); MyPool.close(con3); MyPool.close(con4); //3 System.out.println(MyPool.pool); &#125;&#125; 自定义连接池写法2写法2中,不再使用自定义连接池MyPool的close()进行存回,而是使用Connection接口的close()进行存回,但是我们知道Connection接口的close()只是单纯地释放掉资源,并没有存回操作.所以我们现在的想法是:重写close()在重写之前,首先我们要知道下面操作返回的是什么?123Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/geekhoon", "root", "root");DriverManager.getConnection()返回的是MySQL jar包中Connection接口的实现类对象这个实现类重写了Connection接口的方法 第一种想法是:继承类找到jar包中Connection接口的实现类,重写close(),但有以下几方面问题:1.这个类,在jar包,需要通过反射找到相关类2.更换其他数据库jar包后,还要重新找,重新重写3.Java只支持单继承,如果继承一个类,就不能继承其他类,使用起来有限制第二中想法是:实现接口实现java.sql.Connection接口,即使更换jar包,连接池依然可用步骤:1.自定义实现类MyConnection实现Connection接口,重写里面的所有方法2.在MyConnection类中传入一个Connection接口对象con,方法中除了自己要重写的方法外,其余的方法都要调用con原来的方法实现,即MySQL jar包下Connection接口的实现类重写的方法3.需要重写的方法,不再调用con原来的方法实现,而是自定义实现MyConnection对象相对于Connection对象,前者包裹了后者,可以调用后者的功能,并且进行了功能增强,称之为装饰设计模式 MyConnection代码实现1234567891011121314151617181920212223public class MyConnection implements Connection &#123; //创建一个连接对象 private Connection con; //创建一个集合,存连接对象,这个集合对象pool也就是连接池对象 private LinkedList&lt;Connection&gt; pool; //定义有参构造 public MyConnection(Connection con,LinkedList&lt;Connection&gt; pool)&#123; this.con = con; this.pool = pool; &#125; @Override public void close() throws SQLException &#123; //con.close(); 这样写的话就是释放资源了 pool.add(this);//存回缓存池,this代表调用者 &#125; ...还有N多方法不需要增强,但也需要重写,如下,就不一一列举了 @Override public PreparedStatement prepareStatement(String sql) throws SQLException &#123; return con.prepareStatement(sql);//调用con原来的方法实现 &#125;&#125; MyPool代码实现123456789101112131415161718192021222324252627282930public class MyPool &#123; public static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;(); static &#123; for(int i = 0; i &lt; 3; i++)&#123; pool.add(getCon()); &#125; &#125; private static Connection getCon()&#123; Connection con = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); //----------------------关键步骤------------------------ Connection conByJar = DriverManager.getConnection("jdbc:mysql://localhost:3306/geekhoon", "root", "root"); //将Connection接口的实现类对象和连接池pool作为参数,传入有参构造,重写close() con = new MyConnection(conByJar,pool);//con的close()就已经重写啦 //----------------------------------------------------- &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; return con; &#125; public static Connection getConByPool()&#123; if(!pool.isEmpty())&#123; return pool.remove(); &#125; else &#123; return getCon(); &#125; &#125;&#125; 测试类代码实现123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; Connection con1 = MyPool.getConByPool(); System.out.println(con1); Connection con2 = MyPool.getConByPool(); System.out.println(con2); Connection con3 = MyPool.getConByPool(); System.out.println(con3); Connection con4 = MyPool.getConByPool(); System.out.println(con4); con1.close(); con2.close(); con3.close(); con4.close(); System.out.println(MyPool.pool);//打印集合中有4个元素 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bootstrap]]></title>
      <url>%2F2017%2F03%2F26%2FJavaWeb-04-Bootstrap%2F</url>
      <content type="text"><![CDATA[概述1. 是基于HTML,CSS,JS的前端框架(半成品). 只需要提供固定的HTML结构,添加固定的css样式,就可以完成指定效果的实现 框架------&gt; 也是一种封装,封装的高级形式 封装------&gt; 方法---&gt;类(Java中封装特指类)---&gt;jar包---&gt;框架 1. jar包-----&gt; 封装的是某个功能模块(侧重于功能实现) 2. 框架------&gt; 封装的是流程(结构性封装) 2. 在JQuery的基础上实现的,是JQuery的插件 作用1. 内置了一些常见的复杂的页面实现(封装了一些常见功能) 2. 可以实现响应式布局(根据响应终端自适应显示) 根据访问终端屏幕的大小,动态的改变显示样式(只提供一套代码即可) Bootstrap开发环境1. 引入JQuery实现,注意版本必须兼容 2. 将dist目录下的css font js文件夹复制到当前项目 注意: 这些文件夹必须平级 Bootstrap容器编写页面(界面),必然涉及的概念: 1. 容器: 存储页面元素的一个组件 2. 布局: 怎么在容器排放组件 容器: 1. 容器1: * 语法: &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; * 效果: 大页面下两端有留白 2. 容器2: * 语法: &lt;div class=&quot;container-fluid&quot;&gt;&lt;/div&gt; * 效果: 两端无留白 拓展: 我们只声明了class,但效果显现了,这个class怎么运行的? 在引入的css文件中,编写相关的class样式了 So: class写错,可能识别不了,因为class值都是Bootstrap内置好的,不能随便使用 Bootstrap布局栅格(表格)系统: 1. 栅格本质是表格 ---- 行与列是两要素 2. 行与列实现 1. 行 --- &lt;div class=&quot;row&quot;&gt;&lt;/div&gt; --- 可以写多个,代表多行 2. 列 --- &lt;div class=&quot;col-屏幕代号-比例&quot;&gt;&lt;/div&gt; * Bootstrap中一行默认12单元列,编写的列必须声明一个所占的单元列数 注意: 1. 12列是一个折中方案 2. 行中分配列: * 所有列(比例)相加和为12 * 小于12,空余部分不做处理 * 大于12,大于12的部分会自动换行 响应式布局机制1. Bootstrap将屏幕划分为四大类: 1. 超小屏幕 &lt;= 768px ---- xs 2. 小屏幕: 768 - 992 ---- sm 3. 中等屏幕: 992 - 1200 - md 4. 大屏幕: &gt;= 1200px ---- lg 2. 响应式布局的代码实现 要设置某个屏幕下的占比 --- col-屏幕代号-占比 现象: 1. 如果只设置lg,其余屏幕不按照占比分配 2. 如果只设置xs,其余屏幕按照占比分配 原则: 小屏幕优先,如果屏幕比我大,但是没设置占比,就按照我的占比来 如果屏幕比我小,但是没设置占比,默认是换行,不受我的占比影响 补充: 一个class属性可以设置多个值,不同值之间使用空格隔开 3. 拓展需求: 某些页面元素可能在某些屏幕下显示,某些屏幕下不显示: 语法: 方式1:(设置显示) 添加class visible-屏幕代号 方式2:(设置隐藏) 添加class hidden-屏幕代号 效果: 在指定屏幕下显示(或隐藏),没有指定的不显示(或隐藏),没有小屏优先,必须严格对应 基本模板123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="../css/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="../js/jquery-1.11.3.min.js"&gt;&lt;/script&gt; &lt;script src="../js/bootstrap.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery]]></title>
      <url>%2F2017%2F03%2F23%2FJavaWeb-03-JQuery%2F</url>
      <content type="text"><![CDATA[概述核心理念: write less,do more 作用: 动态地修改内存中的html或css代码 1. JQuery是一个JavaScript框架,是对JS的封装,将一些常见的JS操作进行了封装,提高开发效率 JQuery与JS的区别:类似与commons-io与JDK内置IO的关系 2. 兼容CSS3 3. 相对于JS,能更好地兼容浏览器(并没有完全兼容) JQuery的使用1. JQuery是一个第三方实现,必须下载相关实现库 2. 将实现库导入当前项目,类似于Java导入jar包 3. 当前HTML页面引入JQuery &lt;script src=&quot;JQuery路径&quot;&gt;&lt;/script&gt; JQuery语法记: JQuery是将JS对象的属性操作函数化了 注: JQuery中频繁使用jQuery函数,简化成一个$,二者等价 变量: var $变量名 = $(&quot;选择器&quot;); 变量名前可以加$,代表是JQuery对象,区别于JS对象 alert($变量名);//打印的是object Object代表是JQuery对象 注释: /*注解*/ //注解 获取JQuery对象123456789101112131415161718192021222324252627282930方式1: 选择器获取 1. 标签名(返回的是数组) var vs = $("标签名"); ====等价于==== document.getElementByTagName("标签名") 2. 类名(返回的是数组) var vs = $(".类名"); ====等价于==== document.getElementByClassName("类名") 3. id(其实吧,id选择器返回的也是数组,只是数组长度为1罢了) var v = $("#id"); ====等价于==== document.getElementById("id")方式2: 1. 获取JS对象 2. 转换成JQuery对象 语法: var v = $(JS对象); 拓展: JQuery对象转换成JS对象: (不适用于数组) 语法(两种): var v = $("选择器")[index]; //如JQuery对象[0]; var v = $("选择器").get(index); 备注: JQuery对象转换成JS对象,数组不适用值得是JS数组,比如下面的例子 但是如果是JQuery数组,是可以转成JS对象的,因为一句很重要的话: JQ数组中每个元素都是JS对象 //JQuery 对象转 JS 对象注意 $(function()&#123; var arr1 = new Array("a","b","c"); //JS数组转成 JQuery对象 var arr2 = $(arr1); //arr2转为JS对象 var arr3 = arr2[0]; alert(arr3); //打印a,所以说这种数组不适用这种转换方式 &#125;) //这种情况并不常见, JS对象转成JQ对象再转成JS....(似乎没什么意义) 操作JQuery对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546 * HTML代码/文本/值: $("选择器").html(); --&gt;获取内容体; $("选择器").html("文本/标签"); --&gt;设置内容体; $("选择器").text(); --&gt;获取文本; $("选择器").text("文本"); --&gt;设置文本; $("选择器").val(); --&gt;获取value值; $("选择器").val("新值"); --&gt;设置value值; * 属性: $("选择器").prop("属性名"); --&gt;获取属性值; $("选择器").prop("属性名","属性值"); --&gt;设置属性; * CSS类: $("选择器").css("属性名") --&gt;获取指定css样式; $("选择器").css("属性名","属性值") --&gt;设置css样式; $("选择器").addClass("class名"); --&gt;添加新的"样式类"; $("选择器").removeClass("class名"); -&gt;移除指定"样式类"; * 文档操作: 内部(子元素): $A.append($B) --&gt;将$B追加到$A内部后; $A.appendTo($B) --&gt;将$A追加到$B内部后;($A的$不能去掉,因为appendTo是JQuery方法) $A.prepend($B) --&gt;将$B添加到$A内部前; $A.prependTo($B) --&gt;将$A添加到$B内部前; 外部(兄弟元素): $A.after($B) --&gt;将$B添加到$A之后; $A.before($B) --&gt;将$B添加到$A之前; $A.insertAfter($B) --&gt;将$A添加到$B之后; $A.insertBefore($B) --&gt;将$A添加到$B之前;拓展: prop之前是attr函数,后者由于兼容性问题已废弃注意:1. prop和.css使用: 设置样式时使用css,因为不是所有的属性都能通过prop改 比如,tr中的bgcolor2. html()和text()区别: 相同点: 二者都可以获取和设置内容体 不同点: (1)获取内容体: html() ---&gt; 标签+文本 text() ---&gt; 纯文本 (2)设置内容体: html("") -&gt; 如果设置的内容有标签,标签会被浏览器解析 text("") -&gt; 如果设置的内容有标签,标签不会被浏览器解析,被当作普通文本 在html中常用html() 在xml中常用text()3. $A.append($B)举例: $("#id值").append("&lt;option&gt;北京&lt;/option&gt;"); $A.appendTo($B): $("&lt;option&gt;北京&lt;/option&gt;").appendTo($("#id值")); 12345678910111213更改样式时,推荐使用css进行更改,因为prop不是什么属性都能更改&lt;script&gt; $(function()&#123; var v = $("#t1"); v.prop("bgcolor","red");// 这种是改不了的 v.css("background-color","red"); //正解 &#125;)&lt;/script&gt;&lt;table border="1px" cellpadding="0" cellspacing="0"&gt; &lt;tr id="t1" bgcolor="blue" &gt; &lt;td&gt;haha&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 1234567891011121314151617181920212223242526272829303132333435html()和text()使用:首先要明白:1. 当设置值时,$(选择器).html("")和$(选择器).text("")更改的都是选择器下所有内容,而不是text只设置文本值了2. 获取值是,html()会获取包括标签在内的所有内容 text()只能获取标签内的文本内容&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; var v = $("#d1"); alert(v.html());//&lt;font color="red"&gt;红&lt;/font&gt; alert(v.text());//红 v.html("&lt;font color='blue'&gt;蓝&lt;/font&gt;"); alert(v.html());//&lt;font color='blue'&gt;蓝&lt;/font&gt; alert(v.text());//蓝 v.text("黑"); alert(v.html());//黑 alert(v.text());//黑 v.text("&lt;font color='black'&gt;黑&lt;/font&gt;"); //下面这句,尖括号进行了转义 alert(v.html());//&amp;lt;font color='black'&amp;gt;黑&amp;lt;/font&amp;gt; alert(v.text());//&lt;font color='black'&gt;黑&lt;/font&gt; &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="d1"&gt; &lt;font color="red"&gt;红&lt;/font&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839文档操作:需求:分别在div前后添加start和end,观察区别观察结果得出的结论:利用$A.prependTo($B)和$A.appendTo($B)添加时:$A必须是JQuery对象,不能直接编写一个标签字符串"&lt;font&gt;abc&lt;/font&gt;"当然直接编写一个不含标签的字符串,如"abc"就更不行了因为prependTo和appendTo函数是JQuery的特有函数,字符串是无法调用的&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; /* * 添加start */ //方式1: $("#d1").prepend("start1");//start1div $("#d1").prepend("&lt;font&gt;start2&lt;/font&gt;");//start2start1div //方式2: $("start3").prependTo($("#d1"));//并没有任何改变!!! $("&lt;font&gt;start4&lt;/font&gt;").prependTo($("#d1"));//start4start2start1div /* * 添加end */ //方式1: $("#d1").append("end1");//divend1 $("#d1").append("&lt;font&gt;end2&lt;/font&gt;");//divend1end2 //方式2: $("end3").appendTo($("#d1"));//并没有任何改变!!! $("&lt;font&gt;end4&lt;/font&gt;").appendTo($("#d1"));//divend1end2end4 &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="d1"&gt;div&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 加载123456789101112JQuery页面加载: 方式1: $(function() &#123; //内容体; &#125;) 方式2: $(document).ready(function() &#123; //内容体; &#125;) JS页面加载与JQuery页面加载的比较:1. JS页面加载属于属性操作,加载多次,最后面的会覆盖前面的(属性操作的特点)2. JQuery页面加载属于函数操作,加载多次,执行多次,因为函数每被调用一次,执行一次 事件123456789101112 JS中: JS对象.onXXX = function()&#123;&#125; JQ中: JQ对象.XXX(function()&#123;&#125;);* 常用事件: click(); --&gt;点击事件; submit(); --&gt;表单提交事件; focus(); --&gt;聚焦事件; blur(); --&gt;失焦事件; mouseover(); --&gt;鼠标移入事件; mouseout(); --&gt;鼠标移出事件; change(); --&gt;元素值改变事件; 自实现循环123456789101112131415161718192021222324取出数组的每一个元素，分别调用function，调用时传入索引以及当前元素方式1: $.each(jQuery数组, function(index,obj)&#123; //内容体; &#125;)方式2: jQuery数组.each(function(index,obj)&#123; //内容体; &#125;)举例:&lt;script&gt;var arr = ["a","b","c"];//转换成 JQuery数组var arr2 = $(arr);//循环 --- 取出每一个元素//方式1:$.each(arr2, function(p1,p2) &#123; alert(p1 + " ---- " + p2);&#125;);//方式2:arr2.each(function(p1,p2)&#123; alert(p1 + " ---- " + p2);&#125;);&lt;/script&gt; 优化写法1234567891011121314有些循环不需要索引，此时可以在函数中不传参数，直接使用 this 代表当前元素&lt;script&gt;var arr = ["a","b","c"]; //转换成 JQuery数组 var arr2 = $(arr); //循环 --- 取出每一个元素 /*arr2.each(function()&#123; alert(this); &#125;);*/ $.each(arr2, function() &#123; alert(this); &#125;);&lt;/script&gt; 选择器基本选择器12345 格式:1. $("标签名") --------&gt; 元素选择器; 2. $("#ID值") ---------&gt; id选择器; 3. $(".class值") ------&gt; class类选择器; 4. $("*") -------------&gt; 匹配所有; 层级选择器12345 格式:1. $("选择器1 选择器2") --------&gt; 获取1标签下的所有子级和孙子级2标签2. $("选择器1&gt;选择器2") ------&gt; 获取1标签下的所有子级(不包含孙子级)2标签3. $("选择器1+选择器2") ------&gt; 获取1标签的同级向下第一个兄弟级2标签4. $("选择器1~选择器2") ------&gt; 获取1标签的同级向下所有兄弟级2标签 基本过滤选择器(待整理)1234567891011 格式: (带空格代表子级孙子级,不带空格代表同级)1. $("选择器:first"); --------&gt; 获取匹配的第一个(同级);2. $("选择器:last"); --------&gt; 获取匹配的最后一个(同级);3. $("过滤器1 :first") --------&gt; 获取过滤器1下的第一个子级元素4. $("过滤器1 :last") --------&gt; 获取过滤器1下的最后一个子级元素5. $("过滤器1 标签2:even(偶数)/odd(奇数)") -&gt; 获取过滤器1下所以标签2,取出标签2的奇数或偶数标签2 索引从0开始6. $("选择器:not(选择器)"); --&gt; 去除与给定选择器匹配的;7. $("选择器:eq(index)"); --&gt; 获取匹配的脚标为指定的;8. $("选择器:gt(index)"); --&gt; 获取匹配的脚标大于指定的;9. $("选择器:lt(index)"); --&gt; 获取匹配的脚标小于指定的; 属性选择器12345678 格式: 1. $("选择器[属性名]") --------&gt; 获取所有属性名属性的标签 2. $("选择器[属性名 = '值']") --------&gt; 获取所有属性名等于某值的标签3. $("选择器[属性名 != '值']") -------&gt; 获取所有属性名不等于某值的标签4. $("选择器[属性名 ^= '值']") -------&gt; 获取属性值以指定值开头的;5. $("选择器[属性名 $= '值']") -------&gt; 获取属性值以指定值结尾的;6. $("选择器[属性名 *= '值']") -------&gt; 获取属性值包含指定值的;7. $("选择器[属性名1 = '值'][属性名2 = '值']") --------&gt; 复合条件 表单属性选择器(重点)1234567 格式: 1. $("input:enabled") --------&gt; 获取所有可用的input标签的表单输入项2. $("input:disabled") -------&gt; 获取所有不可用的input标签的表单输入项3. $("input:checked") --------&gt; 获取所有被选定的复选框4. $("#selected的id值 option:selected") ---&gt; 获取所有下拉列表中被选定的项 拓展: 实现相同的效果,不一定使用一样的选择器 JQuery内置的显示与隐藏1234567891011121314151617181920212223242526272829* 基本实现: 1. 显示 1. show(): 直接显示 2. show(毫秒值): 在指定时间内慢慢显示 3. show(毫秒值,function()&#123;&#125;): 显示完毕后,调用函数 2. 隐藏 1. hide(): 直接隐藏 2. hide(毫秒值): 在指定时间内慢慢隐藏 3. hide(毫秒值,function()&#123;&#125;): 隐藏完毕后,调用函数 3. 切换 1. toggle(): 根据当前显示/隐藏状况,进行切换 2. toggle(毫秒值)* 滑动实现 1. 显示 1. slideDown() 2. slideDown(毫秒值) 2. 隐藏 1. slideUp() 2. slideUp(毫秒值)* 淡入淡出 1. 显示 1. fadeIn() 2. fadeIn(毫秒值) 2. 隐藏 1. fadeOut() 2. fadeOut(毫秒值) 3. 切换 1. fadeToggle() 2. fadeToggle(毫秒值) validate概述1. 一个校验框架,对表单校验的一个封装,是一个第三方实现,并且是JQuery的一个插件 使用前提: 1. 导入JQuery 2. 导入validation相关实现 2. 下载validation相关实现 3. 环境搭建 1. 引入jquery.validate.js文件 2. 在当前html中导入该文件 4. 表单校验两要素: 1. 校验规则rules 2. 提示信息messages validation使用: 1. 参考validation资料中的demo文件夹 validation语法jquery表单对象.validate({ // 规则 rules:{ 字段名(name值):{ 校验器:取值, 校验器:取值 }, 字段名(name值):{ 校验器:取值, 校验器:取值 } }, // 提示信息 messages:{ 字段名(name值):{ 校验器:&apos;提示信息(自定义)&apos;, 校验器:&apos;提示信息(自定义)&apos; }, 字段名(name值):{ 校验器:&apos;提示信息(自定义)&apos;, 校验器:&apos;提示信息(自定义)&apos; } } }) &lt;!-- 指定提示信息显示位置 class=&apos;error&apos; 固定; for=&apos;&apos; 绑定字段名(name值); --&gt; &lt;label for=&quot;gender&quot; class=&quot;error&quot;&gt;&lt;/label&gt; 校验规则这些校验规则是 validation 内置好的，我们按照语法规范调用这些校验类型即可 * A、required ---- 必填 ----- true | false * B、rangelength - 长度 ----- [最小长度,最大长度] * C、eamil ------- 邮箱 ----- true | false * D、date -------- 日期 ----- true | false * 日期以后一般使用下拉列表选择 * E、number ------ 数字 ----- true | false * F、min(max) ---- 最小(大)值- 具体数字 * G、range ------- 数字取值 --- [最小值,最大值] * H、euqalTo ----- 内容是否一样- JQuery选择器 错误提示信息1. 错误提示好多都是通用的,validation中已经内置了一些现成的错误提示 2. 如果不想自己编写错误提示的话,可以使用默认的,直接不编写 messages 部分 3. 但是不建议使用默认的,因为自定义的描述性更强 自定义校验器$.validator.addMethod(name, method, messages); name:校验器名称; method:校验处理函数 function(value, element, params){ value:被校验的表单项的value值; element:被校验的表单项对象; params:规则参数; 方法体: 校验实现,返货true代表通过,false代表不符合规则 } messages:错误提示信息; 改变提示信息的样式查原码可知,validate会将错误信息放在一个label中,样式为&quot;error&quot;,故这里定义一个同名的样式类: &lt;style type=&quot;text/css&quot;&gt; .error { color: red; } &lt;/style&gt; 国际化(语言包)1234567(i18n)程序不变,在不同地区显示其本地的语言;* 国际化怎么实现？ 1. 程序主体 2. 程序集成语言包* validation 中的国际化 * dist 内置不同的语言包,当前项目引入该语言包 &lt;script type="text/javascript" src="../js/messages_zh.js" &gt;&lt;/script&gt; 案例定时广告123456789101112131415161718&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; var gg = $("#gg"); window.setTimeout(function()&#123; //gg.css("display","block"); gg.slideDown(2000); window.setTimeout(function()&#123; //gg.css("display","none"); gg.slideUp(2000); &#125;,3000); &#125;,1000); &#125;)&lt;/script&gt;&lt;div id = "gg" style="display: none;"&gt; &lt;img src="../img/image/3.jpg" width="100%"/&gt;&lt;/div&gt; 隔行换色12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;style&gt; .jishu &#123; background-color: #13777E; &#125; .oushu &#123; background-color: red; &#125; .pink&#123; background-color: pink; &#125;&lt;/style&gt;&lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; //var trs = $("tr[id != 'header']"); var jishu = $("tr[id != 'header']:odd"); //alert(jishu.length); jishu.prop("class","jishu"); var oushu = $("tr[id != 'header']:even"); oushu.prop("class","oushu"); var temp; $("tr[id != 'header']").mouseover(function()&#123; temp = $(this).prop("class"); $(this).prop("class","pink"); &#125;); $("tr[id != 'header']").mouseout(function()&#123; $(this).prop("class",temp); &#125;); &#125;)&lt;/script&gt;&lt;table border="1" cellpadding="0" cellspacing="0" width="80%"&gt; &lt;tr id="header"&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品描述&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;手机数码&lt;/td&gt; &lt;td&gt;手机数码商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;电脑办公&lt;/td&gt; &lt;td&gt;电脑办公商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;鞋靴箱包&lt;/td&gt; &lt;td&gt;鞋靴箱包商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;家居饰品&lt;/td&gt; &lt;td&gt;家居饰品商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 复选框全选/反选1234567891011121314151617181920212223242526272829303132333435363738394041424344454647反选时,常规思路是 1. 取当前checkbox数组的选定状态 var b = $(".itemSelect").prop("checked"); 2. 设置反值 $(".itemSelect").prop("checked",!b);但这样是错误的.当前结果是所有复选框取第一个复选框的反值,因为: 1. 获取数组的属性值时，没有循环，获取的是第一个元素的值 2. 设置时，每一个元素根据第一个元素的值取反我们需要知道的是:数组.prop("属性","值") 设置时,底层封装了一个循环,遍历数组的每一个元素分别设置prop的值但是呢? 并不是所有的属性底层都封装了一个循环,隔行换色案例中的class封装了,本例中的checked就没有封装循环.所以解决方案是: 自实现循环&lt;script&gt; $(function()&#123; $("#all").click(function()&#123; $(".itemSelect").prop("checked",true); &#125;); $("#none").click(function()&#123; $(".itemSelect").prop("checked",false); &#125;); $("#fan").click(function()&#123; /* 错误写法: var b = $(".itemSelect").prop("checked"); $(".itemSelect").prop("checked",!b); */ /* 自定义循环写法1: //1、获取所有的复选框 $(".itemSelect").each(function()&#123; //获取当前复选框的状态 var b = $(this).prop("checked"); //取反值 $(this).prop("checked",!b); &#125;); */ 自定义循环写法2: $.each($(".itemSelect"), function() &#123; var b = $(this).prop("checked"); $(this).prop("checked",!b); &#125;); &#125;); &#125;)&lt;/script&gt; 表单校验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160 表单校验需求: 错误提示信息为红色 错误提示显示在输入项下面 自定义校验类型,用户名不能包含敏感词汇 * 首先要知道validation是如何显示错误提示的 1. 在输入项后面内置了一个标签,显示提示信息 &lt;label id="" class="error" for="name值"&gt;&lt;/label&gt; 2. 修改为红色,可以设置 CSS 属性 所有的错误提示有相同的标签和相同的class---error 3. 可以自定义错误出现的位置 默认位置 ---- 紧跟当前 input &lt;label class="error" for="name值"&gt;&lt;/label&gt; 或 &lt;label class="error" for="id值"&gt;&lt;/label&gt; 注意上面这两种形式:如果&lt;input&gt;标签内设置id了,只能使用for="id值" 如果只设置了name值,可以使用for="name值" 自定义的label标签，位置可以随意存储&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; /*label &#123; color: red; &#125;*/ .error &#123; color: red; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script src="../js/jquery.validate.js"&gt;&lt;/script&gt; $.validator.addMethod("my",function(v)&#123; /* * 如果包含 具体的数字 &gt;= 0 false ----- 非法 * 如果不包含 -1 ------ true ----- 合法 * */ return v.indexOf("falungong") == -1; &#125;,"不能包含政治敏感词"); $(function()&#123; $("#f1").validate(&#123; rules:&#123; username:&#123; required:true, rangelength:[6,10], my:true &#125;, email:&#123; required:true, email:true &#125;, birthday:&#123; date:true &#125;, sal:&#123; number:true, min:1600 &#125;, workForday:&#123; range:[6,16] &#125;, pwd:&#123; required:true &#125;, repwd:&#123; required:true, equalTo:"input[name='pwd']" &#125; &#125;, //提示信息部分 messages:&#123; username:&#123; required:"账号必须填写", rangelength:"长度必须在6-10个字符之间" &#125;, email:&#123; required:"邮箱必填", email:"邮箱不符合规则" &#125;, birthday:&#123; date:"日期格式不对" &#125;, sal:&#123; number:"必须是数字", min:"至少1600块" &#125;, workForday:&#123; range:"一天工作时长必须在6-16个小时之间" &#125;, pwd:&#123; required:"密码必填" &#125;, repwd:&#123; required:"必须填写确认密码", equalTo:"两次密码不一致" &#125; &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id="f1"&gt; &lt;table border="1" width="100%" cellpadding="0" cellspacing="0"&gt; &lt;tr&gt; &lt;td colspan="3"&gt;&lt;font color="cornflowerblue" size="5"&gt;测试表单&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名（必填字段，长度范围6~10）&lt;/td&gt; &lt;td colspan="2"&gt; &lt;input type="text" name="username" /&gt; &lt;br/&gt; &lt;label id="unmsg" class="error" for="username"&gt;&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Email（符合邮件格式）&lt;/td&gt; &lt;td colspan="2"&gt; &lt;input type="text" name="email" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期（日期格式）&lt;/td&gt; &lt;td colspan="2"&gt; &lt;input type="text" name="birthday" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;薪资（数字）&lt;/td&gt; &lt;td colspan="2"&gt; &lt;input type="text" name="sal" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;一天工作时长（值范围6~16）&lt;/td&gt; &lt;td colspan="2"&gt; &lt;input type="text" name="workForday" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码（必须填写）&lt;/td&gt; &lt;td colspan="2"&gt; &lt;input type="text" name="pwd" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码（必须填写，且与密码值要相同）&lt;/td&gt; &lt;td colspan="2"&gt; &lt;input type="text" name="repwd" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="注册" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 省市联动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script&gt; // 定义二维数组,存储城市信息 var cities = new Array(); cities[0] = new Array("海淀","昌平"); cities[1] = new Array("长春市","吉林市","松原市","延边市"); cities[2] = new Array("济南市","青岛市","烟台市","潍坊市","淄博市"); cities[3] = new Array("石家庄市","唐山市","邯郸市","廊坊市"); cities[4] = new Array("南京市","苏州市","扬州市","无锡市"); //方式1: function run(node)&#123; //node拿到的是当前选中的option对象 var cs = cities[$(node).val()] var $s2 = $("#city"); $s2.html("&lt;option value=''&gt;----请-选-择-市----&lt;/option&gt;"); $.each(cs,function()&#123; var opt = "&lt;option&gt;"+this+"&lt;/option&gt;"; $s2.html($s2.html() + opt); &#125;); &#125; //方式2:(优化) function run(node)&#123; var cs = cities[$(node).val()]; var $s2 = $("#city"); $s2.html("&lt;option value=''&gt;----请-选-择-市----&lt;/option&gt;"); $.each(cs,function()&#123; var opt = "&lt;option&gt;"+this+"&lt;/option&gt;"; //$s2.append(opt); $(opt).appendTo($s2); &#125;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;select id="province" style="width:150px" onchange="run(this)"&gt; &lt;option value=""&gt;----请-选-择-省----&lt;/option&gt; &lt;option value="0"&gt;北京&lt;/option&gt; &lt;option value="1"&gt;吉林省&lt;/option&gt; &lt;option value="2"&gt;山东省&lt;/option&gt; &lt;option value="3"&gt;河北省&lt;/option&gt; &lt;option value="4"&gt;江苏省&lt;/option&gt; &lt;/select&gt; &lt;select id="city" style="width:150px"&gt; &lt;option value=""&gt;----请-选-择-市----&lt;/option&gt; &lt;/select&gt; &lt;/body&gt;&lt;/html&gt; 左右选择1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.0.js" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $s1 = $("#leftSelectId"); $s2 = $("#rightSelectId"); $btn1 = $("#leftToRightSimple"); $btn1.click(function()&#123; //错误写法:(一定注意这种) //$leftSelected = $("$s1 option:selected"); $leftSelected = $("#leftSelectId option:selected"); //方式1: $.each($leftSelected, function() &#123; $s2.append(this); &#125;); //方式2: //$s2.append($leftSelected); //注意:如果移动到右边时,左边不想删除,要这样写: //$s2.append($leftSelected).clone(); &#125;); $btn2 = $("#leftToRight"); $btn2.click(function()&#123; $leftall = $("#leftSelectId option"); $s2.append($leftall); &#125;); $btn3 = $("#rightToLeftSimple"); $btn3.click(function()&#123; $rightSelected = $("#rightSelectId option:selected"); $s1.append($rightSelected); &#125;); $btn4 = $("#rightToLeft"); $btn4.click(function()&#123; $rightall = $("#rightSelectId option"); $s1.append($rightall); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;select id="leftSelectId" multiple="multiple" style="width: 100px;height: 200px;"&gt; &lt;option&gt;左1&lt;/option&gt; &lt;option&gt;左2&lt;/option&gt; &lt;option&gt;左3&lt;/option&gt; &lt;option&gt;左4&lt;/option&gt; &lt;option&gt;左5&lt;/option&gt; &lt;/select&gt; &lt;input type="button" value="》" id="leftToRightSimple" /&gt; &lt;input type="button" value="》》" id="leftToRight" /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type="button" value="《" id="rightToLeftSimple" /&gt; &lt;input type="button" value="《《" id="rightToLeft" /&gt; &lt;select id="rightSelectId" multiple="multiple" style="width: 100px;height: 200px;"&gt; &lt;option&gt;右1&lt;/option&gt; &lt;option&gt;右2&lt;/option&gt; &lt;option&gt;右3&lt;/option&gt; &lt;option&gt;右4&lt;/option&gt; &lt;option&gt;右5&lt;/option&gt; &lt;/select&gt; &lt;hr /&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript]]></title>
      <url>%2F2017%2F03%2F20%2FJavaWeb-02-JavaScript%2F</url>
      <content type="text"><![CDATA[概述* 概念: * 是基于对象和事件驱动的脚本语言, 用于开发交互式web页面 * 解释型语言,不需要进行编译,由浏览器执行 * 作用: * 动态的修改内存中的html和css * 组成部分: 1. 基本语法部分 ---&gt; ECMAScript ---&gt; 规范了JS使用基本语法 2. 浏览器对象 -----&gt; BOM ----------&gt; Browser Object Model (浏览器内置对象) 3. 文档对象 -------&gt; DOM ----------&gt; Document Object Model (HTML文档以及文档的每一个标签,都被JS当作对象) * 学习路线: 1. 基本语法 (1)变量 运算符 流程控制 (2)方法 2. 面向对象 (3)获取对象(和Java不同,Java对象大多数要自己创建,JS是获取内置好的对象) (4)操作对象 12345678910111213141516171819202122232425使用: 1.内部脚本: &lt;script type="text/javascript"&gt; /** * js脚本; */ &lt;/script&gt; 2.外部脚本: 1)编写*.js文件,内部编写脚本; first.js: /** * js脚本; */ 2)在*.html中引入脚本文件; *.html: &lt;script type="text/javascript" src="js/first.js"&gt; /** * 这里不能在写js脚本; */ &lt;/script&gt;&gt; 注意: (1)外部JS文件一般存储在JS目录中 (2)方案二引入的外部JS文件时,&lt;script&gt;标签中不能再编写其他JS代码 (ECMAScript)基本语法变量1.声明格式: var 变量名; --&gt;js变量可以不声明,直接使用,默认值:undefined; var 变量名 = 值; --&gt;js变量是弱类型,即同一个变量可以存放不同类型的数据; var在JS中是一个关键字,代表变量 2.变量命名规则: 1)必须以字母或下划线开头,中间可是数字,字母或下划线或$; 2)变量名不能包含空格等符号; 3)不能使用能够Js关键字作为变量名; 4)js严格区分大小写; 3.变量值可以是任意类型,并且可以被重复赋其他类型的值 数据类型分类: 基本类型: 1. number数字类型 ---&gt; 整型,浮点 2. boolean布尔类型 ---&gt; true,false 3. string字符串类型 -&gt; &quot;&quot; 或 &apos;&apos; 包裹 4. null --&gt; 空类型 5. undefined -&gt; 未定义,null的衍生,变量只声明不赋值时,就是undefined undefinerd == null :结果是true 引用类型: Object 拓展: (1)NaN ---&gt; not a number :JS中非数字运算得出的结果 (2)typeof(变量) ---&gt; 返回当前变量的数据类型 运算符JS特殊运算符: == : 比较值而不比较数据类型 ===: 既比较值也比较数据类型 流程控制在判断语句中,JS会将相关数据类型转成对应的boolean值,和Java不同 12345678for(var i=1;i&lt;=3;i++)&#123; window.alert(i);&#125;if(1)&#123; window.alert("true");&#125;else&#123; window.alert("false");&#125; 函数12345678910111213141516171819202122232425262728293031321.概念 Java --- method --- 方法 Js ----- function - 函数2.函数声明 普通函数: function 函数名(参数名即可)&#123; // 函数体; &#125; 举例: function getSum(num1,num2)&#123; return num1 + num2; &#125; 匿名函数: var 函数名 = function(参数名即可)&#123; // 函数体; &#125;3.调用 var result = getSum(1,2); --- 标准调用 特殊:JS调用函数,可以传入与函数声明不一致的参数列表,如: var result = getSum(1); //result值为NaN4.注意 (1)JS没有重载的概念 (2)JS中只依赖于函数名调用,不考虑参数列表,如果函数名相同,后面的会覆盖前面的 function get(num1,num2)&#123; window.alert("get1"); &#125; function get(num1)&#123; window.alert("get2"); &#125; get(1,2); //打印的是get2 BOM对象(浏览器对象模型)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182概述: * JS是基于对象的,对象不是自己new的,而是获取第三方内置的对象,来使用 * 浏览器内置的对象就是BOM对象常用对象 1. window对象 --- 当前浏览器内置的对象 * alert("信息") --&gt;警告框; * confirm("信息") --&gt;确认框(确认返回true,取消返回false); var flag = confirm(""); * prompt("信息") --&gt;输入框(确认返回输入的数据,取消返回false); var txt = prompt(""); 凡是window对象的方法,都可以不加window前缀 2. window计时器--两种:往复性计时器和一次性计时器 底层： 为计时器开启一个线程，线程中隔一会调用一次函数 (1)setInterval(code(代码),millisec(毫秒)) --&gt;循环定时器(这个方法会返回一个id值,是当前定时器的标识); 1): function fun01() &#123; /** * 内容; */ &#125; window.setInterval(fun01, 2000); 2): function fun01() &#123; /** * 内容; */ &#125; window.setInterval("fun01()", 2000); 3): window.setInterval(function() &#123; /** * 内容; */ &#125;, 2000); clearInterval(id) --&gt;取消定时器; 举例: var id = window.setInterval(function()&#123; alert("----"); &#125;,3000); //通过编号清除 window.clearInterval(id); (2)setTimeout(code(代码),millisec(毫秒)) --&gt;执行一次定时器(这个方法会返回一个id值,是当前定时器的标识); 1): function fun01() &#123; /** * 内容; */ &#125; window.setTimeout(fun01, 2000); 2): function fun01() &#123; /** * 内容; */ &#125; window.setTimeout("fun01()", 2000); 3): window.setTimeout(function() &#123; /** * 内容; */ &#125;, 2000); clearTimeout(id) --&gt;取消定时器; 3. location: location.href = "资源路径";跳转到一个新的页面; 举例: &lt;script&gt; function toIndex()&#123; //执行跳转 location.href = "../../index.html"; &#125; &lt;/script&gt;&gt; &lt;body&gt; &lt;input type="button" value="首页" onclick="toIndex()" /&gt; &lt;/body&gt; 4. history: history.go(); --&gt;go(-1) 后退,go(1) 前进; history.back(); 后退; history.forward();前进 举例: 12345678910111213141516171819202122232425262728293031第一页:&lt;html&gt; &lt;head&gt; &lt;script&gt; function toNext()&#123; //history.forward(); history.go(1); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 这是start &lt;a href="end.html"&gt;end页面&lt;/a&gt; &lt;input type="button" value="下一页" onclick="toNext()" /&gt; &lt;/body&gt;&lt;/html&gt;第二页:&lt;html&gt; &lt;head&gt; &lt;script&gt; function backToStart()&#123; //history.back(); history.go(-1); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 这是 end 页面 &lt;input type="button" value="上一页" onclick="backToStart()"/&gt; &lt;/body&gt;&lt;/html&gt; DOM对象(文档对象模型)12345678910111213141516* JS主要操作的是HTML中的内容 * 操作流程: 1. 获取要操作的标签对应的DOM对象 --- 获取 2. 操作这个DOM对象 --------------- 调用获取DOM对象方式:1. var v = document.getElementById("ID值");2. var vs = document.getElementsByClassName("类名");3. var vs = document.getElementsByName("name值");4. var vs = document.getElementsByTagName("标签名"); ----&gt; 2,3,4返回的是一个数组,数组中存放的是标签对象;调用方式:标签对象.innerHTML = ""; --&gt;重置标签内容体;标签对象.innerText = ""; --&gt;重置文本;标签对象.属性名 = "属性值"; --&gt;设置属性;标签对象.className --&gt; 获取标签的class值;标签对象.checked; --&gt; 获取当前对象的选中状态; 获取对象举例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455获取div标签对象,然后获取内容体并打印: (1)先给标签添加id (2)获取语法: var d1 = document.getElementById("id"); (3)注意加载顺序: 如果script在head中,直接调用获取语法,不能获取,因为div还没加载 解决方案: 1. 将script实现存储在div后面 2. 在body标签中添加属性onload = "函数" script中有对应的函数实现,获取div对象 执行效果: 页面加载完(注意是加载完),调用这个函数 * 方案一: &lt;div id = "d1"&gt; hello &lt;/div&gt; &lt;script&gt; var d1 = document.getElementById("d1"); alert(d1); &lt;/script&gt; * 方案二: &lt;head&gt; &lt;script&gt; function get()&#123; var d1 = document.getElementById("d1"); alert(d1); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload = "get()"&gt; &lt;div id = "d1"&gt; hello &lt;/div&gt; &lt;/body&gt; * 方案三(优化): 1. 编写函数 2. window.onload = 方法名; (方法没有括号) &lt;head&gt; &lt;script&gt; function get()&#123; var d1 = document.getElementById("d1"); alert(d1); &#125; window.onload = get; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id = "d1"&gt; hello &lt;/div&gt; &lt;/body&gt; * 方案四(优化): 匿名函数 &lt;head&gt; &lt;script&gt; window.onload = function() &#123; var d1 = document.getElementById("d1"); alert(d1); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id = "d1"&gt; hello &lt;/div&gt; &lt;/body&gt; 调用对象举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748获取font标签对象,并调用该对象内容体操作: 获取内容体 --- 标签对象.innerHTML 设置内容体 --- 标签对象.innerHTML = "新值";属性操作: 获取属性 --- 标签对象.属性名 设置属性 --- 标签对象.属性名 = "新值"注意： * class 操作必须使用相关替换 --- className&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .test1 &#123; color: red; &#125; .test2 &#123; color: green; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var f1 = document.getElementById("f1"); //内容体操作 //获取内容体 //alert(f1.innerHTML); //设置内容体 //f1.innerHTML = "haha"; //获取color属性 //alert(f1.color); //修改属性值 //f1.color = "blue"; //f1.size = "1"; var f2 = document.getElementById("f2"); //获取class 值 alert(f2.className); f2.className = "test2"; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;font id="f1" size="6" color="red"&gt;hehe&lt;/font&gt; &lt;font id="f2" class="test1"&gt;Hello&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 事件概念: 页面上的一个动作 动作可以是用户产生的 --- 用户操作 --单机,鼠标移入移出,获得失去焦点,下拉列表选定 也可以是浏览器产生的 --- 页面加载 常见事件: onload --&gt;页面加载完成事件; onsubmit --&gt;表单提交事件; onclick --&gt;单击事件; onchange --&gt;改变事件,下拉列表选项改变时触发 onfocus/onblur --&gt;焦点事件(获得焦点/失去焦点); onmouseover/onmouseout/onmousemove --&gt;鼠标事件(鼠标移入/移出/移动) onkeydown/onkeypress/onkeyup --&gt;按键事件(按键按下/按键按住/按键弹起) 注意: 1. 按键事件可以在方法中传入参数,参数有个keycode属性,可以获取当前按键对应的数字. 通过判断数字,获取按的键位.回车键是13 2. onload事件只能在body和img标签中使用 事件的使用格式格式一: 1. 标签中添加属性 onxxx = &quot;函数&quot; 2. 编写函数实现 格式二: 1. 页面加载完,获取标签对象 2. 标签对象.onxxx = function(){} 123456789101112131415161718191)在标签上使用事件属性: &lt;button onclick="myClick()"&gt;点击事件&lt;/button&gt; &lt;script type="text/javascript"&gt; function myClick() &#123; alert("被点击了..."); &#125; &lt;/script&gt;2)使用标签对象添加事件属性: &lt;button id="button01"&gt;点击事件&lt;/button&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var buttonObj = document.getElementById("button01"); buttonObj.onclick = function() &#123; alert("被点击了..."); &#125; &#125; &lt;/script&gt; thisthis是当前对象,谁是当前对象,谁调用这个方法谁就是当前对象 1234567891011121314151617181920212223242526272829this的两种使用方式:第一种:&lt;script&gt; function run(node)&#123; //获取当前输入框对象的value alert(node.value); &#125; &lt;/script&gt;&lt;body&gt; &lt;input type="text" id="t1" onfocus="run(this)" value="test1"/&gt; &lt;br /&gt; &lt;input type="text" id="t2" onfocus="run(this)" value="test2"/&gt;&lt;/body&gt;第二种:&lt;script&gt; window.onload = function()&#123; var t1 = document.getElementById("t1"); //获取焦点时，打印t1里面的内容 t1.onfocus = function()&#123; //alert(t1.value); alert(this.value);//this 与 t1 等价 &#125;; &#125;&lt;/script&gt;&lt;body&gt; &lt;input type="text" id="t1" value="t1"/&gt; &lt;br /&gt; &lt;input type="text" id="t2"/&gt;&lt;/body&gt; 数组对象(Array)JS中数组长度是可变的,不存在索引越界问题 索引不一定只有数字,字符也可以 数组中可以存储不同类型的元素 创建数组格式: 1. 创建空数组: var arr = new Array(); 2. 创建指定长度数组: var arr = new Array(3); 注意: 数组默认值是undefined 3. 创建数组时直接赋值: var arr = new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); 4. 方式3的变形: var arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]; 常用属性及方法1. 获取长度: arr.length 2. 为数组赋值 arr[0] = &quot;a&quot;; 3. 将数组中的元素用指定字符拼成一个字符串: join(separator) 遍历123456789101112var arr = new Array("a","b","c");两种遍历方式:1.普通遍历: for(var i = 0; i &lt; arr.lenth; i++)&#123; alert("普通遍历"+arr[i]); &#125;2.in遍历 for(index in arr)&#123; alert("in遍历"+arr[index]); &#125;alert(arr.join("--"); //将数组元素以--连接打印 二维数组1234567891011数组和数组嵌套就是二维数组var out = new Array()'out[0] = new Array("a","b","c");out[1] = new Array("d","e","f","g");out[2] = new Array("h","i");//获取大盒子长度alert(out.length);//获取第二个小盒子的长度alert(out[1].length);//获得i值alert(out[2][1]); 其它对象(全局对象)123456789101112131415161718192021222324252627282930313233343536string(字符串): 常用方法: charAt(); 返回在指定位置的字符; indexOf(searchvalue,fromindex); 从指定位置处向后搜索匹配字符串; searchvalue(必选) --&gt; 要匹配的字符串; fromindex(可选) --&gt; 开始位置; lastIndexOf(searchvalue,fromindex); 从指定位置处向前搜索匹配字符串; searchvalue(必选) --&gt; 要匹配的字符串; fromindex(可选) --&gt; 开始位置; split(separator, howmany); 用指定的字符串分割成字符串数组; separator(必选) --&gt; 字符串或正则表达式; howmany --&gt; 返回指定最大长度的数组; toLocaleLowerCase(); toLowerCase();把字符串转换为小写。 toLocaleUpperCase(); toUpperCase()把字符串转换为大写。Date(日期): 创建对象: var date = new Date(); //获取当前时间; var date = new Date(毫秒值); //生成指定时间; 常用方法: date.toString(); //获取时间的string类型; date.toLocaleString(); //获取本地格式的时间; date.gettime(); //获取毫秒值;Math(数学): 常用方法: ceil(); 向上取整; floor(); 向下取整; round(); 四舍五入; random(); 0~1之间的随机数; pow(x,y); 返回x的y次幂; sqrt(x); x的平方根;RegExp(正则): 创建: var reg = new RegExp(正则规则); var reg = /^正则规则$/; 常用方法: test(要校验的字符串); 全局函数封装在window对象中 1. 数字转换: parseInt(&quot;字符串&quot;): 将字符串解析成整数 parseFloat(&quot;字符串&quot;): 将字符串解析成小数 注意: JS解析时,会解析非数字字符前面的数字,不会报错 如如果字符串是12ab3,会解析成12 如果字符串是abc123,会解析成NaN 2. 编码解码: encodeURL(); 把字符串编码为URL; decodeURL(); 将某个编码的URL解码; 问题: 客户端和服务器端编码集不同,数据传输乱码 解决方案: 第一步(编码): 将中文字符根据编码集转换成固定格式的数字: %数字%数字%.... 第二步(解码): 发送到服务器,服务器使用和客户端相同的编码集转换成字符 3. eval(); 将字符串转换为可执行的代码; 案例表单校验(简单)* 要求: 注册时对用户名和密码进行非空校验,用户名还要进行非空格校验 * 语法: 1. form标签中onsubmit = &quot;return 函数() &quot;; 2. JS编写函数实现,函数返回true或false,如果是true就提交表单,否则不提交 * JS中正则的使用: 以/^开始 以 $/结束 * 匹配 --- 两种方式 1. 数据.match(正则); 2. 正则.test(数据); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132主要看两个标签: &lt;script&gt;和&lt;form&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; function check()&#123; var un = document.getElementById("un"); var pw = document.getElementById("pw"); if(un.value == "")&#123; alert("用户名不能为空!"); return false; &#125; var re = /^ +$/; /*if(un.value.match(re))&#123; alert("用户名不能包含空格!"); return false; &#125;*/ if(re.test(un.value))&#123; alert("用户名不能包含空格!"); return false; &#125; if(pw.value == "")&#123; alert("密码不能为空!"); return false; &#125; return true; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="../index.html" method="get" onsubmit="return check()"&gt; &lt;table align="center"&gt; &lt;tr&gt; &lt;td colspan="3"&gt; &lt;font size="6" color="#46B8DA"&gt;会员注册&lt;/font&gt;UserRegister &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;帐号:&lt;/td&gt; &lt;td&gt; &lt;input type="text" name="username" id="un"/&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt; &lt;input type="password" name="password" id="pw" /&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码:&lt;/td&gt; &lt;td&gt; &lt;input type="password" /&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱:&lt;/td&gt; &lt;td&gt; &lt;input type="text" name="email" /&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt; &lt;input type="text" name="name"/&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我介绍:&lt;/td&gt; &lt;td&gt; &lt;textarea rows="5" cols="14"&gt;打篮球&lt;/textarea&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type="radio" name="sex" value="man" checked="checked"/&gt;男 &lt;input type="radio" name="sex" value="woman" /&gt;女 &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期:&lt;/td&gt; &lt;td&gt; &lt;select name="year"&gt; &lt;option value="1990"&gt;1990&lt;/option&gt; &lt;option value="1991"&gt;1991&lt;/option&gt; &lt;option value="1992"&gt;1992&lt;/option&gt; &lt;option value="1993"&gt;1993&lt;/option&gt; &lt;/select&gt; &lt;select name="month"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;option value="4"&gt;4&lt;/option&gt; &lt;/select&gt; &lt;select name="day"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;option value="4"&gt;4&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码:&lt;/td&gt; &lt;td&gt; &lt;input type="text" name="code"/&gt; &lt;/td&gt; &lt;td&gt; &lt;img src="../img/image/captcha.jhtml" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type="submit" value="注册" /&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 表单校验(优化)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950不以警告框的形式弹出校验信息,而是在文本框后面显示&lt;script type="text/javascript"&gt; window.onload = function()&#123; var un = document.getElementById("un"); var unmsg = document.getElementById("unmsg"); un.onfocus = function()&#123; unmsg.innerHTML = "&lt;font&gt;帐号必填&lt;/font&gt;" &#125; un.onblur = function()&#123; var re = /^ +$/; if(un.value == "")&#123; unmsg.innerHTML = "&lt;font color='red'&gt;帐号不能为空!&lt;/font&gt;"; &#125;else if(re.test(un.value))&#123; unmsg.innerHTML = "&lt;font color='blue'&gt;帐号不能包含空格!&lt;/font&gt;"; &#125;else&#123; unmsg.innerHTML = "&lt;font&gt;恭喜!帐号可用!&lt;/font&gt;"; &#125; &#125; var pw = document.getElementById("pw"); var pwmsg = document.getElementById("pwmsg"); pw.onfocus = function()&#123; pwmsg.innerHTML = "&lt;font&gt;密码必填&lt;/font&gt;"; &#125; pw.onblur = function()&#123; if(pw.value == "")&#123; pwmsg.innerHTML = "&lt;font color='red'&gt;密码不能为空&lt;/font&gt;"; &#125;else&#123; pwmsg.innerHTML = "&lt;font&gt;恭喜!密码可用!&lt;/font&gt;" &#125; &#125; &#125;&lt;/script&gt;&lt;tr&gt; &lt;td&gt;帐号:&lt;/td&gt; &lt;td&gt; &lt;input type="text" name="username" id="un" /&gt; &lt;/td&gt; &lt;td&gt; &lt;span id="unmsg"&gt;&lt;/span&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt; &lt;input type="password" name="password"id="pw" /&gt; &lt;/td&gt; &lt;td&gt; &lt;span id="pwmsg"&gt;&lt;/span&gt; &lt;/td&gt;&lt;/tr&gt; 轮播图123456789101112131415161718图片: &lt;div&gt; &lt;img src="../img/img/1.jpg" width="100%" id="lunbo"/&gt; &lt;/div&gt;编写轮播脚本: &lt;script type="text/javascript"&gt; window.onload = function()&#123; var count = 1; window.setInterval(function()&#123; var lunbo = document.getElementById("lunbo"); count++; if(count &gt; 3)&#123; count = 1; &#125; lunbo.src = "../img/img/"+count+".jpg"; &#125;,1000); &#125; &lt;/script&gt; 定时广告12345678910111213141516图片: &lt;div id="gg" style="display: none;"&gt; &lt;img src="../../img/image/2.jpg" width="100%" /&gt; &lt;/div&gt;编写js脚本: &lt;script type="text/javascript"&gt; window.onload = function()&#123; window.setTimeout(function()&#123; var gg = document.getElementById("gg"); gg.style.display = "block"; window.setTimeout(function()&#123; gg.style.display = "none"; &#125;,3000); &#125;,3000); &#125; &lt;/script&gt; 表格隔行变色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150要求: 表格奇数行与偶数行颜色不同,当鼠标移入时,当前行变为粉色,移出时变回原来的颜色知识前提:首先我们要知道,当页面加载完,window.onload = function()&#123;&#125;,function函数已经执行完了,onmouseover和onmouseout事件已经绑定完(也就是每个对象都有这个事件了),只是还未触发,所以tr.onmouseover = function()&#123;&#125;,function并没有执行第一种形式:(错误)错误原因: 页面加载完,此时i=5,1处tr为trs[最后一次进入for时的i],即i=4;此时tr只代表最后一行,当鼠标移入其他行时,触发事件了,事件function中的tr都代表最后一行,所以颜色都是改的最后一行的颜色&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .jishu&#123; background-color: red; &#125; .oushu&#123; background-color: blue; &#125; .pink&#123; background-color: pink; &#125; &lt;/style&gt; &lt;script type = "text/javascript"&gt; window.onload = function()&#123; var trs = document.getElementsByTagName("tr"); for(var i = 1;i &lt; trs.length;i++)&#123; var tr = trs[i];//1处 if(i % 2 == 1)&#123; tr.className = "jishu"; &#125;else&#123; tr.className = "oushu"; &#125; var temp; tr.onmouseover = function()&#123; temp = tr.className; tr.className = "pink"; &#125; tr.onmouseout = function()&#123; tr.className = temp; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1" cellpadding="0" cellspacing="0" width="80%"&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品描述&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;手机数码&lt;/td&gt; &lt;td&gt;手机数码商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;电脑办公&lt;/td&gt; &lt;td&gt;电脑办公商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;鞋靴箱包&lt;/td&gt; &lt;td&gt;鞋靴箱包商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;家居饰品&lt;/td&gt; &lt;td&gt;家居饰品商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;第二种形式(错误):结果是颜色并不会变化.错误原因:加载完,i=5;触发事件function中的trs[5]并不代表某一行(因为总共就5行),属于undefined.&lt;script type = "text/javascript"&gt; window.onload = function()&#123; var trs = document.getElementsByTagName("tr"); for(var i = 1;i &lt; trs.length;i++)&#123; if(i % 2 == 1)&#123; trs[i].className = "jishu"; &#125;else&#123; trs[i].className = "oushu"; &#125; var temp; trs[i].onmouseover = function()&#123; temp = trs[i].className; trs[i].className = "pink"; &#125; trs[i].onmouseout = function()&#123; trs[i].className = temp; &#125; &#125; &#125;&lt;/script&gt;第三种形式:(正确)在onmouseover和onmouseout事件方法中使用this关键字,谁触发事件就代表谁&lt;script type = "text/javascript"&gt; window.onload = function()&#123; var trs = document.getElementsByTagName("tr"); for(var i = 1;i &lt; trs.length;i++)&#123; if(i % 2 == 1)&#123; trs[i].className = "jishu"; &#125;else&#123; trs[i].className = "oushu"; &#125; var temp; trs[i].onmouseover = function()&#123; temp = this.className; this.className = "pink"; &#125; trs[i].onmouseout = function()&#123; this.className = temp; &#125; &#125; &#125;&lt;/script&gt; 复选框操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type = "text/javascript"&gt; window.onload = function()&#123; var cbs = document.getElementsByClassName("itemSelect"); document.getElementById("chooseAll").onclick = function()&#123; for(var i = 0; i &lt; cbs.length;i++)&#123; cbs[i].checked = true; &#125; &#125; document.getElementById("chooseNone").onclick = function()&#123; for(var i = 0; i &lt; cbs.length;i++)&#123; cbs[i].checked = false; &#125; &#125; document.getElementById("fanxuan").onclick = function()&#123; for(var i = 0; i &lt; cbs.length;i++)&#123; cbs[i].checked = !cbs[i].checked; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1" cellpadding="0" cellspacing="0" width="80%"&gt; &lt;tr&gt; &lt;th&gt; &lt;input type="button" value="全选" id="chooseAll"/&gt; &lt;input type="button" value="全不选" id = "chooseNone"/&gt; &lt;input type="button" value="反选" id = "fanxuan" /&gt; &lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品描述&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect"/&gt; &lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;手机数码&lt;/td&gt; &lt;td&gt;手机数码商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;电脑办公&lt;/td&gt; &lt;td&gt;电脑办公商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;鞋靴箱包&lt;/td&gt; &lt;td&gt;鞋靴箱包商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="checkbox" class="itemSelect" /&gt; &lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;家居饰品&lt;/td&gt; &lt;td&gt;家居饰品商品信息&lt;/td&gt; &lt;td&gt; &lt;a href="#"&gt;修改&lt;/a&gt; &lt;a href="#"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 省市联动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657省市联动实现分析：1、省以及市的信息存储起来(JS数组存储)2、当第一个下拉框的选择改变时，触发一个函数 onchange3、函数中根据选择的省在第二个下拉框显示对应的市&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;script&gt; // 定义二维数组,存储城市信息 var cities = new Array(); cities[0] = new Array("海淀","昌平"); cities[1] = new Array("长春市","吉林市","松原市","延边市"); cities[2] = new Array("济南市","青岛市","烟台市","潍坊市","淄博市"); cities[3] = new Array("石家庄市","唐山市","邯郸市","廊坊市"); cities[4] = new Array("南京市","苏州市","扬州市","无锡市");方式一: function run(node)&#123; var city = document.getElementById("city"); //下面这行的目的是:每次更改省的时候,都会调用run,把city下拉列表中的内容清空 city.innerHTML = "&lt;option&gt;----请-选-择-市----&lt;/option&gt;"; for(var i = 0;i &lt; cities[node.value].length; i++)&#123; var opt = "&lt;option&gt;"+cities[node.value][i]+"&lt;/option&gt;"; //每个市进行拼接 city.innerHTML += opt; &#125; &#125;方式二: /*function run(node)&#123; var city = document.getElementById("city"); city.innerHTML = "&lt;option&gt;----请-选-择-市----&lt;/option&gt;"; for(var i = 0; i &lt; cities[node.value].length;i++)&#123; var opt = document.createElement("option"); var txt = document.createTextNode(cities[node.value][i]); opt.appendChild(txt); city.appendChild(opt); &#125; &#125;*/ &lt;/script&gt; &lt;body&gt; &lt;select id="province" style="width:150px" onchange="run(this)"&gt; &lt;option value=""&gt;----请-选-择-省----&lt;/option&gt; &lt;option value="0"&gt;北京&lt;/option&gt; &lt;option value="1"&gt;吉林省&lt;/option&gt; &lt;option value="2"&gt;山东省&lt;/option&gt; &lt;option value="3"&gt;河北省&lt;/option&gt; &lt;option value="4"&gt;江苏省&lt;/option&gt; &lt;/select&gt; &lt;select id="city" style="width:150px"&gt; &lt;option value=""&gt;----请-选-择-市----&lt;/option&gt; &lt;/select&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML&CSS]]></title>
      <url>%2F2017%2F03%2F18%2FJavaWeb-01-HTML%26CSS%2F</url>
      <content type="text"><![CDATA[HTML概述1.超文本标记语言 超文本- 不仅可以存文本, 还可以为文本添加样式,还可以存视频,音频,图片 标记- HTML源码中使用标签实现超文本存储,标签称之为标记 语言- 一门计算机语言 2.作用: 编写静态网页 3.特点: 1. 是一种解释型语言,源码不需要编译 编译型: 源码--&gt;机器码(0101...)--&gt;以后每次执行机器码 解释型: 源码--&gt;每次直接执行源码 拓展: 编译型效率更高 2. 文件的扩展名是*.html或*.htm 3. html结构都是由标签组成 标签名都是预先定义好的,具有固定好的功能; 标签名不区分大小写 标签由开始标签和结束标签组成 标签若没有&quot;内容体&quot;,可以自结束(&lt;img /&gt;也称&quot;空标签&quot;) 4.注释: &lt;!-- 注释内容,不能嵌套使用 --&gt; 标签标题1234&lt;h1&gt;标题1&lt;/h1&gt;,&lt;h2&gt;标题2&lt;/h2&gt;,...&lt;h6&gt;标题6&lt;/h6&gt; 特点: 1. 依次减小 2. 自动换行 水平线1234&lt;hr/&gt; 属性: 1. width:设置宽度,取值百分比(%),像素(px); 2. size:设置高度(粗细),取值百分比(%),像素(px); 字体1234567&lt;font&gt;字体&lt;/font&gt; 属性: color:设置颜色,取值: 1.使用颜色的英语单词; 2.使用16进制组成颜色码: #xx(红)xx(绿)xx(蓝) 例:红:#ff0000 白:#ffffff 黑:#000000 size:设置字体大小,取值1~7;默认是3 格式化12345粗体: &lt;b&gt;粗体&lt;/b&gt;斜体: &lt;i&gt;斜体&lt;/i&gt; 段落12345&lt;p&gt;段落&lt;/p&gt; 特点: 1.自动换行,独占一行; 2.前后留白;&lt;br /&gt; 换行 图片12345678910&lt;img /&gt; 属性: src:图片路径; 相对路径: ../ 返回到当前文件夹的上一级文件夹目录; ./ 当前文件夹目录; alt:当图片不能显示时,代替图片的说明文本; title:提示描述(鼠标悬停在图片上时,显示的说明文本); width:设置图片的宽度,取值百分比,像素; heigth:设置图片的高度,取值百分比(%),像素(px); 列表12345678910111213 有序列表:&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; 无序列表:&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 属性:type:设置标识: ol:取值:a,A,i,I,1等; ul:取值:circle(空心圆),square(方块),disc(实心圆); 超链接123456&lt;a&gt;超链接&lt;/a&gt; 属性: href:资源的路径(访问路径); target:设置打开方式,取值: _blank:开启新窗口显示; _self:覆盖当前窗口显示; 表格123456789101112131415161718192021&lt;table&gt; 属性: border:设置边框,取值像素; cellpadding:设置单元格与单元格内容之间的间距; cellspacing:设置单元格与单元格之间的间距; width:设置宽度,取值百分比(%),像素(px); align:设置表格对齐方式; bgcolor:设置背景颜色;&lt;tr&gt; &lt;!-- 定义一行 --&gt; 属性: align:设置单元格内容的对齐方式; bgcolor:设置背景颜色; &lt;th&gt; &lt;!-- 定义表头单元格 --&gt;&lt;td&gt; &lt;!-- 定义普通单元格 --&gt; 属性: align:设置单元格内容的对齐方式; bgcolor:设置背景颜色; colspan:合并单元格; rowspan:合并行; 框架12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;frameset&gt;:框架标签; 特点: 不能与body共存; 属性: rows:行,取值百分比(%),像素(px); cols:列,取值百分比(%),像素(px); 注意: frameset可以嵌套 如果要实现左侧菜单栏超链接点击时,页面显示在右侧: 1. 右侧 frame 定义一个 name 2. 超链接的 target = "name 值" &lt;frame&gt;:框架子标签; 属性: src:资源路径; noresize:框架分隔线不能移动; name:自定义名称(唯一); 使用&lt;frameset&gt;布局页面:&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;后台页面&lt;/title&gt; &lt;/head&gt; &lt;frameset rows="20%,*"&gt; &lt;frame noresize="noresize" src="top.html" /&gt; &lt;frameset cols="20%,*"&gt; &lt;frame noresize="noresize" src="left.html" /&gt; &lt;frame noresize="noresize" src="main.html" name="main"/&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt;left.html:&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="../../index.html" target="main"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册页面&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 表单12345678910111213141516171819202122232425262728293031323334&lt;form&gt;:表单标签 作用: 读取客户录入,通过网络发送到服务器 应用场景: 登录,注册,搜索关键字 实现方式: 1.用户录入关键字 2.关键字发送到服务器 发送格式: www.xxxx.com?word=用户录入的关键字 www.xxxx.com?username=用户帐号&amp;password=用户密码 3.服务器获取到键值对,取出值,再做下一步处理 4.查询数据库,并将结果发送到客户端 重点: 数据发送到服务器格式: 服务器域名?键1=值1&amp;键2=值2&amp;.... 键---是开发人员预定义好的 值---是用户录入的 后台根据键取值 表单相关知识点: 1.表单页面 表单相关标签 2.指定格式发送服务器 指定格式---&gt; 输入项中设置name属性 发送到服务器---&gt; form标签中设置action="服务器路径" 3.提交方式 地址栏显示录入内容: 默认/method="get" 地址栏不显示录入内容: method="post" POST--&gt; 数据安全,发送的数据没有长度限制 属性: action:数据提交路径; method:数据提交方式:(并不只有get和post) get:理论上速度快,数据会追加到地址栏中(url?k=v&amp;k=v&amp;...),有数据大小限制(不安全); post:理论上速度慢,数据不会追加到地址栏中,无数据大小限制(安全); 表单相关标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 input:定义表单项; 属性: type:表单项类型,取值: text --&gt; 文本框; password --&gt; 密码框; radio --&gt; 单选按钮; checkbox --&gt; 复选框; file --&gt; 文件上传; hidden --&gt; 隐藏域; reset --&gt; 重置按钮; submit --&gt; 提交按钮; image --&gt; 图形提交按钮; button --&gt; 普通按钮; name:发送服务端的数据名称(需要提交的数据必须提供name值); value:发送服务端的数据值; size:表单项的长度; checked:默认选中(用于单选框或复选框); readonly:是否只读,数据会提交 disabled:是否可用,数据不会提交 maxlength:允许输入的最大长度; select:下拉列表; 属性: name:发送服务端的数据名称; multiple:不写默认单选,取值为"multiple"表示多选; size:多选时,可见选项的数目; **子标签** option:下拉项; 属性: value:发送服务端的数据值; selected:默认勾选项; textarea:文本域; 属性: cols:文本域的列数; rows:文本域的行数; 注意: 1. radio保证单选,需要设置相同的name属性 2. 文本域比较特殊，没有 value 属性，设置数据必须设置在内容体 3. 隐藏标签hidden存储一些用户没必要看到的数据,比如id号 拓展: 设置性别用radio,只可以点击圆圈进行选择,如点击男或女也进行选择: * 设input的id * 设置label性别:&lt;input type="radio" name="sex" value="男" id="sexMan"/&gt;&lt;label for="sexMan"&gt;男&lt;/label&gt;&lt;input type="radio" name="sex" value="女" id="sexWoman"/&gt;&lt;label for="sexWoman"&gt;女&lt;/label&gt; 表单小问题1. radio单选传递的值都是on,无法区分值.需要设置value来解决 2. checkbox复选传递的值也都是on,无法区分值,需要设置value来解决 CSS概念: 层叠样式表,多个样式可以重叠使用 HTML-&gt; 内容的载体(存储内容) CSS--&gt; 修饰内容 CSS使用123456789101112131415161718192021222324251.行内样式: 使用style属性; 语法: style=&quot;属性名:属性值;属性名:属性值;&quot; 注意: 值本身有空格,要用 &quot;&quot; 或 &apos;&apos; 包裹,如果外层有双引号了,要用单引号2.内部样式: 在head中使用style标签定义样式; 语法: &lt;style type=&quot;text/css&quot;&gt; 选择器 &#123; 属性名: 属性值; 属性名: 属性值; &#125; &lt;/style&gt;3.外部样式: 创建*.css样式文件,在需要使用其中样式的html中引入该样式; *.css文件语法: 选择器 &#123; 属性名: 属性值; 属性名: 属性值; &#125; 引入样式语法: &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;*.css文件的路径&quot;/&gt; 属性: rel:说明当前页面与href所指定文档的关系(这里固定,指引入的文件是当前页面的样式表); type:指定浏览器的解释方式; href:*.css文件的路径; div与span二者经常结合css使用,都可以存储内容体 div: 换行,除了包裹内容体,还会占内容后的一整行 span: 不换行,刚好包裹内容体 注: div h1 p li ---&gt; 块级元素,默认换行 span font a ---&gt; 行内元素,默认不换行 CSS选择器123456789101112131415161718192021222324252627282930作用: 定位要添加样式的标签分类: 1.元素选择器: 标签名 &#123; CSS语法; &#125; 2.ID选择器: 标签有id属性,这个值是标签的唯一标识; #id值 &#123; CSS语法; &#125; 3.类选择器: 标签有class属性,这个值确定一类标签; .class值 &#123; CSS语法; &#125; 4.属性选择器: 选择器[属性名=&apos;属性值&apos;] &#123; CSS语法; &#125; 5.包含(层叠)选择器:多个选择器组合在一起进行筛选 父选择器 子孙选择器 &#123; CSS语法; &#125; 举例: 先定位div,再定位当前div中的font div font&#123; color: red; &#125;注意优先级: 行内样式 &gt; id选择器 &gt; 类选择器 &gt; 元素选择器 CSS样式border:设置边框样式; 语法: 选择器 { border:宽度 样式 颜色; width:取值百分比,像素; } width:设置宽度,取值百分比,像素; height:设置高度,取值百分比,像素; display:转换标签的类型: 标签分为: 行内标签:可以与其它标签在一行显示的标签称为行内标签; 块级标签:自己独占一行,不能与其它标签在一行共存的称为块级标签; color:设置字体颜色; font-size:设置字体大小; background-color:设置背景样式; float:设置浮动方式,取值: left:元素向左浮动; right:元素向右浮动; none:元素不浮动(默认值); clear:清除浮动效果,取值: left:清除元素向左浮动; right:清除元素向右浮动; both:同时清除左右两侧浮动; CSS边框与尺寸作用: 布局明显,美观 属性: border: 粗细 颜色 实线; width: 像素或百分比; height: 像素; 12345div&#123; border: 1px red solid; /* solid代表实线 */ width: 100px;/* 也可以用百分比,如50% */ height: 200px;&#125; CSS其他样式123456781.超链接:a&#123; text-decoration: none; /* 取消下划线 */&#125;2.设置内容隐藏font&#123; display:none;&#125; CSS结构样式123456781.块级元素转行内元素 div&#123; display:inline; &#125;2.行内元素转块级元素: span&#123; display:block; &#125; CSS布局样式属性: float: 浮动,可以让div水平显示 1.假设都没有float属性,会默认换行 2.假设都有float属性,全部浮动 注意: 有的有float,有的没有float,结果产生了重叠 出现重叠原因: * 页面分成上下两层 * 浮动在上,不浮动在下 * 俯视观看 解决: 在d3中添加属性 clear: both; 相当于把上层浮动的内容拿到下层,再进行排版 123456789101112131415161718#d1&#123; border: 1px red solid; width: 100px; height: 100px; float: left; /* 浮动 */ &#125;#d2&#123; border: 1px green solid; width: 200px; height: 200px; float: left; &#125;#d3s&#123; border: 1px blue solid; width: 300px; height: 300px; clear: both;&#125; CSS盒子模型三部分: 外边距(margin),边框(border)和内边距(padding): 外边距(margin):边框与其它标签边框之间的距离; 内边距(padding):边框与内容之间的距离; 盒子之间间距设置: margin-top: 100px; /* 或百分比,纵向上不推荐百分比 */ margin-left: 100px; margin-right margin-bottom 盒子内元素与盒子之间间距设置: padding-top: 100px; /* 或百分比 */ padding-left: 50px; padding-right padding-bottom 拓展: right和bottom生效的情况: margin----&gt; 平级的盒子之间 padding---&gt; 不指定盒子的width和height时可以生效]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[反射]]></title>
      <url>%2F2017%2F03%2F06%2F20-%E5%8F%8D%E5%B0%84%2F</url>
      <content type="text"><![CDATA[类加载器* 要使用某个类时,如果该类还未被加载到内存中, 则系统会通过加载,连接,初始化三步来实现对这个类进行初始化。 1. 类的加载 * 将class文件读入内存,类的加载器创建一个编译后的class文件的对象(字节码对象) * 任何类在使用时,系统都会建立一个class对象 2. 连接 * 验证: 检查内部结构 * 准备: 为类的静态成员分配内存,并默认初始化值 * 解析: 将类的二进制数据中的符号引用替换为直接引用 3. 初始化 * 创建对象,赋值 类的加载时机* 创建类的实例 * 类的静态变量，或者为静态变量赋值 * 类的静态方法 * 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 * 初始化某个类的子类 * 直接使用java.exe命令来运行某个主类 类的加载器* 负责将.class文件加载到内存中,并为之生成对应的Class对象 * 组成: 1. 根类加载器Bootstrap ClassLoader 负责Java核心类的加载,比如System,String等 在JDK中JRE的lib目录下rt.jar文件中 2. 扩展类加载器Extension ClassLoader 负责JRE的扩展目录中jar包的加载。 在JDK中JRE的lib目录下ext目录 3. 系统类加载器System ClassLoader 在JVM启动时加载来自java命令的class文件以及classpath环境变量所指定的jar包和类路径 反射* JAVA反射机制是在运行状态中， 对于任意一个类,都能够知道这个类的所有属性和方法； 对于任意一个对象,都能够调用它的任意一个方法和属性； * 条件：运行状态 已知：一个类或一个对象(根本是已知.class文件) 结果：得到这个类或对象的所有方法和属性 class文件的产生过程* Class对象是在加载类时由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的 Class文件对象的获得1. 对象获取(通过Object类中的getClass()方法) 2. 类名获取(任意数据类型都具备一个class静态属性) 3. Class类的静态方法获取(通过Class类中的方法) 123456789101112131415161718191.对象获取Person p = new Person();//调用父类方法getClass()Class c1 = p.getClass();System.out.println(c1);2.类名获取//每个类型,包括基本和引用,都会赋予这个类型一个静态的属性,属性名字就叫classClass c2 = Peron.class;Class d1 = double.class;System.out.println(c2);System.out.println(d1);//打印结果是double3.静态方法获取Class.forName(String classname)//字符串的类名:要加上包名Class c3 = Class.forName("com.geekhoon.demo1.Person");System.out.println(c3);打印结果都是:class com.geekhoon.demo01.Person 通过反射获取无参构造方法并使用* Class中方法: 1. public Constructor&lt;?&gt;[] getConstructors(): 获取所有的public修饰的构造方法 2. public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) : 获取public修饰, 指定参数类型所对应的构造方法 不传参数得到无参构造方法 * Constructor类中方法: 1. public T newInstance(Object... initargs) : 使用此Constructor对象表示的构造方法来创建该构造方法的声明类的新实例 并用指定的初始化参数初始化该实例 因为是无参构造,所以不传参数 123456789101112131415161718192021222324public static void main(String[] args) throws Exception &#123; //获取Class对象 Class c = Class.forName("com.geekhoon.demo01.Person");//1.获取class文件对象中所有公共的构造方法: Constructor[] getConstructors()//返回值是Constructor类型数组 Constructor[] cons = c.getConstructors(); for (Constructor con : cons) &#123; System.out.println(con);//打印的是所有公共构造方法名 &#125;//2.获取指定的构造方法 ----&gt; 获取空参数构造方法: Constructor getConstructor() Constructor con = c.getConstructor(); System.out.println(con);//打印空参构造方法名//运行空参构造方法,使用的是Constructor类方法newInstance()//创建该构造方法的声明类的新实例,new了一个Person对象//运行获取到的构造方法,返回值是Object类型对象 //相当于Object obj = new Person(); Object obj = con.newInstance();//要调用Person类的方法,需要进行向下转型 Person p = (Person) obj; p.eat(); System.out.println(obj);//因为重写了toString(),打印结果是Person [name=null, age=0]//没有重写的话,打印的则是p的地址&#125; 获取无参构造方法并使用的快捷方式* 前提: 1. 被反射的类,必须具有空参数构造方法 2. 构造方法权限必须是public,本包下可以使用默认default 123456public static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.geekhoon.demo01.Person"); //使用Class的newInstance方法,直接创建被反射类的对象实例 Object obj = c.newInstance(); System.out.println(obj);&#125; 通过反射获取有参构造方法并使用1234567891011121314151617181920212223242526272829public static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.geekhoon.demo01.Person");//getConstructor(),参数列表中传递的是构造方法对应的类型//不可以直接写String,int,因为参数是字节码文件对象类型,加上.class Constructor con = c.getConstructor(String.class,int.class);//运行构造方法newInstance(),参数列表中传递的是实际参数,进行赋值 Object obj = con.newInstance("张三",20); System.out.println(obj);&#125;``` ### 通过反射获取私有构造方法并使用 ### * 暴力反射,破坏了程序的封装性,安全性 * Class类中方法: 1. Constructor[] getDeclaredConstructors(): 获取所有构造方法,包括私有 2. Constructor getDeclaredConstructor(Class...c): 获取指定参数列表的构造方法 * Constructor父类 1. public void setAccessible(boolean flag): flag为true,可以保证私有构造方法的运行(取消了运行时期的权限检查)```javapublic static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.geekhoon.demo01.Person"); //获取指定参数列表的构造方法 Constructor con = c.getDeclaredConstructor(int.class,String.class); //Constructor父类AccessibleObject的方法setAccessible(boolean b) con.setAccessible(true); Object obj = con.newInstance(10,"李四"); System.out.println(obj);&#125; 反射获取成员变量,并修改值* Class类方法: 1. public Field[] getFields() 返回值是Field[],反映此Class对象所表示的类或接口的所有可访问公共字段 2. public Field getField(String name): 传递字符串类型的变量名 返回值是Field，反映此Class对象所表示的类或接口的指定公共成员字段 * Filed类方法: 1. void set(Object obj,Object value): 修改成员变量的值 123456789101112131415161718192021public static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.geekhoon.demo01.Person"); //使用空参构造创建对象 Object obj = c.newInstance(); //获取指定的公共成员变量String name Field field = c.getField("name"); //修改成员变量的值 field.set(obj, "王五"); //打印对象 System.out.println(obj);//Person [name=王五, age=0] //获取私有的成员变量age Field field2 = c.getDeclaredField("age"); //将私有权限去除 field2.setAccessible(true); //设置值 field2.set(obj, 22); //打印对象 System.out.println(obj);//Person [name=王五, age=22]&#125; 反射获取空参成员方法并运行* Class类方法: 1. Method getMethod(String methodName,Class...c):获取class对象中指定的成员方法 methodName:获取的方法名 Class...c:参数列表 2. Method[] getMethods()获取的是class文件中所有的公共成员方法,包括继承的 * Method类方法: 1. Object invoke(Object obj,Object...o): 运行成员方法 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; Class c = Class.forName("com.geekhoon.demo01.Person"); Object obj = c.newInstance(); //获取class对象中的所有公共成员方法 //Method[] getMethods()获取的是class文件中所有的公共成员方法,包括继承的 Method[] methods = c.getMethods(); for (Method method : methods) &#123; System.out.println(method); &#125; System.out.println("======分割线======"); //获取class对象中指定的成员方法 //Method getMethod(String methodName,Class...c) //methodName:获取的方法名 //Class...c:参数列表 Method method = c.getMethod("eat"); //使用Method类中的方法: Object invoke(Object obj,Object...o) //运行成员方法: method.invoke(obj);&#125; 反射获取有参成员方法并运行12345678public static void main(String[] args) throws Exception&#123; Class c = Class.forName("com.geekhoon.demo01.Person"); Object obj = c.newInstance(); //调用getMethod()获取指定成员方法 Method method = c.getMethod("sleep", String.class,int.class); //调用Method类的方法invoke()运行sleep方法 method.invoke(obj, "睡觉",100);&#125; 泛型擦除* 集合中的泛型都是伪泛型,即在编译后的.class文件里面是没有泛型的 所以利用反射,拿到集合类class对象,直接调用add方法,而不是通过实例对象调用add 1234567891011121314151617181920212223public class Test08 &#123; /* * 定义集合类,泛型是String * 要求: 向集合中添加Integer类型数据 * 步骤: * 1. 通过反射,获取集合ArrayList类的class文件对象 * 2. 通过class文件对象,调用add方法 * */ public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("a"); //通过反射,获取class文件对象 Class c = list.getClass(); //调用add方法 Method method = c.getMethod("add", Object.class); //运行add方法 method.invoke(list, 150); for (Object o : list) &#123; System.out.println(o); &#125; &#125;&#125; 反射通过配置文件来决定运行的步骤* 通过配置文件得到类名和要运行的方法名,用反射的操作类名得到对象和调用方法 * 步骤: 1. 准备配置文件,键值对 2. IO流读取配置文件 3. 文件中的键值对存储到集合Properties中,集合保存的键值对,就是类名和方法名 4. 反射获取指定类的class文件对象 5. 通过class文件对象,获取指定的方法 6. 运行方法 1234567配置文件config.properties: #className=com.geekhoon.demo.Person#methodName=eat#className=com.geekhoon.demo.Student#methodName=studyclassName=com.geekhoon.demo.WorkermethodName=work 12345678910111213141516171819202122232425262728293031323334353637383940414243//代码:package com.geekhoon.demo;import java.io.FileReader;import java.lang.reflect.Method;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws Exception &#123; //IO流读取配置文件 FileReader fr = new FileReader("config.properties"); //创建集合对象 Properties pro = new Properties(); //调用load()加载流对象 pro.load(fr); fr.close(); //通过键获取值 String className = pro.getProperty("className"); String methodName = pro.getProperty("methodName"); //反射获取指定类的class文件对象 Class c = Class.forName(className); Object obj = c.newInstance(); //获取指定方法 Method method = c.getMethod(methodName); //运行方法 method.invoke(obj); &#125;&#125;class Person&#123; public void eat()&#123; System.out.println("人在吃饭"); &#125;&#125;class Student&#123; public void study()&#123; System.out.println("学生在学习"); &#125;&#125;class Worker&#123; public void work()&#123; System.out.println("工人在工作"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC]]></title>
      <url>%2F2017%2F03%2F01%2F19-JDBC%2F</url>
      <content type="text"><![CDATA[JUnit* JUnit是一个Java语言的单元测试框架,属于第三方工具,需要导入jar包 * Ecilpse中已经集成了JUnit作为单元测试工具,不需要导入jar包 * 进行单元测试,可以不写main方法 * 编写测试类: 测试方法要求: 1. 类名不能是Test 2. 方法名不能是静态 3. 方法不能有返回值 4. 方法不能有参数列表 * @Test : 注解 * 运行: 方式1：选定测试方法名 ---- 右击 ---- run as ---- Junit test 方式2：选定类名 --------- 右击 ---- run as ---- Junit test\ * @Before ----- 测试函数执行前调用 * @After ------ 测试函数执行完调用 12345678910111213141516171819202122232425262728293031public class JUnitDemo &#123; @Before public void start()&#123; System.out.println("测试开始...."); &#125; @Test public void testAdd()&#123;//测试方法 MyMath.add(1, 2); &#125; @Test public void testChu()&#123;//测试方法 MyMath.chu(10, 0); &#125; @After public void end()&#123; System.out.println("测试结束...."); &#125;&#125; public class MyMath &#123; public static void add(int num1, int num2)&#123; int result = num1 + num2; System.out.println("和:" + result); &#125; public static void chu(int num1, int num2)&#123; int result = num1 / num2; System.out.println("商:" + result); &#125;&#125; JDBC概述* Java Data Base Connectivity * 一种用于执行SQL语句的Java API * Java提供的访问数据库规范 * 可以为多种关系数据库提供统一访问 * 由一组用Java语言编写的类和接口组成. * 原理: * Java提供访问数据库规范称为JDBC,JDBC需要连接驱动,驱动是生产厂商提供规范的实现类 * JDBC是接口,驱动是接口的实现,没有驱动将无法完成数据库连接 * 每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库 * 导入驱动jar包 * 建lib目录，用于存放当前项目需要的所有jar包 * 选择jar包，右键执行build path / Add to Build Path 开发步骤1.注册驱动 告知JVM使用的是哪一个数据库的驱动 2.获取数据库的连接对象 使用JDBC中的类,完成对MySQL数据库的连接 3.获得执行者对象 通过连接对象获取对SQL语句的执行者对象 4.执行sql语句 使用执行者对象,向数据库执行SQL语句 获取到数据库的执行后的结果 5.处理结果 6.释放资源 close() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class Test &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;/* * 1.注册驱动 * Driver是一个接口: 每个驱动程序类必须实现的接口 * 方式一: 使用java.sql.DriverManager类的静态方法registerDriver(Driver driver) * 参数是MySQL驱动程序的Driver实现类,这种方式会new两个Driver对象,不推荐使用 * 方式二: 使用反射技术, 将驱动类加入到内容,如下: */ Class.forName("com.mysql.jdbc.Driver");/* * 2.获取数据库的连接对象 * 使用DriverManager类中静态方法static Collection getConnection() */ String url = "jdbc:mysql://localhost:3306/mybase"; String user = "root"; String password = "root"; Connection con = DriverManager.getConnection(url, user, password);/* * 3.获得执行者对象 *///Statement stat = con.createStatement();这种接口对象有安全隐患(SQL注入攻击) String sql = "INSERT INTO sort(sname,sprice,sdesc) VALUES(?,?,?)";//使用Statement的子类接口prepareStatement可有效避免安全隐患,但注意sql语句的编写//要赋值的列如上或者判断条件中要用值,不要直接写出值,而要用?占位,如select * from sort where sid = 1//这里就不能写1, 要写成select * from sort where sid =?//如果是select * from sort,不需要值,那不用写setObject()//通过PreparedStatement对象的setObject()进行赋值//第一个参数是占位符的位置,从1开始,第二个是值//使用的是Connection数据库连接对象的方法,获取的是PreparedStatement接口的实现类,//也叫sql语句的预编译对象//PreparedStatement prepareStatement(String sql) //PrepareStatement接口预编译SQL语句 PreparedStatement pds = con.prepareStatement(sql); pds.setObject(1, "汽车用品"); pds.setObject(2, 3220); pds.setObject(3, "涨价");/* * 4.执行sql语句 * 有两点: * 1.是增删改语句:调用执行者对象的executeUpdate(),返回值是受影响行数: * int row = pds.executeUpdate(); * 也可以不用接收返回值,直接写成pds.executeUpdate() * 2.是查询语句:调用执行者对象的executeQuery(),返回值是结果集 */ ResultSet rs = pds.executeQuery();/* * 5.处理结果集 * ResultSet接口方法 boolean next() 返回true,有结果集,返回false没有结果集 *///特别注意: rs.next()判断的是结果集,不是数据表,是根据select条件查询出的内容,可能一条或多条 while(rs.next())&#123; //获取每列数据,使用是ResultSet接口的方法 getXX方法参数中,建议写String列名 System.out.println(rs.getInt("sid") + " " + rs.getString("sname") + " " + rs.getDouble("sprice") + " " + rs.getString("sdesc")); &#125;/* * 6.释放资源 */ rs.close(); pds.close(); con.close(); &#125;&#125; JDBC使用细节1. 所有相关类导包 ---- java.sql.*; 2. 导入 com.mysql.*;也没问题 问什么？ a)、因为所需要的对象都是 jar 包中的类对应的对象 b)、jar 包中的类实现了 java.sql.xxx 这些接口 常规使用：父类声明指向子类实现 ---- 使用了多态 非常规使用：子类声明指向子类实现 3. 既然导入jar包实现也可以，为什么一再强调导 java.sql? 前提： 开发时是由 MySQL 数据库,部署时使用 Oracle 数据库 场景1： 开发使用MySQL: 1)、导入 MySQL jar 包 2)、也导入MySQL jar 包对应的类 部署时是由Oracle: 1)、导入Oracle jar 包 2)、将导的包换成 Oracle 的 （相当麻烦） 场景2 ---- 多态的好处： 实现了程序的可插拔设计 开发时使用MySQL: 1)、导入 MySQL jar 包 2)、导包导 JDK 内置的 部署时是由Oracle: 1)、导入Oracle jar 包 SQL注入攻击* 由用户输入用户名,密码来查询数据库中是否存在该用户的sql语句如下: SELECT * FROM 用户表 WHERE NAME = 用户输入的用户名 AND PASSWORD = 用户输的密码; * 不管输入的用户名是XXXX,密码是XXX,只要密码格式为 XXX&apos; OR &apos;1&apos;=&apos;1 或 XXX&apos; OR &apos;1 = 1 * 真正执行的代码变为: SELECT * FROM 用户表 WHERE NAME = &apos;XXXX&apos; AND PASSWORD =&apos;XXX&apos; OR &apos;1&apos;=&apos;1&apos;;或 SELECT * FROM 用户表 WHERE NAME = &apos;XXXX&apos; AND PASSWORD =&apos;XXX&apos; OR &apos;1 = 1&apos;; where条件都为true, 永远都可以查询出结果,那么用户就直接登录成功了,这就是SQL注入攻击问题 12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) throws Exception &#123; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://localhost:3306/mybase"; String username = "root"; String password = "root"; Connection con = DriverManager.getConnection(url, username, password); Statement stat = con.createStatement(); Scanner sc = new Scanner(System.in); String user = sc.nextLine(); String pass = sc.nextLine(); //执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败 String sql = "SELECT * FROM users WHERE username='"+user+"' AND PASSWORD='"+pass+"'"; System.out.println(sql); ResultSet rs = stat.executeQuery(sql); while(rs.next())&#123; //进入while循环意味着根据用户名密码查询到信息了,说明登录成功了 //任意用户名,只要密码格式如: 任意密码'or'1=1 //都可以登录成功 System.out.println(rs.getString("username")+" "+rs.getString("password")); &#125; rs.close(); stat.close(); con.close(); &#125;&#125;//数据表中正确的用户名密码有: 用户名 密码 a 1 b 2用户名输入c,密码输入c' or '1=1 ,就可以打印出所有用户信息了 123456789101112131415161718192021222324252627282930313233防止SQL注入问题,解决方案:public class Test &#123; public static void main(String[] args) throws Exception &#123; //1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.获取连接 String url = "jdbc:mysql://localhost:3306/mybase"; String user = "root"; String password = "root"; Connection con = DriverManager.getConnection(url, user, password); Scanner sc = new Scanner(System.in); String username = sc.nextLine(); String pass = sc.nextLine(); //执行sql语句 String sql = "select * from users where username = ? and password = ?"; //3.获取执行者对象 PreparedStatement pds = con.prepareStatement(sql); pds.setObject(1, username); pds.setObject(2, pass); ResultSet rs = pds.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString("username")+" "+rs.getString("password")+" "); &#125; rs.close(); pds.close(); con.close(); &#125;&#125; JDBC工具类普通工具类+普通的测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * JDBC工具类 * 内容: * 1.私有化构造方法. 不允许在其他类中创建对象！直接类名点调用方法即可 * 2.声明一个Connection对象 * 3.静态代码块 * 4.公共方法返回Connection对象 * 5.释放资源方法 */public class JDBCUtils &#123; private JDBCUtils()&#123;&#125; private static Connection con; static&#123; try &#123; //1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2.获得数据库连接 String url = "jdbc:mysql://localhost:3306/mybase"; String user = "root"; String password = "root"; con = DriverManager.getConnection(url, user, password); &#125; catch (Exception e) &#123; throw new RuntimeException(e+"数据库连接失败"); &#125; &#125; public static Connection getConnection()&#123; return con; &#125; public static void close(Connection con, Statement state,ResultSet rs)&#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (Exception e) &#123; &#125; &#125; if (state != null) &#123; try &#123; state.close(); &#125; catch (Exception e) &#123; &#125; &#125; if (con != null) &#123; try &#123; con.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; public static void close(Connection con, Statement state)&#123; if (state != null) &#123; try &#123; state.close(); &#125; catch (Exception e) &#123; &#125; &#125; if (con != null) &#123; try &#123; con.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125;/* * 对JDBC工具类进行测试 */public class Test &#123; public static void main(String[] args) throws Exception &#123; //调用JDBCUtils工具类中的静态方法，获取数据库连接 Connection con = JDBCUtils.getConncetion(); //3.获取执行者对象 String sql = "SELECT * FROM sort"; PreparedStatement pst = con.prepareStatement(sql); //4.执行sql语句 ResultSet rs = pst.executeQuery(); //5.处理结果集 while(rs.next()) &#123; System.out.println(rs.getInt("sid") + " " + rs.getString("sname") + " " + rs.getDouble("sprice") + " " + rs.getString("sdesc")); &#125; //6.释放资源 JDBCUtils.close(con, pst, rs); &#125;&#125; 读取配置文件工具类+普通的测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176开发中获得连接的4个参数(驱动,URL,用户名,密码)通常都存在配置文件中方便后期维护,程序如果需要更换数据库,只需要修改配置文件即可1.配置文件database.properties中的内容:driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybaseuser=rootpassword=root2.读取配置文件工具类:import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;import java.util.Properties;/* * JDBC读取配置文件工具类 * 1.私有化构造方法 * 2.声明所需的连接信息 */public class JDBCUtilsConfig &#123; //1.私有化构造方法 private JDBCUtilsConfig()&#123;&#125; //2.声明变量 private static Connection con; private static String driverClass; private static String url; private static String user; private static String password; //3.静态代码块 static&#123; try &#123; //使用类的加载器, 加载配置文件, //配置文件一般放在src文件夹下 InputStream in = JDBCUtilsConfig.class.getClassLoader() .getResourceAsStream("database.properties"); //创建Properties集合 Properties pro = new Properties(); pro.load(in); //获取集合中的键值对 driverClass = pro.getProperty("driverClass"); url = pro.getProperty("url"); user = pro.getProperty("user"); password = pro.getProperty("password"); //注册驱动 Class.forName(driverClass); //获取连接对象 con = DriverManager.getConnection(url, user, password); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException("数据库连接失败!"); &#125; &#125; //4.公共方法返回连接对象 public static Connection getConnection()&#123; return con; &#125; //5.释放资源 方式1: public static void close(Connection con, Statement state,ResultSet rs)&#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (Exception e) &#123; &#125; &#125; if (state != null) &#123; try &#123; state.close(); &#125; catch (Exception e) &#123; &#125; &#125; if (con != null) &#123; try &#123; con.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; public static void close(Connection con, Statement state)&#123; if (state != null) &#123; try &#123; state.close(); &#125; catch (Exception e) &#123; &#125; &#125; if (con != null) &#123; try &#123; con.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; 方式2:(最全面稳妥的方式) public static void close(ResultSet rs,Statement sm,Connection con)&#123; //注意try..catch..finally写法 //下一个对象的关闭都在当前对象的finally中 try&#123; if(rs != null)&#123; rs.close(); rs = null;//对象置为null,方便回收 &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); //如果某个对象关闭失败,抛运行时异常,程序关闭,对象也全部关闭 throw new RuntimeException(); &#125;finally&#123; try&#123; if(sm != null)&#123; sm.close(); sm = null; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); throw new RuntimeException(); &#125;finally&#123; try&#123; if(con != null)&#123; con.close(); con = null; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); throw new RuntimeException(); &#125; &#125; &#125; &#125; //重载 public static void close(Statement sm,Connection con)&#123; try&#123; if(sm != null)&#123; sm.close(); sm = null; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); throw new RuntimeException(); &#125;finally&#123; try&#123; if(con != null)&#123; con.close(); con = null; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); throw new RuntimeException(); &#125; &#125; &#125; &#125;3.测试类:public class Test &#123; /* * 对读取配置文件的工具类进行普通测试 */ public static void main(String[] args) throws Exception &#123; Connection con = JDBCUtilsConfig.getConnection(); //获取执行者对象 String sql = "SELECT * FROM sort"; PreparedStatement pst = con.prepareStatement(sql); //执行sql语句 ResultSet rs = pst.executeQuery(); //处理结果集 while(rs.next()) &#123; System.out.println(rs.getInt("sid") + " " + rs.getString("sname") + " " + rs.getDouble("sprice") + " " + rs.getString("sdesc")); &#125; //释放资源 JDBCUtilsConfig.close(con, pst, rs); &#125;&#125; 读取配置文件工具类+自定义对象存储测试* JDBC读取数据表sort,每行数据封装到Sort类的对象中 将多个Sort类对象,存储到List集合中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273741.Sort类public class Sort &#123; private int sid; private String sname; private double sprice; private String sdesc; public Sort(int sid, String sname, double sprice, String sdesc) &#123; super(); this.sid = sid; this.sname = sname; this.sprice = sprice; this.sdesc = sdesc; &#125; public Sort() &#123; super(); &#125; public int getSid() &#123; return sid; &#125; public void setSid(int sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public double getSprice() &#123; return sprice; &#125; public void setSprice(double sprice) &#123; this.sprice = sprice; &#125; public String getSdesc() &#123; return sdesc; &#125; public void setSdesc(String sdesc) &#123; this.sdesc = sdesc; &#125; @Override public String toString() &#123; return "Sort [sid=" + sid + ", sname=" + sname + ", sprice=" + sprice + ", sdesc=" + sdesc + "]"; &#125;&#125;2.读取配置文件工具类同上3.自定义对象存储测试/* * 对读取配置文件的工具类进行测试。使用自定义对象存储 */public class Test4 &#123; public static void main(String[] args) throws Exception &#123; Connection con = JDBCUtilsConfig.getConnection(); //获取执行者对象 String sql = "SELECT * FROM sort"; PreparedStatement pst = con.prepareStatement(sql); //执行sql语句 ResultSet rs = pst.executeQuery(); //创建list集合 ArrayList&lt;Sort&gt; list = new ArrayList&lt;Sort&gt;(); //处理结果集 while(rs.next()) &#123; list.add(new Sort(rs.getInt("sid"), rs.getString("sname"), rs.getDouble("sprice"), rs.getString("sdesc"))); &#125; //释放资源 JDBCUtilsConfig.close(con, pst, rs); //遍历集合 for (Sort sort : list) &#123; System.out.println(sort); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL数据库]]></title>
      <url>%2F2017%2F02%2F28%2F18-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[存储数据三种形式: 1. 变量 1. 特点: 数据在内存中 2. 问题: 不能持久化存储 2. IO流结合文件 1. 特点: 数据存储在文件中,实现了持久化存储 2. 问题: 数据存储在文件中,但是读取时,不同的实现可能效率差异比较大 3. 数据库 数据库 = 文件存储数据 + 算法封装 数据库* 存储数据的仓库 * 数据库的本质就是文件存储 * 数据库管理系统DBMS(DataBase Management System): 操作和管理数据库的大型软件 * 常用数据库: 1. MySQL: 开源免费.被Oracle收购.MySQL6.x后开始收费 2. Oracle: 收费的大型数据库 3. DB2: IBM公司的收费数据库,常用于银行系统 4. SQLServer: 微软,收费的中型数据库 5. SyBase: 淡出历史舞台了 6. SQLite: 嵌入式的小型数据库,应用于手机端 * dos窗口开关MySQL服务: 开: net start mysql 关: net stop mysql * dos窗口登录MySQL: mysql -u用户名 -p密码 SQL语句* 结构化查询语言,专门操作数据库的计算机语言 * 分类: 1. DDL:数据定义语言,用来定义数据库对象: create,alter,drop 2. DML:数据操作语言,用来对数据库中表的数据进行更新: insert,delete,update 3. DCL:数据控制语言,用来定义数据库的访问权限和安全级别，及创建用户 4. DQL:数据查询语言,用来查询数据库中表的数据: select,from,where * 语法: 1. 可以单行或多行书写, 分号结尾 2. 不区分大小写. 但关键字一般大写 * 注释： * 单行: -- * 多行: /* ... */ * 数据类型 * int: 整型 * double: 浮点 * varchar(M): 字符,M为0-65535之间的整数 * date: 日期,只有年月日,没有时分秒: yyyy-MM-dd * datetime: 日期时间都有 数据库操作1. 创建数据库: create database geekhoon; 创建数据库,并指定数据库中数据的编码: create database 数据库名 character set utf8; 修改数据库编码集(不建议修改):alter database 数据库名 character set utf8;//注意不是utf-8 2. 查看MySQL服务器中所有数据库: show databases; 查看某个数据库的定义的信息: show create database 数据; 3. 删除数据库: drop database 数据库名; 4. 使用数据库: use 数据库名; 5. 查看正在使用的数据库: select database(); 数据表操作1. 创建数据表: create table 表名( 字段名1 数据类型 约束, 字段名2 数据类型 约束, ... 字段名n 数据类型 约束 ); * 约束: 限制列可以使用的数据 分类: 1. 主键约束 primary key: 非空 唯一. 通常没有实际意义. 加上AUTO_INCREMENT可实现自增长 2. 非空约束 not null 3. 唯一约束 unique 4. 外键约束 5. 检查 check(MySQL没有该约束) 2. 删除数据表: drop table 表名; 3. 查看数据库中的所有表: show tables; 4. 查看建表语句: show create table 表名; 5. 查看表结构: desc 表名; 6. 修改表结构: * 添加列: alter table 表名 add 列名 数据类型 约束; * 修改列: alter table 表名 modify 列名 数据类型 约束; * 修改列名: alter table 表名 change 旧列名 新列名 数据类型 约束; * 删除列: alter table 表名 drop 列名; * 修改表名: rename table 旧表名 to 新表名; * 修改表的字符集:alter table 表名 character set 字符集; 123456789CREATE TABLE users( uid INT PRIMARY KEY AUTO_INCREMENT, uname VARCHAR(20) NOT NULL, uaddress VARCHAR(100) NOT NULL);-- 展示所有表SHOW TABLES;-- 显示表结构DESC users; 数据操作1. 增加数据:(列名1为主键) * insert into 表名(列名1,列名2,列名3) values(值1,值2,值2); * insert into 表名(列名2,列名3) values (值2,值3); 省去主键不写 * insert into 表名 values (全列值); 包括主键值也要写 * 批量写入数据: insert into 表名 (列名1,列名2,列名3) values (值1,值2,值3),(值1,值2,值3),...; 2. 修改数据: (在数据原有基础上修改) * update 表名 set 列1=值1,列2=值2 where 条件 * 条件的写法: 1. id = 5 2. id &lt;&gt; 5 : 不等于5 3. id &lt;= 5 4. or : 或 5. and : 与 6. not : 非 7. id in (1,3,4,5,6) : 表示包含的id 8. id not in (1,3,4,5,6) 3. 删除数据: delete from 表名 where 条件 truncate table 表名; 或 truncate 表名; 都可以 * 删除表中所有记录使用delete from 表名, 还是用truncate table 表名 ? delete是一条一条的删, 不清空AUTO_INCREMENT记录数 truncate直接将表删除,重新建表,AUTO_INCREMENT将置为0,重新开始;效率比delete高 4. 查询数据 * 查询指定列的数据: select 列名1,列名2 from 表名 * 查询全部列的数据: select * from 表名 * 查询去掉重复数据: select distinct 列名 from 表名 * 查询重新命名列: select 列名 AS 新名 from 表名 * 查询时直接运算: select 列名1,列名2+1000 as 新名 from 表名 : 列名2进行了运算,并用新名查询结果 * 查询表中第五到第十条数据: select * from 表名 limit(4,6); limit(m,n): 第一个数指开始的索引,从0开始,第二个参数是取得条数 * 命令行乱码问题: * mysql的客户端编码的问题我们的是utf8,而系统的cmd窗口编码是gbk,在cmd下输出中文会乱码 * 解决方案: 修改mysql客户端编码。 * dos下: set character_set_results=gbk; 或 set names gbk; 条件查询* 格式: select 字段 from 表名 where 条件; * 比较运算符: 123456789101112* &gt; &lt; &lt;= &gt;= = &lt;&gt;* BETWEEN ...AND... :显示在某一区间的值(含头含尾),效率比用大于小于号判断低* IN(set) :显示在in列表中的值，例：in(100,200),效率比用or高* LIKE :模糊查询 * Like语句中有两个通配符： % 用来匹配多个字符；例 '%a%'; _ 用来匹配一个字符。例 'a_';* is null :判断是空* is not null ":判断不为空 * SELECT * FROM phones WHERE xinghao IS NOT NULL; * SELECT * FROM phones WHERE NOT xinghao IS NULL; 注意：效果上二者等价 效率上:前者高 排序查询* order by 列名 [desc][asc]:排序要放在最后 * desc 降序 * asc 升序,默认升序 * 升序: select * from 表名 order by 列名 * 降序: select * from 表名 order by 列名 desc; 聚合函数* count：统计指定列不为NULL的记录行数； * sum：计算指定列的数值和，如果指定列类型不是数值类型,则计算结果为0； * max：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串类型排序运算； * min：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算； * avg：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0； 12345678-- 统计行数select count(*) as 'count' from 表名;-- 求和select sum(money) from zhangwu where name like '%支出%';-- 求最大值select max(money) from zhangwu;//null值不会计算-- 求平均值select avg(money) from zhangwu;//null值不会计算 分组查询* 格式: select 列1,列2 from 表名 where 条件 group by 列名 having 条件 order by 列名; * group by 被分组的列名 : 要放在最后,有排序的话,排序放最后 * having 和 where的区别: 1. having是在分组后对数据进行过滤 where是在分组前对数据进行过滤 2. having后面可以使用聚合函数进行判断 where后面不可以使用聚合函数进行判断,聚合函数的新名也不可以 * 被分组的列也要在select中 * 分组查询一般都跟随聚合函数 12345678910111213141516-- 分组查询,不跟聚合函数:SELECT * FROM phones GROUP BY pinpai;#效果：按照品牌分组之后,只取出每一组的第一条记录(不常使用)-- 分组查询-- 对zname内容进行分组, zname也要写在select后面SELECT zname,SUM(zmoney) FROM zhangwu GROUP BY zname-- 对zname内容进行分组查询求和,但是只要名称中包含"支付"的SELECT zname,SUM(zmoney) AS 'getsum' FROM zhangwu WHERE zname LIKE '%支出%'GROUP BY znameORDER BY getsum DESC-- 对zname内容进行分组查询求和,但是只要名称中包含"支付"的,且和超过100的-- 结果集是分组查询后,再次进行筛选,不能用where,要用havingSELECT zname,SUM(zmoney) AS 'getsum' FROM zhangwu WHERE zname LIKE '%支出%'GROUP BY znameHAVING getsum &gt; 100ORDER BY zmoney DESC 注意事项数据类型CHAR 和 VARCHAR比较: 1. 相同点: 语法与作用是一样的 2. 不同点: 1. 长度不同: CHAR为0-255之间的整数 VARCHAR为0-65535之间的整数 2. 数据存储结构不同 CHAR(10) ------ 比如存储数据&quot;AB&quot; ----底层为:&quot;AB &quot;,有8个空位 VARCHAR(10) --- 比如存储数据&quot;AB&quot; ----底层为:&quot;2AB&quot;,存储3个长度 存储结构角度: VARCHAR比CHAR类型设计更为合理,空间利用率高 CHAR类型存储空间固定,意味着可能存在资源浪费,灵活性差的问题,但是效率高 CHAR类型应用场景: 所有数据长度都一样时,可以使用CHAR 约束效果上: 主键 = 非空 + 唯一 但是主键不能换成not null和unique,因为主键还有索引的概念 索引可以对数据进行一步定位,效率更高 * 关于主键: 主键会被固定算法求成对应的索引,当我们通过主键查询时,比如id=&apos;a001&apos;,其实底层是根据 &apos;a001&apos;对应的索引一步定位查询的 MySQL多表表与表之间的关系有一对多,多对多,一对一 1. 单表设计存在的缺陷: 1). 数据重复存储,会浪费磁盘空间(数据没有实现复用) 2). 导致数据修改时效率低 2. 多表优点: 1. 存储空间更为节约 2. 修改信息时效率更高 3. 本质: 另一种形式的封装 外键12345678910111213141516* 作用: 限制从表某些字段的数据使用* 使用: 1. 将主从表记录通通清空(不一定) 2. 按照外键语法添加外键* 语法: * 添加外键: alter table 从表名 add constraint 外键名 foreign key (从表中外键字段名) references 主表名(主表的主键字段名) 效果: 从表的使用外键的字段的数值只能是主表中被引用的字段已经存在的数字* 注意: 从表中的外键必须和主表的主键的数据类型一样* 外键名看不到,很少用到.需要用到的使用场景: 删除外键 * 查看外键方式: show create table 从表名; * 删除外键: alter table 从表名 drop foreign key 外键名; 一对多例: 1. 学生信息表与考试信息表: &quot;一条学生信息&quot;可以对应&quot;多条考试成绩信息&quot; &quot;一条考试成绩信息&quot;只属于&quot;一条学生信息&quot; 2. 用户表与订单表: &quot;一条用户信息&quot;可以对应&quot;多条订单信息&quot; &quot;一条订单信息&quot;只属于&quot;一条用户信息&quot; 3. 客户表与银行卡表: &quot;一条客户信息&quot;可以对应&quot;多条银行卡信息&quot; &quot;一条银行卡信息&quot;只属于&quot;一条客户信息&quot; 如上的表设计就是&quot;一对多&quot; * 主表(一表): 将&quot;一方&quot;称之为主表或一表 * 从表(多表): 将&quot;多方&quot;称为为从表或多表 * &quot;一对多&quot;的实现: 在&quot;从表&quot;中创建一个字段来引用&quot;主表&quot;的主键作为外键 多对多例: 1. 学生表与课程表: &quot;一条学生信息&quot;可以对应&quot;多条课程信息&quot; &quot;多条学生信息&quot;可以对应&quot;一条课程信息&quot; 2. 班级表与教师表: &quot;一条班级信息&quot;可以对应&quot;多条教师信息&quot; &quot;多条班级信息&quot;可以对应&quot;一条教师信息&quot; 3. 订单表与商品表: &quot;一条订单信息&quot;可以对应&quot;多条商品信息&quot; &quot;多条订单信息&quot;可以对应&quot;一条商品信息&quot; 如上的表设计就是&quot;多对多&quot; * &quot;多对多&quot;的实现: 1. 创建一个中间表 2. 在中间表(从表)中创建两个字段来分别引用两张&quot;主表&quot;的主键作为外键; 两个字段的组合可以表示多对多的关联 * 使用 1. 查主表1 2. 查中间表(从表) 3. 查主表2 * 优化1: * 加外键(两个字段都要加) 1. 将中间表记录清空(如果表记录没有违反现实逻辑,可以不清空) 2. 添加外键 * 优化2: * 加联合主键(多个字段联合作为主键),组合方式不能重复 * 开发中不常用,效率低 * 语法: primary key (字段1,字段2) 一对一例: 公民表与身份证表 多表查询交叉查询(笛卡尔积)12笛卡尔积 --- 有大量无用数据 SELECT * FROM 表1,表2; 内连接查询12345* 查询有用数据1. 隐式: SELECT * FROM 表1,表2 WHERE 条件;2. 显式: SELECT * FROM 表1 INNER JOIN 表2 ON 条件; 外连接查询123456789101. 左外连接查询: SELECT * FROM 表1 LEFT OUTER JOIN 表2 ON 条件;注意: 查询左表(表1)所有的数据,右表(表2)是否显示,取决于条件是否成立,如果成立显示,如果不成立显示null;2. 右外连接查询: SELECT * FROM 表1 RIGHT OUTER JOIN 表2 ON 条件;注意: 查询右表(表2)所有的数据,左表(表1)是否显示,取决于条件是否成立,如果成立显示,如果不成立显示null;3. 拓展: * A left outer join B 等价于 B right outer join A 子查询12345* 使用一个select查询的结果作为另一个select的一部分(查询结果,查询条件,查询表等);* 查询结果唯一用"=",多个结果用"in"* 如:SELECT * FROM 表1 WHERE id = (SELECT id FROM 表2 WHERE 条件);SELECT * FROM 表1 WHERE id in (SELECT id FROM 表2 WHERE 条件); 商城数据库设计多表关系图 sql语句123456789101112131415161718192021222324252627282930313233343536373839404142CREATE DATABASE shop;USE shop;#创建用户表CREATE TABLE USER( uid VARCHAR(20) PRIMARY KEY,#主键 username VARCHAR(20)#用户名);#创建订单表CREATE TABLE orders( oid VARCHAR(20) PRIMARY KEY,#主键 createdate DATE,#下单时间 total_price DOUBLE,#总费用 user_id VARCHAR(20)#用户id(外键));#创建用户表与订单表间的外键约束ALTER TABLE orders ADD CONSTRAINT uid_fk FOREIGN KEY(user_id) REFERENCES USER(uid);#创建商品表CREATE TABLE product( pid VARCHAR(20) PRIMARY KEY,#主键 pname VARCHAR(20),#商品名 price DOUBLE,#价格 category_id VARCHAR(20)#商品分类(外键));#创建分类表CREATE TABLE category( cid VARCHAR(20) PRIMARY KEY,#主键 cname VARCHAR(20)#分类名);#创建商品表与分类表键的外键约束ALTER TABLE product ADD CONSTRAINT cid_fk FOREIGN KEY(category_id) REFERENCES category(cid);#创建商品与订单中间表CREATE TABLE orderitem( pid VARCHAR(20),#商品id(外键) oid VARCHAR(20)#订单id(外键));#创建中间表与订单表之间的外键约束ALTER TABLE orderitem ADD CONSTRAINT oid_fk FOREIGN KEY(oid) REFERENCES orders(oid);#创建中间表与商品表之间的外键约束ALTER TABLE orderitem ADD CONSTRAINT pid_fk FOREIGN KEY(pid) REFERENCES product(pid);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多线程]]></title>
      <url>%2F2017%2F02%2F25%2F17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[线程与进程* 进程: 正在执行的程序. 当一个程序进入内存执行,即变成一个进程 * 线程: 进程中的一个执行单元,执行路径. * 单线程: 一个应用程序只有一条执行路径 * 多线程: 一个应用程序有多条执行路径 * 一个程序运行后至少有一个进程,一个进程中可以包含多个线程 * 线程的调度: * 分时调度: 所有线程轮流使用CPU的使用权,平均分配每个线程占用 CPU 的时间。 * 抢占式调度: 优先让优先级高的线程使用 CPU,如果线程的优先级相同,那么会随机选择一个 * 对于CPU的一个核而言,某个时刻,只能执行一个线程, 而 CPU的在多个线程间切换速度相对我们的感觉要快,看上去就是在同一时刻运行。 * 多线程程序并不能提高程序的运行速度,但能够提高程序运行效率,让CPU的使用率更高 * main的主线程: &quot;main&quot; * 多线程的意义: 提高应用程序的使用率 * 多进程的意义: 提高CPU的使用率 * Java程序的运行原理: Java命令去启动JVM,JVM会启动一个进程,该进程会启动一个主线程 * JVM的启动是多线程吗? 是.因为它最低有俩个线程启动,主线程和垃圾回收线程 Thread类概述* 是线程的一种实现方式 * Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程 * 多线程的实现方案: 1. 继承Thread类 该子类应重写 Thread 类的 run 方法。创建对象，开启线程。run方法相当于其他线程的main方法。 2. 实现Runnable接口 该类实现 run 方法, 然后创建Runnable的子类对象，传入到Thread子类的构造方法中，开启线程。 继承Thread类* 创建和启动一个线程: 1. 创建Thread子类对象, 继承Thread, 重写方法run() 2. 子类对象调用start(): 让线程程序执行, JVM调用线程中的run 一个对象只能开启一次start(),多次启动一个线程是非法的 1234567891011121314151617public class SubThread extends Thread &#123; public void run()&#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println("SubThread...."+i); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; SubThread st = new SubThread(); st.start(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println("main...."+i); &#125; &#125;&#125;//打印结果是SubThread....和main....无规律交叉打印,因为线程执行的随机性 为什么要继承Thread类* 因为可以根据自己的需求重写run方法 * 注意start()和run()的区别: start(): 开启线程,并让JVM调用run() run(): 不开启线程 * 创建线程的目的: 让程序可以独立运行 获取线程名字getName()1234567891011121314151617String getName(): 返回该线程的名称, Thread类的方法public class SubThread extends Thread &#123; public void run()&#123; System.out.println(super.getName()); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; SubThread st = new SubThread(); SubThread st1 = new SubThread(); st.start(); st1.start(); &#125;&#125;打印结果: 获得的是当前线程的默认名字,根据线程被执行的先后顺序命名Thread-0Thread-1 currentThread()12345678static Thread currentThread(): 返回正在执行的线程对象, Thread类的方法//如果要获取主线程的名字, 只能用此方法public class Test &#123; public static void main(String[] args) &#123; //返回正在执行的线程的名字 System.out.println(Thread.currentThread().getName()); &#125;&#125; 设置线程名字* 两种方式: 1. 构造器 2. setName() 12345678910111213141516171819202122232425262728public class SubThread extends Thread &#123; @Override public void run() &#123; System.out.println(getName()); &#125; public SubThread() &#123; super("线程名2"); &#125; public SubThread(String name) &#123; super(name); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; SubThread st1 = new SubThread("旺财"); st1.start();//打印旺财 SubThread st2 = new SubThread(); st2.start();//打印线程名2 SubThread st3 = new SubThread(); st3.setName("线程名1"); st3.setName("线程名3"); st3.start();//打印线程名3 &#125;&#125; 睡眠sleep()* static void sleep(毫秒) * main方法中和Thread子类的run()中都可以使用 * main()中可以抛异常 * run()中只能try/catch,不能抛异常,因为父类Thread没抛异常 12345678910111213141516171819202122232425262728293031做法一:public class SubThread extends Thread &#123; @Override public void run() &#123; for (int i = 5; i &gt;= 1; i--) &#123; try&#123; System.out.println(i); Thread.sleep(1000); &#125;catch(Exception ex)&#123; &#125; &#125; System.out.println("发射!!"); &#125;&#125;public class Test2 &#123; public static void main(String[] args) throws Exception &#123; SubThread st = new SubThread(); st.start(); &#125;&#125;做法二:public class Test2 &#123; public static void main(String[] args) throws Exception &#123; for (int i = 5; i &gt;= 1; i--) &#123; System.out.println(i); Thread.sleep(1000); &#125; System.out.println("发射!"); &#125;&#125; Runnable接口* 实现线程程序的另一个方式 * 实现接口Runnable, 重写run() * 创建和启动一个线程: 1. 定义一个类,实现接口Runnable, 重写run() 2. 测试类中创建Thread类对象,构造方法中,传递Runnable接口实现类 3. Thread类对象调用方法start() * 实现Runnable接口, 避免了继承Thread类的单继承局限性, 可以多实现 1234567891011121314151617181920212223//1. 定义一个类,实现接口Runnable, 重写run()public class SubRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; System.out.println(Thread.currentThread().getName()+"..."+i); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123;//2. 测试类中创建Thread类对象,构造方法中,传递Runnable接口实现类 SubRunnable sr = new SubRunnable(); Thread t = new Thread(sr);//3. Thread类对象调用方法start() t.start(); for (int i = 0; i &lt; 50; i++) &#123; System.out.println(Thread.currentThread().getName()+"..."+i); &#125; &#125;&#125;//结果是Thread-0..值 和 main...值交叉无规律打印 实现Runnable的好处* 避免了单继承的局限性 * 降低了程序的耦合性,Runnable接口对线程对象和线程任务进行解耦 匿名内部类实现多线程程序* 前提: 继承或接口实现 1234567891011121314151617181920212223public static void main(String[] args) &#123; //方式一:new Thread类,调用start() new Thread()&#123; @Override public void run() &#123; System.out.println("1.开启线程"); &#125; &#125;.start(); //方式二:new Runnable接口,作为Thread构造方法的参数,Thread对象调用start() Runnable r = new Runnable() &#123; public void run() &#123; System.out.println("2.开启线程"); &#125; &#125;; new Thread(r).start(); //方式三: 将方式二两步合在一起 new Thread(new Runnable()&#123; @Override public void run() &#123; System.out.println("3.开启线程"); &#125; &#125;).start();&#125; 线程状态1. NEW: 新建状态 new Thread()/Thread子类对象 2. RUNNABLE: 运行状态 start() 3. BLOCKED: 受阻塞状态 4. TIMED_WAITING: 休眠 sleep() 5. WAITING: 等待 wait()/notify()唤醒 6. TERMINATED: 死亡状态 run()结束,stopr() 线程池* 容纳多个线程的容器 * 原理: * 程序一开始的时候,创建多个线程对象,存储到集合中,需要线程时,从集合获取线程出来 * 线程用完后,回到容器中,省去每次开启关闭线程的麻烦和资源浪费 * JDK1.5之后, 内置线程池技术 使用线程池的方式* Executors类 * 创建线程池的工厂类 * 方法: * static ExecutorService newFixedThreadPool(int nThreads): 返回线程池对象 其实返回的是ExecutorService接口的实现类(线程池对象) * newSingleThreadExecutor() * shutdown(): 删除线程池 * 步骤: 1. 使用工厂类Executors中的静态方法创建线程对象,指定线程个数 static ExecutorService newFixedThreadPool(int nThreads) 2. 接口实现类对象, 调用方法submit(Runnable r), 提交线程执行任务 参数是Runnable接口的实现类 Callable接口* 实现线程的第三种方式 * 有返回值, 可以抛异常 * 重写call() * 步骤: 1. 使用工厂类Executors中的静态方法创建线程对象,指定线程个数 static ExecutorService newFixedThreadPool(int nThreads) 2. 接口实现类对象, 调用方法submit(Callable&lt;T&gt; c), 提交线程执行任务 参数是Callable接口的实现类 submit(Callable&lt;T&gt; c)返回Future&lt;T&gt;接口的实现类 Future接口中有get(),可以获取返回值 123456789101112131415161718public class SubCollable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; return "geekhoon"; &#125;&#125;public class Test &#123; public static void main(String[] args) throws Exception, ExecutionException &#123; ExecutorService es = Executors.newFixedThreadPool(2); Future&lt;String&gt; f1 = es.submit(new SubCollable()); Future&lt;String&gt; f2 = es.submit(new SubCollable()); String s1 = f1.get(); String s2 = f2.get(); System.out.println(s1); System.out.println(s2); &#125;&#125; 线程实现异步求和* 要求: 两个进程,1个进程求1+..100的和,另一个进程求1+..200的和 1234567891011121314151617181920212223242526方式一: 使用Runnable接口public class SubRunnable implements Runnable &#123; private int num; public SubRunnable(int num)&#123; this.num = num; &#125; @Override public void run() &#123; int sum = 0; for (int i = 0; i &lt;= num; i++) &#123; sum += i; &#125; //因为Runnable接口没有返回值,所以和要直接打印 System.out.println(Thread.currentThread().getName()+"..."+sum); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; SubRunnable sr1 = new SubRunnable(100); SubRunnable sr2 = new SubRunnable(200); Thread t1 = new Thread(sr1, "线程1");//第二个参数就是设置当前进程的名字 Thread t2 = new Thread(sr2, "线程2");//也可以用setName() t1.start(); t2.start(); &#125;&#125; 12345678910111213141516171819202122232425方式二: 使用Callable接口public class SubCallable implements Callable&lt;Integer&gt; &#123; private int num; public SubCallable(int num)&#123; this.num = num; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i = 0; i &lt;= num; i++) &#123; sum += i; &#125; return sum; &#125;&#125;public class Test2 &#123; public static void main(String[] args) throws Exception &#123; ExecutorService es = Executors.newFixedThreadPool(2); Future&lt;Integer&gt; f1 = es.submit(new SubCallable(100)); Future&lt;Integer&gt; f2 = es.submit(new SubCallable(200)); System.out.println("1 + .. + 100 = "+f1.get()); System.out.println("1 + .. + 200 = "+f2.get()); &#125;&#125;//注意: 两种方法的run()和call()都是无参方法,只能通过构造方法进行传值 多线程安全问题* 判断多线程是否有安全问题的依据: 1. 是否是多线程环境 2. 是否有共享数据 3. 是否有多条语句操作共享数据 * 解决安全问题,Java程序提供了同步技术 * 同步代码块公式: synchronized(任意对象){ 多条语句操作共享数据的代码 } * 特别注意: 同步代码块生效的前提是对象锁唯一,就是要用同一个对象 * 卖票问题: 1. 同票多次: CPU的每一次执行,必须是一个原子性操作(最简单,最基本的操作). System.out.println(&quot;...卖了第&quot;+(100-ticketsCount+1)+&quot;票,剩&quot;+--ticketsCount+&quot;张&quot;); 这一句就不是原子操作,因为既进行了打印又进行了递减操作,可能线程刚打印完还没进行自减 此时第二个线程进来,抢占了CPU资源,于是打印的值就和前一个一样 2. 负数票: 随机性和延迟导致的 * 解决方法: 1. 同步代码块 2. 同步方法: 同步方法(this)和静态同步方法(类名.class) 1234567891011121314151617181920212223242526272829设置了休眠Thread.sleep(500);引发了多线程安全问题//出现多线程负数票的原因:当剩下最后一张票的时候,窗户1进入一处并休眠,窗口2也进入一处并休眠1唤醒后,打印卖了100张,剩0张但此时窗口2线程也在循环内,也进行打印,就出现了负值public class MyThread implements Runnable &#123; private int ticketsCount = 100; @Override public void run() &#123; while(true)&#123; if (ticketsCount &lt;= 0 ) &#123; break; &#125; try &#123; Thread.sleep(500);//一处 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"...卖了第"+(100-ticketsCount+1)+"票,剩"+--ticketsCount+"张"); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); new Thread(my1, "窗口1").start(); new Thread(my1, "窗口2").start(); &#125;&#125; 1234567891011121314151617181920212223242526272829设置同步代码块,解决多线程安全问题public class MyThread implements Runnable &#123; private int ticketsCount = 100; private Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; //ticketsCount是共享数据, 所以要放在同步代码中 if (ticketsCount &lt;= 0 ) &#123; break; &#125; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"...卖了第"+(100-ticketsCount+1)+"票,剩"+--ticketsCount+"张"); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); new Thread(my1, "窗口1").start(); new Thread(my1, "窗口2").start(); &#125;&#125; 同步原理* 同步代码块传入的对象是任意对象, 这个对象也叫做同步锁,对象监视器 * 同步保证安全性: 没有锁的线程不能执行, 只能等 * 前提: 多线程 * 解决问题时要注意: 多个线程使用的是同一个锁对象 * 好处: 解决了多线程的安全问题 * 弊端: 线程很多时,每个线程都会判断同步上的锁,很耗费资源,并且降低程序运行效率 * 原理: 1. 线程遇到同步代码块, 就会判断有没有同步锁, 2. 有: 获取同步锁,进去同步代码中执行. 执行完毕后, 将锁对象还回去 在同步中的线程, 进行了休眠, 此时另一个线程会执行 遇到同步代码块, 再一次判断有没有同步锁 没有: 线程不能进去同步代码, 被阻挡在同步代码块外面 * 一个线程进入了同步代码块, 其余线程就进不去, 只能在线程代码块外面等 * 没有锁的线程,不能进入同步,在同步中的线程,不出去同步,不会释放锁 同步方法* 采用同步方法形式, 解决线程的安全问题 * 好处: 代码简洁 * 将线程共享数据,同步,抽取到方法 * 在方法的声明上, 加上同步关键词synchronized * 问题: 1. 同步方法中有锁吗? 有.同步方法中的对象锁就是本类对象的引用this 2. 如果同步方法是静态的, 有锁吗? 成员变量也要改成静态的. 也有锁. 锁不是this(因为静态随类的加载而加载,此时还没有对象) 锁是本类的字节码文件对象(类名.class) * 线程安全的类: 1. StringBuffer 2. Vector 3. HashTable 1234567891011121314151617181920212223242526public class MyThread implements Runnable &#123; private int ticketsCount = 20; @Override public void run() &#123; while(true)&#123; payTickets(); &#125; &#125; public synchronized void payTickets() &#123; if (ticketsCount &gt; 0 ) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"...卖了第"+(20-ticketsCount+1)+"票,剩"+--ticketsCount+"张"); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); new Thread(my1, "窗口1").start(); new Thread(my1, "窗口2").start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142静态同步方法public class MyThread implements Runnable &#123; private static int ticketsCount = 20; @Override public void run() &#123; while(true)&#123; payTickets(); &#125; &#125; public static synchronized void payTickets() &#123; if (ticketsCount &gt; 0 ) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"...卖了第"+(20-ticketsCount+1)+"票,剩"+--ticketsCount+"张"); &#125; &#125;&#125;或public class MyThread implements Runnable &#123; private static int ticketsCount = 20; @Override public void run() &#123; while(true)&#123; payTickets(); &#125; &#125; public static void payTickets() &#123; synchronized(MyThread.class)&#123;//锁是本类 if (ticketsCount &gt; 0 ) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"...卖了第"+(20-ticketsCount+1)+"票,剩"+--ticketsCount+"张"); &#125; &#125; &#125;&#125; lock接口* JDK1.5新特性 * 方法: 1. void lock(): 上锁 2. void unlock(): 解锁 * 实现类有ReentrantLock * 加锁解锁位置与同步代码块一样 123456789101112131415161718192021222324252627282930public class MyThread implements Runnable &#123; private static int ticketsCount = 20; //在类的成员位置,创建Lock接口的实现类对象 private Lock lock = new ReentrantLock(); @Override public void run() &#123; while(true)&#123; //调用lock获取锁 lock.lock(); if (ticketsCount &gt; 0 ) &#123; try &#123; Thread.sleep(500); System.out.println(Thread.currentThread().getName()+"...卖了第"+(20-ticketsCount+1)+"票,剩"+--ticketsCount+"张"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //释放锁 lock.unlock(); &#125; &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); new Thread(my1, "窗口1").start(); new Thread(my1, "窗口2").start(); &#125;&#125; 死锁* 如果出现了同步嵌套, 就容易产生死锁 * 同步弊端: 1.效率低 2.容易产生死锁 * 死锁问题: 是指两个或两个以上的线程在执行过程中,因争夺资源产生的一种互相等待的现象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//两把锁public class LockA &#123; //私有化构造方法 private LockA()&#123;&#125; //使得对象只能通过类名.调用, 且保证唯一性 public static final LockA locka = new LockA();&#125;public class LockB &#123; public LockB()&#123;&#125; public static final LockB lockb = new LockB();&#125;//public class DeadLock implements Runnable &#123; private int i = 0; @Override public void run() &#123; while(true)&#123; if (i % 2 == 0) &#123; //先进入A同步,再进入B同步 synchronized (LockA.locka) &#123; System.out.println("if...loaka"); synchronized (LockB.lockb) &#123; System.out.println("if...lockb"); &#125; &#125; &#125;else&#123; //先进入B同步,再进入A同步 synchronized (LockB.lockb) &#123; System.out.println("else...lockb"); synchronized (LockA.locka) &#123; System.out.println("else...locka"); &#125; &#125; &#125; i++; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; DeadLock d = new DeadLock(); Thread t0 = new Thread(d); Thread t1 = new Thread(d); t0.start(); t1.start(); &#125;&#125; 线程间通信问题* 不同种类的线程间针对同一个资源的操作 * 可能出现的问题: 1. 赋值不生效, 打印的是默认值: 操作不同资源类对象 2. 同一数据出现多次: CPU的一点点时间片的执行权,就足够执行多次,Output的线程一直抢占,就会打印多次 3. 姓名和性别不匹配: 线程运行的随机性 * 以下为操作不同资源类对象,产生null的代码 * 处理这个问题,可以在测试类中先创建好该对象,再作为参数, 通过生产者Input,消费者Output各自的构造方法进行传参, 以达到操作同一资源的目的,完成线程间通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * 资源类,有两个成员变量 * 有两个线程Input和Output分别对其赋值和打印 */public class Resource &#123; public String name; public String sex;&#125;/* * 输入的线程,即生产者线程, 对资源对象Resource中成员变量赋值 */public class Input implements Runnable &#123; //注意:只声明了资源类对象,并没有new private Resource r = new Resource(); @Override public void run() &#123; int i = 0; while(true)&#123; //这里加上同步锁,避免出现打印"张三...nv"和"lisi...男"的情况 //特别注意:生产者消费者加的要是同一把锁,所以传的是唯一的Resource类对象 synchronized (r) &#123; if (i % 2 == 0) &#123; r.name = "张三";//如果不加同步代码块,且上一次打印的是lisi..nv,则执行到这一步,如果输出线程抢到了CPU,就会打印出张三...nv r.sex = "男"; &#125;else&#123; r.name = "lisi";//如果不加同步代码块,且上一次打印的是张三...男,执行到这一步时,输出线程抢到了CPU,就会打印出lisi...男 r.sex = "nv"; &#125; &#125; i++; &#125; &#125;&#125;/* * 输出线程, 即消费者线程, 对资源对象Resource中成员变量,输出值 */public class Output implements Runnable&#123; private Resource r = new Resource(); @Override public void run() &#123; while(true)&#123; synchronized (r) &#123; System.out.println(r.name+"..."+r.sex); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; Input in = new Input(); Output out = new Output(); new Thread(in).start(); new Thread(out).start(); &#125;&#125; 打印结果是循环打印null...null, 原因是Input和Output中都重新new了Resource对象它们操作的是不同对象 线程等待与唤醒机制* 等待唤醒机制所涉及到的方法,在Object类中: 1. wait(): 等待, 将正在执行的线程释放其执行资格和执行权,并存储到线程池中。 2. notify(): 唤醒, 唤醒线程池中wait()的线程,一次唤醒一个,而且是任意的。 3. notifyAll(): 唤醒全部, 可以将线程池中的所有wait()线程都唤醒。 * 为什么这些方法不定义在Thread类中? 因为这些方法的调用必须通过锁对象调用, 而同步代码块的锁对象是任意类型对象 * 唤醒: 让线程池中的线程具备执行资格。必须注意的是,这些方法都是在同步中才有效。 * 这些方法在使用时必须标明所属锁,这样才可以明确出这些方法操作的到底是哪个锁上的线程。 * 思路: 1. 生产者: 先看是否有数据,有就等待,没有就生产,生产完之后,通知消费者消费数据 2. 消费者: 先看是否有数据,有就消费,没有就等待,等待前,通知生产者生产数据 * 为什么变成了一个一个打印,而不是一片一片打印? 因为等待唤醒机制,使得每生产一个数据就消费一个数据,生产完会暂停生产,待消费完再生产 消费完会暂停消费,待生产完再消费,保证了每次只有一个数据在操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* * 资源类,有两个成员变量 * 有两个线程Input和Output分别对其赋值和打印 */public class Resource &#123; public String name; public String sex; //设置布尔类型变量flag, 用于表示赋值和打印的状态 //true表示,有数据, 赋值完成,需要进行输出操作了 //false表示,没有数据, 需要进行赋值操作,此时不能进行输出操作 public boolean flag = false;&#125;/* * 输入的线程,对资源对象Resource中成员变量赋值 */public class Input implements Runnable &#123; //注意:只声明了资源类对象,并没有new private Resource r; //用构造方法对Input,Output进行传参,使得Resource对象锁唯一 public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int i = 0; while(true)&#123; //这里加上同步锁,避免出现打印"张三...nv"和"lisi...男"的情况 synchronized (r) &#123; //判断有没有数据, true说明赋值完成,使对象等待 if (r.flag) &#123;// 1处 try &#123; r.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //为fasle,进行赋值操作 if (i % 2 == 0) &#123; r.name = "张三"; r.sex = "男"; &#125;else&#123; r.name = "lisi"; r.sex = "nv"; &#125; //有数据了,置为true r.flag = true; //唤醒,注意是资源类对象进行唤醒,唤醒消费者线程 r.notify(); //唤醒消费者,并不意味着消费者线程马上执行,还是需要二者抢夺CPU//如果生产者抢到了,会再次进入run(),有数据进入1处后,还是等待,此时消费者线程可以抢到CPU,从之前等待处唤醒,打印当前信息//如果消费者抢到了,会从之前等待处唤醒,打印当前信息 &#125; i++; &#125; &#125;&#125;/* * 输出线程,对资源对象Resource中成员变量,输出值 */public class Output implements Runnable&#123; private Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while(true)&#123; synchronized (r) &#123; //为false,说明输出完了,没有数据,就等待 if (!r.flag) &#123; try &#123; r.wait();//1处//1处:消费者线程wait()后,立即释放锁.生产者线程就会执行, 消费者线程醒来的时候还是从本条语句醒来 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //为true,有数据就消费 System.out.println(r.name+"..."+r.sex); //消费完, 没有数据了 r.flag = false; //唤醒生产者线程 r.notify();//注意唤醒生产者,不代表立即执行生产者线程 &#125; &#125; &#125;&#125;/* * 测试类 */public class Test &#123; public static void main(String[] args) &#123; Resource r = new Resource(); Input in = new Input(r); Output out = new Output(r); new Thread(in).start(); new Thread(out).start(); &#125;&#125; 常见面试题1. start()和run()的区别: * run(): 封装了被线程执行的代码, 直接调用仅仅是普通方法的调用 * start(): 启动线程, 并由JVM自动调用run() 2. sleep()和wait()的区别: * sleep(): 必须指定时间; 不释放锁 * wait(): 可以指定时间,也可以不指定时间; 释放锁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO流]]></title>
      <url>%2F2017%2F02%2F20%2F16-IO%E6%B5%81%2F</url>
      <content type="text"><![CDATA[File类概述* java.io.File * 文件和目录路径名的抽象表示形式 * 将操作系统中文件,目录(文件夹),路径,封装成File对象 * 提供方法, 操作系统中的内容 * File是与系统无关的类 * 文件 file * 目录 directory * 路径 path 成员变量1. static String pathSeparator : 与系统有关的 路径分隔符 Windows: 打印出来是一个分号 Linux : 打印出来是一个冒号 2. static separator : 与系统有关的默认 名称分隔符 Windows: 打印出来是一个 \ Linux: 打印出来是一个 / 构造方法1. File(String pathname) : 传递路径名, 将路径封装成一个File类型对象 路径名中\,要写两个,因为要转义 2. File(String parent,String child) : 传递路径, 传递字符串父路径, 字符串子路径 好处: 可以单独操作父路径与子路径 3. File(File parent, String child) : 传递路径, 传递File类型父路径, 字符串子路径 好处: 父路径是File类型, 父路径可以直接调用File类方法 绝对路径与相对路径* 绝对路径: 具体的一个文件路径, 在系统中具有唯一性 * 相对路径: 表示的是路径之间的相对关系, File类的功能1.创建功能1. 创建文件: boolean createNewFile(), 创建的文件路径和文件名, 是在File构造方法中给出的 File file = new File(&quot;c:\\a.txt&quot;); boolean b = file.createNewFile(); 如果创建的文件已存在, 不再重新创建. 这个方法只能创建文件, 不能创建文件夹 2. 创建文件夹: boolean mkdir(), 创建的文件夹路径和文件夹名, 是在File构造方法中给出的 如果创建的文件夹已存在, 不再重新创建 3. 创建多层文件夹: boolean mkdirs() 推荐使用, 因为创建一层和多层文件夹都可以 2.删除功能1. 删除文件或文件夹: boolean delete(), 删除的文件或文件夹, 是在File构造方法中给出 文件不存在或被打开, 则删除失败 删除文件可以直接删除,删除文件夹要确保该文件夹是空的 删除,不走回收站,直接从硬盘删除(需谨慎) 3.获取功能1. 返回路径中表示的文件或文件夹名: String getName() 获取路径中最后部分的名字, 不管存不存在 2. 返回路径字符串: String getPath() 3. 返回路径中表示的文件的字节数: long length() 只能拿到文件的字节数, 文件夹没有字节数 4. 获取String类型绝对路径: String getAbsolutePath() 5. 获取File类型绝对路径: File getAbsoluteFile() eclipse环境中, 写的是一个相对路径, 获得的绝对位置是当前工程根目录 6. 获取String类型父路径: String getParent() 7. 获取File类型父路径: File getParentFile() 8. 获取到File构造方法中封装的路径中的文件和文件夹名: String[] list() 获取的是文件名 9. 获取到File构造方法中封装的路径中的文件和文件夹名: File[] listFiles() 获取的是目录或者文件的全路径 8和9中如果要获得D盘根目录下的内容,要写成&quot;D:\\&quot;,如果只写成&quot;D:&quot;,获得是当前工程目录下的内容 10. 返回的是根目录盘符: static File[] listRoots() 4.判断功能1. 判断File构造方法中封装路径是否存在: boolean exists() 2. 判断File构造方法中封装的路径是不是文件夹 boolean isDirectorty() 3. 判断File构造方法中封装的路径是不是文件 boolean isFile() 4. 判断是否是隐藏的 boolean isHidden() 文件过滤器* 过滤一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹 * 方法介绍 * public File[] listFiles(FileFilter filter) * 原理: * listFiles()遍历目录的同时，获取到了文件名全路径， 调用过滤器的方法accept，将获取到的路径传递给accept方法的参数pathname * accept方法接收了参数pathname，参数是listFiles传递来的 * 在accept方法中，进行判断，如果这个路径是Java文件，返回true，否则返回false * 一旦方法返回了true * listFiles将路径保存到File数组中 遍历目录下的所有java文件1234567891011121314151617181920212223242526272829方式一: 自定义实现类,实现FileFilter接口,重写accep方法public class MyFilter implements FileFilter &#123; @Override public boolean accept(File pathname) &#123;//注意这个if条件的重要性: //判断当前过滤到的是否是文件夹, 如果是文件夹, 返回true,则继续遍历该文件夹//如果不加这个if,所有不是以.java为结尾的文件夹也被过滤掉,进不去文件夹内部进行遍历了 if (pathname.isDirectory()) &#123; return true; &#125; return pathname.getName().toLowerCase().endsWith(".java"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; File file = new File("D:\\Demo"); getAllJava(file); &#125; public static void getAllJava(File file)&#123; File[] subFiles = file.listFiles(new MyFilter()); for(File subFile : subFiles)&#123; if (subFile.isDirectory()) &#123; getAllJava(subFile); &#125;else&#123; System.out.println(subFile); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526方式二: 使用匿名内部类public class Test &#123; public static void main(String[] args) &#123; File file = new File("D:\\Demo"); getAllJava(file); &#125; public static void getAllJava(File file)&#123; File[] subFiles = file.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; if (pathname.isDirectory()) &#123; return true; &#125; return pathname.getName().toLowerCase().endsWith(".java"); &#125; &#125;); for(File subFile : subFiles)&#123; if (subFile.isDirectory()) &#123; getAllJava(subFile); &#125;else&#123; System.out.println(subFile); &#125; &#125; &#125;&#125; 1234567891011121314151617方式三: 不使用文件过滤器, 自己写判断条件public class Test &#123; public static void main(String[] args) &#123; File file = new File("D:\\Demo"); getAllJava(file); &#125; public static void getAllJava(File file)&#123; File[] subFiles = file.listFiles(); for (File subFile : subFiles) &#123; if (subFile.isFile() &amp;&amp; subFile.getName().toLowerCase().endsWith(".java")) &#123; System.out.println(subFile); &#125;else if (subFile.isDirectory()) &#123; getAllJava(subFile); &#125; &#125; &#125;&#125; 递归递归遍历全目录123456789101112131415161718192021222324public static void main(String[] args) &#123; File file = new File("D:\\demo"); getAllName(file);&#125;private static void getAllName(File file) &#123; //打印当前文件名 //System.out.println(file); //拿到file文件夹下所有内容 File[] subFiles = file.listFiles(); //注意加上这步, 以免报错 if (subFiles != null) &#123; //遍历文件数组 for(File subFile : subFiles)&#123; //如果是文件夹,继续递归调用getAllName if (subFile.isDirectory()) &#123; getAllName(subFile); &#125;else&#123; //如果是文件, 直接打印 System.out.println(subFile); &#125; &#125; &#125;&#125; 概念和注意事项* 方法自己调用自己, 方法频繁进栈 * 递归分两种, 直接递归与间接递归 * 注意: 1. 递归一定要有出口,必须可以让程序停下 2. 递归次数不能过多 3. 构造方法,禁止递归 斐波那契数列12345678910111213public static void main(String[] args) &#123; System.out.println(getFBNQ(12));&#125;public static int getFBNQ(int month)&#123; if (month == 1) &#123; return 1; &#125; if (month == 2) &#123; return 1; &#125; return getFBNQ(month-2)+getFBNQ(month-1); &#125; 字节流* 输入Input: 文件到程序 * 输出Output: 程序到文件 * 输入输出以Java程序为参照 字节输出流* java.io.OutputStream 所有字节输出流的父类 * 是一个抽象类 * 作用: 从Java程序,写出文件 * 字节: 这样的流每次只操作文件中的一个字节 * 可以写任意文件, 注意不是文件夹 方法1. write(int b): 写入一个字节, int可以变成byte 2. write(byte[] b): 写入字节数组 3. write(byte[] b, int off, int len): 写入字节数组, off是开始写入的索引,len是写几个 4. void close(): 关闭流对象,释放与流相关的资源, 关闭之前会调用flush方法 注意: 流对象, 操作文件的时候, 自己不做, 依赖操作系统 FileOutputStream类* OutputStream实现类 * 写入数据文件 * 构造方法:绑定输出的输出目的, 可以创建文件, 如果文件已存在, 直接覆盖 * 参数(输出目的): 1. File 封装文件 2. String 字符串的文件名 * 流对象使用步骤: 1. 创键流子类的对象, 绑定输出目的 2. 调用流对象的方法write写 3. close释放资源 * 文件的续写和换行 1. 续写使用FileOutputStream类构造方法: * FileOutputStream(File file, boolean append) * FileOutputStream(String file, boolean append) append置为true, 可以续写 2. 换行 * \r\n * 可以写在上一行的末尾, 或者下一行的开头 * fos.write(&quot;\r\n&quot;.getBytes()); * IO流中的异常处理 try..catch..finally * 细节: 1. 保证流对象变量, 作用域足够 2. catch里面 * 处理异常(输出异常信息) * 停止程序, 重新尝试 3. 如果流对象建立失败了, 即new对象时失败了, 没有占用系统资源 * 释放资源时, 对流对象进行判断null * 变量不是null, 对象建立成功, 需要关闭资源 1234567891011121314151617public static void main(String[] args) throws IOException &#123; //1. 创建流对象, 绑定输出的输出目的 FileOutputStream fos = new FileOutputStream("a.txt",true); //2. 写入一个字节,会自动查ASCII表, 写入解码后的内容 fos.write(97);//这是一个字节 //写入一个字节数组, 使用getBytes()后,查两次码表,第一次将字符串编码成对应的ASCII码 //第二次是写入文件时, 将对应的ASCII码解码成对应的字符 byte[] bytes = &#123;-65,-66,67,68&#125;; fos.write(bytes); //写入了一个汉字和CD, 两个负数代表一个汉字 fos.write("\r\n".getBytes());//插入换行 fos.write(bytes,2,2);//写入字节数组的一部分, 写入了CD //写入字节数组的简便方式: 调用String类的getBytes() fos.write("www.geekhoon.com".getBytes());//这是十六个字节 foe.write("你好".getBytes()); //一个汉字是两个字节 //3. 关闭流对象 fos.close();&#125; 123456789101112131415161718192021222324252627//IO流中异常处理public static void main(String[] args) &#123; //声明变量 FileOutputStream fos = null; try&#123; //创建对象 fos = new FileOutputStream("c:\\a.txt"); //写入数据 fos.write(100); &#125;catch(IOException ex)&#123; //打印异常信息 ex.printStackTrace(); //如果是运行时异常,IOException处理不了,要抛异常 throw new RuntimeException("文件写入失败,请重试"); &#125;finally&#123; try &#123; //判断对象是否创建成功 if (fos != null) &#123; fos.close(); &#125; &#125; catch (IOException ex) &#123; //关闭流对象,添加try.catch的原因是,对象即使创建成功了,可能在写入过程中 //突然将外界存储断开,则写入失败, 要抛运行异常 throw new RuntimeException("关闭资源失败"); &#125; &#125;&#125; 字节输入流* java.io.InputStream 所有字节输入流的父类 * 是一个抽象类 * 作用: 读取任意文件, 每次只读取1个字节 方法1. int read(): 读取一个字节 2. int read(byte[] b): 读取一定量的字节,存储到数组中 FileInputStream类* InputStream实现类 * 构造方法: 为这个流对象绑定数据源 * 参数(数据源) 1. File 封装文件 2. String 字符串的文件名 * 步骤: 1. 创建字节输入流的子类对象 2. 调用read读取 3. 关闭资源 * read()执行一次, 自动读取下一个字节,返回值返回的是读取到的字节 当读取到文件结尾时, 返回值为 -1 * 注意一个点: fis.read()读的是字节,为啥返回int类型: 因为读到结尾返回-1, -1是两个字节, 一个字节接收不了,所以使用int接收, 自动补齐32位 12345678910111213141516171819202122public static void main(String[] args) throws IOException &#123; //创建InputStream的实现类对象 FileInputStream fis = new FileInputStream("a.txt"); //定义len变量, 接收读到的字符 int len = 0; //循环调用读方法 while((len = fis.read()) != -1)&#123; //len直接打印,会查ASCII,将字符转成ASCII值进行打印,所以要进行强转 //如果文件中是0,不强转,打印的是48 System.out.print((char)len); &#125; //while循环的一种错误写法: /* * 错误原因是: 每次执行fis.read(),都会读取到下一个字符,两次fis.read()读到的内容不一样 * 和迭代器的next()道理类似 * while(fis.read() != -1)&#123; * System.out.print(fis.read()); * &#125; */ //关闭流对象 fis.close();&#125; 字节输入流FileInputStream读取字节数组* 数组作用: 缓冲, 提高效率 * read返回的int, 表示什么含义: 读取到的有效字节数 * int read(byte[] b): 读取到字节数组 * int read(byte[] b, int off, int len): 读取到字节数组, off是开始读取的索引,len是读几个 123456789101112131415public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 FileInputStream fis = new FileInputStream("a.txt"); //定义变量,接收read()返回值 int len; //定义byte数组, 作为缓冲 byte[] b = new byte[2]; //循环读取, 判断条件使用的是int read(byte[] b),别忘传入b while((len = fis.read(b)) != -1)&#123; //使用String类的构造方法 String(byte[] b), 字节数组转成字符串 System.out.print(new String(b,0,len)); &#125; //关闭流对象 fis.close();&#125; 1234567891011121314151617181920将根目录下的a.txt的内容拷贝到b.txt中,考虑到可能复制的是大文件所以使用byte数组,作为缓冲,提高效率public static void main(String[] args) throws IOException&#123; //创建字节输入流对象 FileInputStream fis = new FileInputStream("a.txt"); //创建字节输出流对象 FileOutputStream fos = new FileOutputStream("b.txt"); //创建变量接收读的值 int len = 0; //创建byte数组,做缓冲, 作为参数传入read方法中 byte[] b = new byte[1024]; //循环读入a.txt中的内容,并写入b.txt while((len = fis.read(b)) != -1)&#123; fos.write(b,0,len); &#125; //释放资源 fis.close(); fos.close(); System.out.println("拷贝完毕!");&#125; 字节流复制文件读取* 字节输入流, 绑定数据源 * 字节输出流, 绑定数据目的 * 抛运行异常的原因是让程序停止.抛编译异常的话,异常后面的代码还会执行 * 可用于图片加密: 添加异或, 因为一个数异或一个数两次,还等于本身,可用于加密,解密 * 如fos.write(len ^ 123) 123456789101112131415161718192021222324252627282930313233343536读一个字节,写一个字节public static void main(String[] args) &#123; //定义两个流对象的变量 FileInputStream fis = null; FileOutputStream fos = null; try&#123; //new两个对象 fis = new FileInputStream("a.txt"); //绑定数据源 fos = new FileOutputStream("c.txt"); //绑定数据目的 //定义变量接收read()返回值 int len = 0; //循环读取并写入 while((len = fis.read()) != -1)&#123; fos.write((char)len); &#125; &#125;catch(IOException ex)&#123; ex.printStackTrace(); throw new RuntimeException("文件复制失败"); &#125;finally&#123; try&#123; if (fos != null) &#123; fos.close(); &#125; &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125;finally&#123; try&#123; if (fis != null) &#123; fis.close(); &#125; &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940采用数组缓冲,提高效率读字节数组, 写字节数组public static void main(String[] args) &#123; //定义两个流对象的变量 FileInputStream fis = null; FileOutputStream fos = null; try&#123; //new两个对象 fis = new FileInputStream("a.txt"); //绑定数据源 fos = new FileOutputStream("d.txt"); //绑定数据目的 //定义变量接收read()返回值 int len = 0; //len为每次读取的有效字节个数 //定义数组, 作为缓冲 byte[] bytes = new byte[1024]; //循环读取并写入, 读数组,写数组 while((len = fis.read(bytes)) != -1)&#123; fos.write(bytes,0,len); &#125; &#125;catch(IOException ex)&#123; ex.printStackTrace(); throw new RuntimeException("文件复制失败"); &#125;finally&#123; try&#123; if (fos != null) &#123; fos.close(); &#125; &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125;finally&#123; try&#123; if (fis != null) &#123; fis.close(); &#125; &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125; &#125; &#125; System.out.println("复制结束");&#125; 字符流字符输出流* java.io.Writer 所有字符输出流的父类 * 只能写文本文件,文本文件就是能用记事本打开看的懂的文件 方法1. write(int c): 写一个字符 2. write(char[] c): 写字符数组 3. write(char[] c, int off, int len): 字符数组一部分 4. write(String s): 写入字符串 FileWriter类* Writer的子类 * 构造方法: 绑定数据目的,注意是文件路径,不是文件夹路径,如果文件路径不存在,自动创建,存在则覆盖 * File 类型对象 * String 文件名 * 字符输出流写数据的时候, 必须要运行一个刷新功能flush() * 建议write一次,flush一次, 最后close 字符输入流* java.io.Reader 所有字符输入流的父类 * 只能读文本文件 * 不能读字符串 方法1. int read(): 读取一个字符 2. int read(char[] c): 读取一个字符数组 FileReader类* Reader的子类 * 构造方法: 绑定数据源 * File 类型对象 * String 文件名 12345678910111213141516171819202122232425262728293031323334353637383940字符流完成文本文件复制public static void main(String[] args) &#123; // 创建字符流对象 FileReader fr = null; FileWriter fw = null; try &#123; // new字符流对象 fr = new FileReader("a.txt"); // 绑定数据源 fw = new FileWriter("e.txt"); // 绑定数据目的 // 定义变量,接收read返回值 int len = 0; // 定义字符数组,做缓冲 char[] cBuff = new char[1024]; // 2KB // 循环读写 while ((len = fr.read(cBuff)) != -1) &#123; fw.write(cBuff, 0, len); // 记住,写完要刷新 fw.flush(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); throw new RuntimeException("复制失败"); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException ex) &#123; throw new RuntimeException("释放资源失败"); &#125; finally &#123; try &#123; if (fr != null) &#123; fr.close(); &#125; &#125; catch (IOException ex) &#123; throw new RuntimeException("释放资源失败"); &#125; &#125; &#125;&#125; 转换流字符转字节的过程* java.io.OutputStreamWriter 继承Writer类 * OutputStreamWriter的子类是FileWriter, 本质就是一个字符输出流, 操作字节输出流,写文本文件 * 字符流通向字节流的桥梁, 将字符流转成字节流 * 主要作用: 把java程序中写好的字符流转成可选的编码表对应的字节流, 然后通过字节输出流写入到文件中 * GBK中一个汉字2个字节, UTF-8中一个汉字3个字节 构造方法1. OutputStreamWriter(OutputStream out): 接收字节输出流 字节输出流: FileOutpuStream 2. OutputStreamWriter(OutputStream out, String charsetName): 接收字节输出流,转成对应编码的字节流输出流,再写入到数据目的 charsetName : 编码表名(不区分大小写) 可写的: GBK, UTF-8 使用GBK的话, 不用在参数中传递GBK, 因为默认GBK 12345678910111213141516171819202122232425public static void main(String[] args) throws IOException&#123; getGBK(); getUTF8();&#125;public static void getGBK() throws IOException&#123; //创建字节输出流 FileOutputStream fos = new FileOutputStream("D:\\gbk.txt"); //创建转换流对象, 包装字节输出流 OutputStreamWriter osw = new OutputStreamWriter(fos, "GBK"); //写 osw.write("你好"); //关 osw.close();//关闭转换流对象,字节输出流对象也跟着关闭了&#125;public static void getUTF8() throws IOException&#123;//创建字节输出流, 如果绑定数据目的是"UTF-8.txt",在eclipse中打开,还会乱码//因为即使用UTF-8写进UTF-8.txt,但eclipse默认使用的是GBK码表,还会将UTF-8转成GBK,不在eclipse中打开就行 FileOutputStream fos = new FileOutputStream("D:\\UTF-8.txt"); //创建转换流对象 OutputStreamWriter osw = new OutputStreamWriter(fos, "UTF-8"); //写 osw.write("你好"); //关 osw.close();&#125; 字节转字符的过程* java.io.InputStreamReader ,继承Reader * InputStreamReader的子类是FileReader, 本质就是一个字符输入流, 操作字节 * 字节流通向字符流的桥梁, 将字节流转成字符流 * 读取的方法: read() : 读取一个字符,也可以读取一个字符数组 构造方法1. InputStreamReader(InputStream in) 2. InputStreamReader(InputStream in, String charsetName) 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws IOException &#123; //readGBK() ; //如果要读取一个GBK编码的文件,使用子类字符输入流FileReader或者字节输入流FileInputStream即可,无需指定编码表 readUTF8(); //当需要读取一个UTF-8编码的文件时,需要使用转换流,指定转换后的字符流是UTF-8的格式&#125;public static void readGBK() throws IOException&#123; //创建字节输入流 FileInputStream fis = new FileInputStream("D:\\gbk.txt"); //创建转换流对象,包装字节输入流 InputStreamReader isr = new InputStreamReader(fis, "GBK"); //创建char[], 作为缓冲 char[] c = new char[1024]; int len = 0; while((len = isr.read(c)) != -1)&#123; System.out.println(new String(c,0,len)); &#125; //关闭流对象 isr.close();&#125;public static void readUTF8() throws IOException&#123; //创建字节输入流 FileInputStream fis = new FileInputStream("D:\\UTF-8.txt"); //创建转换流对象,包装字节输入流 InputStreamReader isr = new InputStreamReader(fis, "UTF-8"); //创建char[], 作为缓冲 char[] c = new char[1024]; int len = 0; while((len = isr.read(c)) != -1)&#123; System.out.println(new String(c,0,len)); &#125; //关闭流对象 isr.close();&#125; 转换流和子类区别* 继承关系 OutputStreamWriter |--FileWriter InputStreamReader |--FileReader * 区别: * 当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。 * 以下三句话功能相同 1. InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));//默认字符集。 2. InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;GBK&quot;);//指定GBK字符集。 3. FileReader fr = new FileReader(&quot;a.txt&quot;); * 使用场景: 1. 向数据目的中写入UTF-8格式的内容时, 需要用到OutputStreamWriter(OutputStream,&quot;UTF-8&quot;) 2. 从数据源中读取UTF-8格式的内容时, 需要用到InputStreamReader(InputStream,&quot;UTF-8&quot;) * 应用: 1. 向一个文件中写入GBK格式的内容,读这个GBK格式的文件,生成内容与GBK格式相同的UTF-8格式的文件 步骤: 1. 写入GBK格式的内容: * FileWriter fw = new FileWriter(&quot;d:\\a.txt&quot;); * 或OuputStreamWriter osw = new OuputStreamWriter(new FileOutputStream(&quot;d:\\a.txt&quot;),&quot;GBK&quot;); * 或OuputStreamWriter osw = new OuputStreamWriter(new FileOutputStream(&quot;d:\\a.txt&quot;)); 2. 读GBK格式的内容: * FileReader fr = new FileReader(&quot;d:\\a.txt&quot;); * 或InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;d:\\a.txt&quot;),&quot;GBK&quot;); * 或InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;d:\\a.txt&quot;)); 3. 写入UTF-8格式: * OuputStreamWriter osw = new OuputStreamWriter(new FileOutputStream(&quot;d:\\b.txt&quot;),&quot;UTF-8&quot;); * 记住一句话: 什么格式的内容, 就是什么格式来读, 要写入什么格式, 就用什么格式来写 缓冲流* 提高IO流读写速度 * 分为字节缓冲流和字符缓冲流 * 装饰设计模式 字节缓冲流1. 字节输出缓冲流 * java.io.BufferedOutputStream * 继承自OutputStream * 作用: 提高原有输出流的写入效率 * 方法: write() 字节或字节数组 * 先写入底层输出缓冲流,一定量后,再一起写入 * 构造方法: 1. BufferedOutputStream(OutputStream out) : 可以传递任意的字节输出流, 传递的是哪个字节流,就对哪个字节流提高效率 2. 字节输入缓冲流 * java.io.BufferedInputStream * 继承自InputStream * 方法: read() 字节或字节数组 * 构造方法: 1. BufferedInputStream(InputtStream out) 可以传递任意的字节输入流, 传递的是哪个字节流,就对哪个字节流提高效率 1234567891011121314151617181920字节输出缓冲流public class BufferedOutputStreamDemo &#123; public static void main(String[] args)throws IOException &#123; //创建字节输出流,绑定文件 //FileOutputStream fos = new FileOutputStream("c:\\buffer.txt"); //创建字节输出流缓冲流的对象,构造方法中,传递字节输出流 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("c:\\buffer.txt")); bos.write(55); byte[] bytes = "HelloWorld".getBytes(); bos.write(bytes); bos.write(bytes, 3, 2); bos.close(); &#125;&#125; 1234567891011121314字节输入缓冲流public class BufferedInputStreamDemo &#123; public static void main(String[] args) throws IOException&#123; //创建字节输入流的缓冲流对象,构造方法中包装字节输入流,包装文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("c:\\buffer.txt")); byte[] bytes = new byte[10]; int len = 0 ; while((len = bis.read(bytes))!=-1)&#123; System.out.print(new String(bytes,0,len)); &#125; bis.close(); &#125;&#125; 四种文件复制效率分析* 推荐使用第二种和第四种 字节流读写单个字节12345678910public static void copy_1(File src,File desc) throws IOException&#123; FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(desc); int len = 0; while((len = fis.read()) != -1)&#123; fos.write(len); &#125; fos.close(); fis.close();&#125; 字节流读写字节数组1234567891011public static void copy_2(File src,File desc) throws IOException&#123; FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(desc); byte[] b = new byte[1024]; int len = 0; while((len = fis.read(b)) != -1)&#123; fos.write(b, 0, len); &#125; fos.close(); fis.close();&#125; 字节流缓冲区流读写单个字节12345678910public static void copy_3(File src,File desc) throws IOException&#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc)); int len = 0; while((len = bis.read()) != -1)&#123; bos.write(len); &#125; bos.close(); bis.close();&#125; 字节流缓冲区流读写字节数组1234567891011public static void copy_4(File src,File desc) throws IOException&#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc)); int len = 0; byte[] b = new byte[1024]; while((len = bis.read(b)) != -1)&#123; bos.write(b,0,len); &#125; bos.close(); bis.close();&#125; 字符缓冲流1. 字符输出缓冲流 * BufferedWriter, 继承自Writer * 方法: write() : 单个字符, 字符数组, 字符串 * 构造方法: 1. BufferedWriter(Writer w): 传递任意字符输出流 传递谁,就高效谁 能传递的字符输出流: FileWriter,OutputStreamWriter * BufferedWriter特有方法: newLine(): 实现换行,功能与\r\n一样,区别是这个方法可以跨平台 2. 字符缓冲输入流 * BufferedReader, 继承自Reader * 有一个子类LineNumberReader, 可以读行号 * 方法: read() 单个字符, 字符数组 * 特有方法: String readLine(): 可以读取文本的一行, 返回值是String,读取到末尾,返回null * 构造方法: 1. BufferedReader(Reader r) 能传递的字符输入流: FileReader,InputStreamReader 1234567891011121314151617181920字符输出缓冲流public static void main(String[] args) throws IOException &#123; //创建字符输出流 FileWriter fw = new FileWriter("D:\\a.txt"); //创建字符输出缓冲流, 传入字符输出流,包装数据目的 BufferedWriter bfw = new BufferedWriter(fw); bfw.write(97); bfw.newLine(); bfw.flush(); bfw.write("你好".toCharArray()); nfw.newLine(); bfw.flush(); bfw.write("大家好"); bfw.flush(); bfw.close();&#125; 123456789101112131415161718字符输入缓冲流public static void main(String[] args) throws IOException &#123; //定义计数变量作为行号 int lineNumber = 0; //创建字符输入流 FileReader fr = new FileReader("D:\\a.txt"); //创建字符输入缓冲流,传递字符输入流,包装数据源 BufferedReader bfr = new BufferedReader(fr); //定义String类型变量, 接收readLine()返回值 String line = null; //循环读取 while((line = bfr.readLine()) != null)&#123; lineNumber++; System.out.println(lineNumber+" "+line); &#125; //关闭缓冲流对象 bfr.close();&#125; 使用字符缓冲流对象,复制文本文件123456789101112131415161718192021注意: 1.生成的b.txt会比a.txt大两个字节,因为写入最后一行后,又nextLine()了2.注意这种读写方式,读一行,写一行,加一个换行,加一个刷新public static void main(String[] args) throws IOException &#123; //创建字符输入缓冲流对象 BufferedReader bfr = new BufferedReader(new FileReader("D:\\a.txt")); //创建字符输出缓冲流对象 BufferedWriter bfw = new BufferedWriter(new FileWriter("D:\\b.txt")); //创建String类型变量接收readLine()返回值 String line = null; //循环读, 读一行, 写一行, 加一个换行 while((line = bfr.readLine()) != null)&#123; bfw.write(line); bfw.newLine(); //刷新 bfw.flush(); &#125; //关闭流对象 bfw.close(); bfr.close();&#125; IO流对象的操作规律IO流相关类继承关系1. 字节流抽象父类: 输入流: InputStream: |-- FileInputStream(字节输入流的子类) |- read(int len) : 读取单个字节 |- read(byte[] b): 读取字节数组 |-- BufferedInputStream(InputStream in) 输出流: OutputStream: |-- FileOutputStream(字节输出流的子类) |- write(int len) : 写出单个字节 |- write(byte[] b): 写出字节数组 |- write(byte[] b,int off,int len): 写出字节数组的一部分 |-- BufferedOutputStream(OutputStream ou) 2. 字符流抽象父类 输入流: Reader: |-- InputStreamReader(将字节转成字符) |-- FileReader(字符输入流的子类) |- read(char c) : 读取单个字符 |- read(char[] ch): 读取字符数组 |-- BufferedReader(Reader r) |- readLine() : 读取一整行 输出流: Writer: |-- OutputStreamWriter(将字符转成字节) |-- FileWriter(字符输出流的子类) |- write(char c) : 写出单个字符 |- write(char[] ch): 写出字符数组 |- write(String str): 写出字符串 |-- BufferedWriter(Writer w) |- newLine() : 写出一个换行 对象操作流： |-- ObjectInputStream(对象输入流) |- readObject(); 对象必须实现序列化接口 |-- ObjectOutputStream(对象输出流) |- writeObject(Object obj) 打印流： PrintWriter:（流对象,boolean b） 如果是true、自动刷新 1.可以自动刷新 2.只能输出 3.println()(原样输出、并且自带换行) print() printf() 操作规律1. 如果操作的是纯文本文件, 直接使用带缓冲的字符流即可! 读一行,写一行 2. 如果操作的是所有文件,直接使用待缓冲的字节流即可! 带上小数组 3. 如果需要编码转换, 直接使用转换流即可! Properties集合类特点* HashTable的子类, 实现Map接口 * 集合都是临时存储, 但Properties可以与IO对象结合使用,实现持久化存储 * 没有泛型(不能写泛型), 键值对都是字符串 存储键值对* 特有方法: 1. setProperty(String key, String value): 功能等同于Map中的put 2. getProperty(String key): 通过键获取值, 功能等同于Map中的get(index) 3. StringPropertyNames(): 将集合的键存储到Set集合, 类似与keySet 12345678910111213Properties pro = new Properties();pro.setProperty("a", "1");pro.setProperty("b", "2");pro.setProperty("c", "3"); System.out.println(pro.getProperty("a")); //1System.out.println(pro.getProperty("b")); //2System.out.println(pro.getProperty("c")); //3System.out.println(pro.getProperty("d")); //null//遍历Set&lt;String&gt; keySet = pro.stringPropertyNames();for (String key : keySet) &#123; System.out.println(key+"..."+pro.getProperty(key));//存取无序&#125; 特有方法load1. load(InputStream in) 2. load(Reader r) * 传递任意的字节或字符输入流 * 作用: 读取文件中的键值对到集合 * Properties并不是只能读.properties配置文件,.txt等文本也可以读,只是通常而已 * .properties代表键值对格式存储的文件 12345678注意config.properties中写键值的时候,键和值后不要加空格或分号,否则就成为键或值的一部分了private static void function_2() throws IOException &#123; Properties pro = new Properties(); FileReader fr = new FileReader("config.properties"); pro.load(fr); fr.close(); System.out.println(pro);&#125; store1. store(OutputStream o, String comments) 2. store(Writer w, String comments) * 接收所有的字节或字符输出流 * 作用: 将集合中的键值对写到文件 * String类型的comments写的是: 写回文件的原因,可以写&quot;&quot;,或者英文形式,如&quot;abc&quot; 123456789private static void function_3() throws IOException &#123; Properties pro = new Properties(); pro.setProperty("name", "geekhoon"); pro.setProperty("age", "11"); pro.setProperty("blog", "www.geekhoon.com"); FileWriter fw = new FileWriter("config.properties"); pro.store(fw, "just a test");//后面写原因,可以写"" fw.close();&#125; 对象操作流对象的序列化与反序列化* 序列化: 对象中的数据,以流的形式,写入到文件中保存 * 反序列化: 在文件中,以流的形式,将对象读取出来 ObjectOutputStream流写对象* 将对象数据写到文件中, 实现序列化 * 构造方法: * ObjectOutputStream(OutputStream out),传递任意的字节输出流 * 方法: * void writeObject(Object obj): 写出对象的方法 123456789101112131415161718对象类,要实现Serializable接口public class Person implements Serializable &#123; private String name; private int age; 构造方法; get/set; toString();&#125;private static void writeObject() throws IOException &#123; //创建字节输出流,封装文件 FileOutputStream fos = new FileOutputStream("d:\\person.txt"); //创建序列化流的对象,构造方法传递字节输出流 ObjectOutputStream oos = new ObjectOutputStream(fos); Person p = new Person("张三",11); //调用序列化流的方法writeObject,写出对象 oos.writeObject(p); oos.close();&#125; ObjectInputStream流读取对象* 从文件中读取对象数据, 实现反序列化 * 构造方法: * ObjectInputStream(InputStream in), 传递任意的字节输入流 * 注意: 字节输入流封装的文件,必须是序列化的文件 * 方法: * Object readObject(): 读取对象 123456789private static void readObject() throws IOException, ClassNotFoundException &#123; FileInputStream fis = new FileInputStream("d:\\person.txt"); //创建反序列化流的对象,构造方法传递字节输入流 ObjectInputStream ois = new ObjectInputStream(fis); //调用反序列化的方法readObject(),读取对象 Object obj = ois.readObject();//readObject()要抛ClassNotFoundException这个异常 System.out.println(obj); //打印Person [name=张三, age=11] ois.close();&#125; 静态不能序列化* 被static修饰的成员变量,属于类 * 非静态成员变量才属于对象 * 对象序列化和反序列化操作的是对象, 静态变量不能序列化 * 如: private static int age; * readObject()打印的结果就是Person [name=张三, age=0] transient关键字* 不能写成静态变量, 也不想被序列化, 需要使用transient关键字 * 作用: 阻止成员变量序列化 * 如: private transient int age; * readObject()打印的结果就是Person [name=张三, age=0] Serializable接口的含义* 接口中并没有方法 * 这种接口称为标记接口 * 实现标记接口的实现类, 才可以序列化 序列化中的序列号冲突问题* 序列化之后,还没进行反序列化,去把person类的内容进行了修改,再进行反序列化,会报错 序列化中自定义的序列号* (权限) static final long serialVersionUID = 1L; * 权限和值可以改,序列化之前可以改 * 类,自定义了序列号,编译器不会计算序列号 打印流概述* PrintStream类 * PrintWriter类 * 特点: 1. 此流不负责数据源, 只负责数据目的 2. 为其他输出流, 添加功能 3. 永远不会抛出IOException, 但是可能抛出其他异常 * 两个打印流的方法完全一致 * 区别在于构造方法,就是打印流的输出目的端 1. PrintStream: 构造方法,接收File对象,字节输出流OutputStream,字符串文件名 2. PrintWriter: 构造方法,接收File对象,字节输出流OutputStream,字符串文件名, 字符输出流Writer 打印流输出目的是File对象123456File file = new File("d:\\a.txt");//a.txt原来不存在的话,也可以被自动创建,但是在读的时候不可以PrintWriter pw = new PrintWriter(file);pw.println(100);//文件中打印出的的是100, 原样输出pw.write(100);//文件中打印的出的是d,会查码表pw.flush();pw.close(); 输出语句是char数组123字符串的本质是char[], String str = "abc";等同于char[] arr = &#123;'a','b','c'&#125;;char[] arr = &#123;'a','b','c'&#125;;System.out.println(arr); //打印的是abc, 而不是地址值 打印流输出目的是String文件名和流对象123456打印流,输出目的是字符串文件名public static void function_1() throws FileNotFoundException&#123; PrintWriter pw = new PrintWriter("d:\\1.txt");//文件可以自己创建 pw.println("你好"); pw.close();&#125; 123456789打印流,输出目的是流对象可以是字节输出流OutputStream, 也可以是字符输出流Writerpublic static void function_2() throws IOException&#123; //FileOutputStream fos = new FileOutputStream("d:\\3.txt");//文件可以自己创建 FileWriter fw = new FileWriter("d:\\4.txt");//文件可以自己创建 PrintWriter pw = new PrintWriter(fw); pw.print("abc"); pw.close();&#125; 打印流开启自动刷新* 需要满足两个条件: 1. 输出目的必须是流对象,OutputStream或Writer, 不可以是String类型文件名或File对象 2. 必须调用println,printf,format方法中的一个 3. PrintWriter(流对象,true);参数中要加上true 12345678FileOutputStream fos = new FileOutputStream("d:\\5.txt");PrintWriter pw = new PrintWriter(fos,true);//添加参数true, 可以实现自动刷新pw.println("a");pw.println("b");pw.println("c");//不需要刷新,现在运行,也可以在文件中打印abc//但流对象还是要关闭pw.close(); 打印流复制文本文件* 打印流只负责写 12345678910public static void function_3() throws IOException&#123; BufferedReader bfr = new BufferedReader(new FileReader("d:\\a.txt")); PrintWriter pw = new PrintWriter(new FileWriter("d:\\b.txt"),true); String line = ""; while((line = bfr.readLine()) != null)&#123; pw.println(line); &#125; pw.close(); bfr.close();&#125; 第三方jar包commons-io工具类FilenameUtils工具类* 常用方法: 1. static String getExtension(String filename): 获取文件扩展名 2. static String getName(String filename): 获取文件名 3. static boolean isExtension(String filename, String extension): 判断文件名的后缀是不是extension, 区分大小写 FileUtils工具类* 常用方法: 1. static String readFileToString(File file): 读取文件内容，并返回一个String 2. static void writeStringToFile(File file，String content): 将内容content写入到file中 3. static void copyDirectoryToDirectory(File srcDir,File destDir): 文件夹复制 4. static void copyFile(File srcFile,File destFile): 文件复制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[异常]]></title>
      <url>%2F2017%2F02%2F18%2F15-%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[异常继承体系* Throwable类是所有错误,异常的超类 | - Error : 错误, Throwable的子类 | - Exception : 异常, Throwable的子类 |-RuntimeException : 运行期异常, JAVA程序运行过程中出现的问题, Exception的子类 |-非RuntimeException : 编译期异常，必须处理的，否则程序编译不通过, Exception的子类 * 异常与错误的区别 1. 异常: * 异常指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。 * 若不处理异常，程序将会结束运行。 2. 错误: * 指程序在运行期间发生了某种错误，Error错误通常没有具体的处理方式，程序将会结束运行。 * Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。 * 我们无法针对处理，只能修正代码 异常处理方式1. JVM的默认处理方式 * 把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。 * 一旦有异常发生，其后来的代码不能继续执行。 2. 解决程序中异常的手动方式 * 编写处理代码 try...catch...finally 自己编写处理代码,后面的程序可以继续执行 * 抛出 throws 把自己处理不了的，在方法上声明，告诉调用者，这里有问题 异常中关键字抛出异常对象 throw* 在方法内部,抛出异常 * 用来抛出一个指定的异常对象, * 以抛出异常的方式,告诉调用者main,(如果是main方法调用的话) * throw 后面, 必须写new 对象,必须是异常的对象,只能写一个对象 方法中声明异常关键字 throws* 在方法声明上, 表明此方法,可能出现异常 * throws 后面, 必须写异常类的类名,可以写多个异常类名 * 格式: 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… { } * 当调用了一个抛出异常的方法,调用者就必须处理, 不处理,编译失败 面试题1. 编译期异常和运行期异常的区别 编译期异常 必须要处理的，否则编译不通过 运行期异常 可以不处理，也可以处理 2. throw,throws区别 throw: 在方法体中,后面跟的是异常对象名,并且只能是一个 throw抛出的是一个异常对象，说明这里肯定有一个异常产生了 throws: 在方法声明上,后面跟的是异常的类名,可以是多个 throws是声明方法有异常，是一种可能性，这个异常并不一定会产生 try..catch异常处理* 格式: try{ 被检测代码 }catch (异常类名1 变量){ 异常处理方式 }catch (异常类名2 变量){ ... }catch ... }finally{ 必须要执行的代码 } * 注意: 如果出现了上下级关系的异常, 越高级越要写在catch下面 * finally,无论程序是否有异常出现,程序必须执行释放资源 如：IO流操作和数据库操作中会见到 * finally：是try-catch的一部分！被它修饰的代码一定会被执行到！除非在这之前退出了虚拟机 System.exit(0); * 方法中, 在catch语句中有return, return语句在finally之前执行, 还是之后执行? return , 先建立了一个返回的链接, 先检测一下, 如果有finally, 那么执行完finally代码块后, 继续返回 运行时期异常处理* 编译异常: 调用了抛出异常的方法, 不处理编译失败 (try throws) * 运行异常: 抛出的异常是RuntimeException类, 或者它的子类, 除此之外,都是编译异常 * throws Exception : 抛的是编译异常 * throws NullPointerException : 抛的是运行异常 * 运行异常的特点: * 方法中抛出运行异常,方法定义中无需throws声明,调用者也无需处理此异常。 * 运行异常一旦发生,后面的代码没有执行的意义,需要程序人员修改源代码 * 设计原因: (不写throws, 调用者也不用处理) * 运行异常, 不能发生, 但是如果发生, 程序人员停止程序, 修改源代码 方法重写时异常的处理* 继承后, 在子类重写父类方法的时候, 异常处理 * 结论: 1.父类的方法如果抛出异常, 子类重写后, 1. 可以不抛出异常 2. 也可以抛出异常, 但是抛的异常不能大于父类的异常(异常的继承关系) 如果抛同级异常, 只能和父类抛的异常一模一样 2.父类的方法如果不抛出异常, 子类重写后, 也不能抛出异常 如果子类重写的方法调用了抛出编译异常(注意,如果调用了抛运行异常的方法,不会出问题)的方法, 只能try/catch处理, 子类重写的方法不可以向外抛异常 Throwable类常用方法* 都和异常的信息有关系 1. String getMessage() : 对异常信息的详细描述 2. String toString() : 对异常信息的简短描述 3. void printStackTrace(): 将异常信息追踪到标准的错误流 自定义异常* 步骤: 1. 继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可, 一般写运行异常 2. 构造方法中, super将异常信息传递给父类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F02%2F11%2F14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[概念* 操作字符串数据的规则表达式 语法规则注意: 一个[ ]代表一个字符 * 字符 * x 代表的是 字符x * \\ 代表的是 反斜线字符&apos;\&apos; * \t 代表的是 制表符 * \n 代表的是 换行符 * \r 代表的是 回车符 * \s 代表的是 空格 * 字符类 * [abc] a、b 或 c 范围中的一个 * [^abc] 任何字符，除了 a、b 或 c * [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） * [0-9] 0到9的字符都包括 * [^0-9] 不是数字 * [a-zA-Z_0-9] 代表的字母或者数字或者下划线 * 预定义字符类 * . 任何字符 * \d 数字：[0-9] * \D 不是数字 * \w 单词字符：[a-zA-Z_0-9] * 边界匹配器 * ^ 代表的是行的开头 * $ 代表的是行的结尾 * \b 代表的是单词边界 * 数量词 * X? X，一次或一次也没有 * X* X，零次或多次 * X+ X，一次或多次 * X{n} X，恰好 n 次 * X{n,} X，至少 n 次 * X{n,m} X，至少 n 次，但是不超过 m 次 正则表达式和String类相关的方法1.匹配。 使用的是String类中的matchers方法。 boolean matches(String 正则表达式) 如boolean b = &quot;abc&quot;.matches(&quot;[a]&quot;); //返回false, 因为abc为三个字符,正则只有a一个,改成&quot;[abc]+&quot;返回true 2.切割。 使用的是String类中的split方法。 String[] split(String 正则表达式) 如String[] strArr = &quot;abc&quot;.split(&quot;a&quot;); 注意: 1. 返回值类型是String类型的数组 2. 如果用原字符串中没有的字符来切, 切割后数组长度为1 3. 切割符是&quot;.&quot;的时候, 要转义,用&quot;\\.&quot; 两个反斜杠的原因: 第一个是java中先转义 第二个是正则中转义 4. 切割符是&quot; &quot;的时候, 要转义,用&quot;\\s&quot;,或者&quot; +&quot; 3.替换。 使用的是String类中的replaceAll方法。 String replaceAll( String 正则表达式,String 字符串) 如String str = &quot;abc0123&quot;.repalceAll(&quot;[\\d]&quot;,&quot;#&quot;); //打印abc#### 若要打印成abc# ,将正则表达式改为&quot;[\\d]+&quot; 练习1.QQ号正则表达式, 要求:全数字,0不能开头,5-10位 1QQ.matches("[1-9][\\d]&#123;4,9&#125;"); 2.要求: 输入aaa_bbbb_ccc_ddd,输出AaaBbbbCccDdd 123456789101112131415161718192021public class RegexDemo &#123; public static void main(String[] args) &#123; String str = "aaa_bbbb_ccc_ddd"; change(str); &#125; public static void change(String str)&#123; String[] strArr = str.split("_"); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; strArr.length; i++) &#123; String word = strArr[i]; sb.append(wordLowerToUpper(word)); &#125; System.out.println(sb.toString()); &#125; public static String wordLowerToUpper(String word)&#123; String first = word.charAt(0)+""; first = first.toUpperCase(); String other = word.substring(1); return first + other; &#125;&#125; 3.简式邮箱格式正则表达式 1234567891011public class Email_Test &#123; public static void main(String[] args) &#123; String str = "fsd1111fdsfsddsdsad22@2.com.cn"; email_judge(str); &#125; public static void email_judge(String str)&#123; //.com.cn .字母 可以有多个 boolean b = str.matches("[\\w]+@[a-z0-9]+(\\.[a-z]+)+"); System.out.println(b); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[API]]></title>
      <url>%2F2017%2F02%2F10%2F13-API%2F</url>
      <content type="text"><![CDATA[API概念* API(Application Programming Interface) 应用程序编程接口 * Java API Java jdk给我们提供好的类 Object类* 所有类的父类 * 常用方法 * boolean equals(Object obj){} 比较两个对象的地址值是否一致 * String toString() 返回对象的地址值。(对象调用toString()默认不用写,自动调用) 我们一般会在子类中重写toString方法来返回对象的内容 String类* 特点: 1. 字符串是一个常量,一旦创建,不可改变 如String str = &quot;abc&quot; 不变指的是&quot; &quot;内的值不变,不是str的值不可变 2. 所有的 &quot;&quot; 都是String类的对象 * 注意: 1. 只有显示定义的字符串才会存在于常量池中 * JDK1.6及以前, 常量池位于方法区 * JDK1.7之后, 常量池位于堆中 2. 源码分析,String类底层采用的是字符数组 字符串的本质是一个char数组, 字符串以字符形式存储于常量池中 * String类创建方式和比较 1. String s1 = &quot;abc&quot;; 在内存中只有一个对象。这个对象在字符串常量池中 2. String s2 = new String(&quot;abc&quot;); 在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象，在字符串常量池中 * String类常见构造方法 1. public String():空构造 2. public String(byte[] bytes):把字节数组转成字符串 3. public String(byte[] bytes,int offset,int length):把字节数组的一部分转成字符串 4. public String(char[] value):把字符数组转成字符串 5. public String(char[] value,int offset,int count):把字符数组的一部分转成字符串 6. public String(String original):把字符串常量值转成字符串 注意: 1. 2和3中,将字节数组转成字符串,会通过使用机器操作系统的默认编码表(GBK)解码byte数组,构造新的String Java语言使用的就是unicode(字符串用GBK，字符用unicode码表) 12345678910byte[] bytes = &#123;97,98,-99,-100,-112&#125;;//调用String类的构造方法,传递字节数组String s = new String(bytes);System.out.println(s); //打印结果为 ab潨?//汉字的字节编码就是负数, 两个负数代表一个汉字, 多一个负数,会打出?byte[] bytes1 =&#123;65,66,67,68,69&#125;;//调用String构造方法,传递数组,传递2个int值,offset代表数组的起始的索引,length代表转的个数String s1 = new String(bytes1,1,3);System.out.println(s1); 2. 4和5中,把字符数组转成字符串,如果是字符型数据,不查询编码表 1234567char[] c = &#123;97,'8','c','d','e','f'&#125;;//调用String构造方法,传递字符数组String s = new String(c);System.out.println(s);//打印a8cdef ,97会查编码表ASCii String s1 = new String(c,1,4);System.out.println(s1);//打印8cde * String的常用判断方法 1. boolean equals(Object obj):比较字符串的内容是否相同,区分大小写 2. boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 3. boolean contains(String str):判断大字符串中是否包含小字符串 4. boolean startsWith(String str):判断字符串是否以某个指定的字符串开头 5. boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾 6. boolean isEmpty():判断字符串是否为空。 * String类的获取功能 1. int length():获取字符串的长度。 2. char charAt(int index):获取指定索引位置的字符 3. int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。被查找的字符不存在,返回-1 4. int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 5. String substring(int start):从指定位置开始截取字符串,默认到末尾。 6. String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。(包含头，不包含尾) 7. char[] toCharArray() 将字符串转成字符数组 8. byte[] getBytes() 将字符串转成字节数组 (byte数组相关的功能,查询编码表) 9. String toUpperCase();转成大写 10. String toLowerCase();转成小写 11. static String valueOf(char[] data) : 将字符数组,转成String类型 * String的替换功能 1. String replace(char old,char new) 2. String replace(String old,String new) 3. String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 4. String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 注：如果要被替换字符或字符串在原字符串中不存在，则返回原字符串。 * 空串与null区别 * &quot;&quot;是字符串常量,同时也是一个String类的对象,既然是对象当然可以调用String类中的方法 * null是空常量,不能调用任何的方法,否则会出现空指针异常,null常量可以给任意的引用数据类型赋值 * 声明一个String str 如果说str是null，那么内存根本没有创建字符串对象，没有str引用。 如果说str是空串，那么确定存在一个由str引用的字符串对象，只不过这个字符串的值是空。 null用来表示没有实例存在，而“”本身就是一个实例，有自己的对象空间，和“123456”这样的字符串没有区别。 使用注意事项： 对象用equals比较，null用等号比较。因此，如果str1=null;下面的写法运行会有错误： if(str1.equals(&quot;&quot;)||str1==null){//当str1为null, str1.equals(&quot;&quot;)会报空指针异常 //。。。。 } 正确的写法是 if(str1==null||str1.equals(&quot;&quot;)){ //先判断是不是对象，如果不是， 不需要判断是不是空字符串 //... } StringBuffer类* 概述 * 字符串缓冲区 * 线程安全的可变字符序列 * 底层采用字符数组实现,初始容量为16 * StringBuffer和String的区别 * String是一个不可变的字符序列 * StringBuffer是一个可变的字符序列 其实字符串String的底层也是用StringBuffer来完成的。 比如：String str = &quot;abc&quot; + 4 + &apos;c&apos;; 这句话的底层其实就是： String str = new StringBuffer().append(&quot;abc&quot;).append(4).append(&apos;c&apos;).toString(); * StringBuffer和数组容器的区别？ 1. 数组容器是固定长度的。 StringBuffer是可变长度的。 2. 数组容器一旦初始化就明确了元素的类型。 StringBuffer可以存储任意类型。包括基本和引用。 3. 数组存储完元素可以对元素进行操作（通过角标）。 StringBuffer存储完元素后，都会变成字符串，只能用字符串的方法来操作。 * 特点 1. 缓冲区就是用来缓存数据，意味着它是一个容器。 2. 该容器的长度是可变的。 3. 提供了对容器中内容的操作的方法(最多无外乎四种：增删改查.) 4. 该缓冲区中可以添加多种类型的元素，基本类型和引用类型。 5. 无论怎么样的改变容器中的数据，最终要使用结果，还是必须要将其转成字符串，使用toString方法。 * 构造方法 1. public StringBuffer():无参构造方法 2. public StringBuffer(String str) :向StringBuffer对象中插入一个字符串 * 常用方法 1. StringBuffer append(), 将任意类型的数据,添加缓冲区 * 调用者是谁,返回值就是谁 2. delete(int start,int end): 删除缓冲区中字符 * 开始索引包含,结尾索引不包含 3. insert(int index, 任意类型): 将任意类型数据,插入到缓冲区的指定索引上 4. replace(int start,int end, String str): 将指定的索引范围内的所有字符,替换成新的字符串 5. reverse(): 将缓冲区中的字符反转 6. String toString(): 继承Object,重写toString() * 将缓冲区中的所有字符,变成字符串 StringBuilder类* StringBuffer和StringBuilder的区别 * StringBuffer是jdk1.0版本的,是线程安全的,效率低 * StringBuilder是jdk1.5版本的,是线程不安全的,效率高 Date* 日期类 * 毫秒值 * 获取当前日期的毫秒值 System.currentTimeMillis() 返回值long类型参数 * 时间原点: 公元1970年1月1日 00:00:00 * 日期对象之间要进行基本运算，需要转成具体的毫秒数值才可以 * Date类的构造方法 * 空参构造 public Date() :获取当期操作系统的日期,时间 * 带参构造 public Date(long times) :将传入的毫秒值转为对应的日期,时间 * Date类的get/set方法 * public long getTime() :将当前的日期对象，转为对应的毫秒值 * public void setTime(long times) :根据给定的毫秒值，生成对应的日期对象 * 日期格式化SimpleDateFormat * SimpleDateFormat继承自抽象类 DateFormat,使用父类普通方法,重写抽象方法 * 作用: 对日期进行格式化(自定义) * 对日期进行格式化的步骤: (Date对象 ==&gt; 字符串) 1: 创建SimpleDateFormat对象 在类构造方法中,写入字符串的日期格式 (自己定义) 2: SimpleDateFormat调用方法format对日期进行格式化 public String format(Date date) * 字符串转成日期对象步骤: (字符串 ==&gt; Date对象) 1: 创建SimpleDateFormat的对象 在类构造方法中,写入字符串的日期格式 (自己定义) 2: 子类对象,调用方法 parse 传递String,返回Date Date parse(String 日期模式) 注意传递的Stirng类型日期模式,要和1中定义的格式相同 * 日期模式: yyyy 年份 MM 月份 dd 月中的天数 HH 0-23小时 mm 小时中的分钟 ss 秒 * 练习: 1.计算出生至今活了多少天 12345678910111213141516171819202122232425public static void function() throws Exception &#123; System.out.println("请输入出生日期 格式 YYYY-MM-dd"); //获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); //将字符串日期,转成Date对象 //创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); //调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); //获取今天的日期对象 Date todayDate = new Date(); //将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long second = todaySecond-birthdaySecond; if(second &lt; 0)&#123; System.out.println("还没出生呢"); &#125; else&#123; System.out.println(second/1000/60/60/24); &#125;&#125; Calendar* 日历类(抽象类) * 创建对象: Calendar类中写了getInstance()静态方法,直接返回子类的对象,不用new子类对象 格式如: Calendar c = Calendar.getInstance(); * 常用方法: * get(日历字段): 获得指定日历字段的值 12345678Calendar c = Calendar.getInstance();// 获取年份int year = c.get(Calendar.YEAR);// 获取月份int month = c.get(Calendar.MONTH) + 1;// 获取天数int day = c.get(Calendar.DAY_OF_MONTH);System.out.println(year + "年" + month + "月" + day + "日"); * getTime() 把日历对象,转成Date日期对象 * set(int field,int value) 设置指定的时间 field 设置的是哪个日历字段 value 设置后的具体数值 * set(int year,int month,int day) 传递3个整数的年,月,日 12345Calendar c = Calendar.getInstance();// 设置,月份,设置到10月份// c.set(Calendar.MONTH, 9);// 设置年,月,日c.set(2017, 01, 01); * add(int field, int value) 进行整数的偏移 12// 让日历中的天数,向后偏移30天c.add(Calendar.DAY_OF_MONTH, 30); * 练习: 1.输入年份,判断是否为闰年 12345678910111213141516public static void judge()&#123; System.out.println("请输入一个年份: "); int year = new Scanner(System.in).nextInt(); Calendar c = Calendar.getInstance(); //把日期设置成输入年份,当年的3月1日 c.set(year, 2, 1); //利用偏移方法,前移一天,get二月的天数 c.add(Calendar.DAY_OF_MONTH, -1); //闰年29天 if(c.get(Calendar.DAY_OF_MONTH) == 29)&#123; System.out.println("闰年"); &#125;else&#123; //平年28天 System.out.println("平年"); &#125;&#125; 基本类型包装类* 可以将字符串转换成对应的基本数据类型 * 八种基本类型对应的包装类: char Character int Integer byte Byte short Short long Long float Float double Double boolean Boolean Integer* int对应的包装类 * 构造方法 Integer(String s) : 将数字格式的字符串作为参数 如: Integer i = new Integer(&quot;100&quot;); int num = i.intValue(); //intValue()方法返回值为int类型,以 int 类型返回该 Integer 的值 //后面哟用到自动装箱可以直接 Integer i = 100; * int与String之间互转方法 1. 字符串转为int (1)static int parseInt(String s) :要求s要是数字形式的字符串 static int valueof(string s) : 要求s要是数字形式的字符串 (2)static int parseINt(String s,int radix) : 将指定进制的字符串转成十进制的int类型 注意: parseInt方法的最后返回值都是十进制的int类型 如: radix为2 ,则将2进制的String s转成10进制的int 2. int转为字符串 (1)方式一: 添加空字符串 int i = 3; String str = i + &quot;&quot; ; (2)方式二: * static String toString(int i): 注意这个方法不是Object类中toString的重写,因为Object类在tOString是空参方法 * static String toString(int i,int radix): 将int类型的数据转成radix进制的数字形式的字符串 注意: Java中最高支持36进制, 0-9A-Z * 其他方法: * 两个静态成员变量: * MAX_VALUE : int范围最大值 * MIN_VALUE * 三个静态方法: 1. toBinarString(int) : 10进制--&gt;2进制 2. toOctalString(int) : 10进制--&gt;8进制 3. toHexString(int) : 10进制--&gt;16进制 三个方法的返回值都是String类型 自动装箱/自动拆箱* 概述 * 自动装箱: 基本数据类型,直接变成对象 * 自动拆箱: 对象中的数据,变回基本数据类型 * 举例: * 装箱: Integer i = 1; //这步的实际操作是 Integer i = new Integer(1); * 拆箱: i = i + 1; //实际操作是(1) i + 1 为 i.intValue() + 1; (2) i = 2; * 好处: 基本数据类型与引用类型可以直接计算 * 坏处: 有可能会抛空指针异常, 如 Integer i = null; i = i + 1; System.out.println(i);//会抛异常 Integer a1 = 500; Integer b1 = 500; System.out.println(a1==b1); //因为自动装箱实质上也new了一个Integer对象,所以a1和b1地址值不同,false System.out.println(a1.equals(b1)); //内容相同, 为true //数据在byte范围内,JVM不会重新new对象 Integer a2 = 127; //Integer a2 = new Integer(127); Integer b2 = 127; //Integer b2 = a2; System.out.println(a2==b2); //a2, b2指向的是同一个对象,地址相同 System.out.println(a2.equals(b2)); //内容相同,true Integer i1 = 60; Integer i2 = 60; Integer i3 = 60 + 60; Integer i4 = i1 + i2; System.out.println(i3 == i4); //这个我判断错了, 答案是true //因为i3 = 120, 在byte范围内, i4也=120 ,不会重新new对象 ,所以它们地址相同 String s1 = "he"; String s2 = "llo"; String s3 = "he" + "llo"; String s4 = s1 + s2; System.out.println(s3 == s4); //比较的是地址, false byte b1 = 60; byte b2 = 60; byte b3 = 60 + 60; int b4 = (byte) (b1 + b2); System.out.println(b3 == b4); //比较的是值, true Byte by1 = 60; Byte by2 = 60; Byte by3 = 60 + 60; int by4 = by1 + by2; System.out.println(by3 == by4); //这个我判断错了,比较的不是地址, 因为by4是int类型 //Byte by3 有个自动拆箱 即 byte by3 //基本数据类型比较 比较的就是值的大小 //结果是true System类* 概述 * 不能new, 因为构造方法是private的 * 全是静态方法 * 常用方法 1. static long currentMillis() : 获得当前时间毫秒值 2. static void exit(int status) : 退出JVM,所有程序停止 status传0 ,程序正常退出 status传非0 ,程序异常时退出 3. static void gc() : 调用垃圾回收器,但不能100%回收 对象在被回收前,会调用对象的finalize方法,且只会执行一次 4. static Properties getProperties() : 获取JVM和当前操作系统的属性 5. static void arrayCopy(Object src, int srcPos, Object dest, int destPos, int length) 复制一个数组 src : 要复制的源数组 srcPos : 源数组的起始索引 dest : 复制后的目标数组 destPos : 目标数组起始索引 length : 拷贝长度 Math类* 概述 * 数学计算工具类 * java.lang.Math * 全是静态方法 * 常用方法 1. static int abs(int i) : 获取绝对值 2. static double ceil(double d) : 返回大于或等于参数d的最小整数(向上取整) 3. static double floor(doublr d) : 返回小于或等于参数d的最大整数(向下取整) 4. static double pow(double a, double b) : 返回a的b次方 5. static double sqrt(double a) : 开方 输入负数,返回NaN,意思是not a number 6. static double random() : 返回随机数0.0-1.0, [0.0-1.0) 7. static double round(double d) : 获取d的四舍五入的值 5.415622 得 5.0 5.5222455555 得 6.0 Arrays类* 概述 * 数组工具类 * 位于java.util.Arrays * 全是静态方法 * 常用方法 1. static void sort(数组) : 将数组进行升序排序 2. static int binarySearch(数组,查找元素) : 返回查找元素在数组中的索引 注意: 查找元素不存在时，返回(-插入点 - 1) 3. static String toString(数组) : 将数组变成字符串 大数据运算BigInteger类* 概述 * 将一个超大整数封装到BigInteger对象中 * java.math.BigInteger * 构造方法 * BigInteger(String num) : 将BigInteger的十进制字符串表示形式转换为BigInteger对象。 * 四则运算(结果也是BigInteger对象) * 加 BigInteger add(BigInteger val) BigInteger b = b1.add(b2); * 减 BigInteger subtract(BigInteger val) * 乘 BigInteger multiply(BigInteger val) * 除 BigInteger divide(BigInteger val) BigDecimal类* 概述 * 解决浮点数计算不准确的问题 * 构造方法 * BigDecimal(String val) : 将 BigDecimal 的字符串表示形式转换为 BigDecimal * 三则运算(结果也是BigDecimal对象) * 加 BigDecimal add(BigDecimal val) BigDecimal b = b1.add(b2); * 减 BigDecimal subtract(BigDecimal val) * 乘 BigDecimal multiply(BigDecimal val) * 除 * divide(BigDecimal val) 除不尽会产生无限不循环小数,抛异常 * 用BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) scale : 保留几位数 roundingMode : 保留模式,写下面这些静态成员变量 * 静态成员变量 * static int ROUND_UP : 向上加１ * static int ROUND_DOWN : 直接舍去 * static int ROUND_HALF_UP : 如果舍弃部分&gt;=0.5,向上加1,否则直接舍去 * static int ROUND_HALF_DOWN : &gt;0.5,向上加1,否则直接舍去]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象]]></title>
      <url>%2F2017%2F02%2F04%2F12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[面向过程与面向对象* 面向过程： 注重实现过程，每件事都是要亲自去做 * 面向对象： 注重实现结果，强调这件事让别人帮我来做 好处: 1. 更符合人类思考的习惯 2. 将复杂的事情简单化 3. 从执行者变成指挥者 局部变量和成员变量区别1.定义位置不同 局部变量：方法中 成员变量：类中方法外 2.作用域不同 局部变量：方法中，出了方法就不能用了 成员变量：整个类 3.默认值不同 局部变量：没有默认值，局部变量必须先赋值才能使用 成员变量：有默认值。和数组元素默认值一样 4.内存位置不同 局部变量：在栈内存的方法中 成员变量：在堆内存的对象中 5.生命周期不同 局部变量：随着方法弹栈而消亡 成员变量：随着对象的回收而消亡 private关键字* private可以修饰成员内容包括成员方法和成员变量 * 被private修饰的内容不能在其他类访问 get和set方法私有化所有的属性 (成员变量) ,必须写对应的get/set方法 凡是自定义的类,自定义成员变量,应该私有化,提供get/set 12345678910111213141516171819202122public class Person &#123; private String name; private int age; // set方法,变量name,age赋值 public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; // get方法,变量name,age获取值 public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125;&#125; * 测试代码1 1234567891011public class PersonTest &#123; public static void main(String[] args) &#123; Person p = new Person(); //调用set方法,对成员变量赋值 p.setAge(18); p.setName("旺财"); //调用get方法,获取成员变量的值 System.out.println(p.getName()); System.out.println(p.getAge()); &#125;&#125; 封装概念: 隐藏实现细节，对外提供可以访问的方式 好处: * 1、提高了代码的复用性 * 2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。 * 3、提高了安全性 继承* 子类会自动拥有父类所有非private修饰的属性和方法 * 格式: class 子类 extends 父类 {} * 好处: * 1、提高了代码的复用性，提高软件开发效率。 * 2、让类与类之间产生了关系，提供了多态的前提。 * 坏处: 提高了类与类之间的耦合性 * 注意: * 1、Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类 * 2、多个类可以继承一个父类 * 3、Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类 如: C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类 123class A&#123;&#125; class B extends A&#123;&#125; // 类B继承类A，类B是类A的子类 class C extends B&#123;&#125; // 类C继承类B，类C是类B的子类，同时也是类A的子类 * 4、Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。 * 补充: * 父类和子类创建后,编译时,父类.class先进内存方法区,然后子类再进 * 创建子类的对象,子类在堆中划分区域存储,一个区域留给父类,父类成员变量 跟随子类对象进入堆内存,另一块区域留给自己(父类区域在子类区域内部) * 继承后子类父类成员变量的特点 : * 子父类中出现了同名的成员变量时,遵循就近查找原则,访问子类. 在子类中需要访问父类中非私有成员变量时，需要使用super关键字 * 重写: * 当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法， 若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 * 子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写 12345678910111213141516171819202122232425//手机类 class Phone&#123; public void sendMessage()&#123; System.out.println("发短信"); &#125; public void call()&#123; System.out.println("打电话"); &#125; public void showNum()&#123; System.out.println("来电显示号码"); &#125; &#125; //智能手机类 class NewPhone extends Phone&#123; //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能 public void showNum()&#123; //调用父类已经存在的功能使用super super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println("显示来电姓名"); System.out.println("显示头像"); &#125; &#125; 子类父类内存图: 重载与重写对比重载overload: 在同一个类中,方法名相同,参数列表不同 和权限修饰符(public private 默认)无关,和返回值类型无关 方法名:重载的两个方法的方法名必须相同 形参列表(三者至少满足一个): 形参类型的顺序不同 形参的个数不同 形参的类型不同 重写overwrite: 权限修饰符(public private 默认): 子类方法的权限 &gt;= 父类的方法的权限 方法名: 子类方法和父类方法必须相同 形参列表: 子类方法和父类方法的形参列表必须相同 返回值类型: 基本类数据类型: 必须相同 引用数据类型: 子类方法的返回值类型和父类方法的返回值类型相同 或者 子类方法的返回值类型是父类方法的返回值类型的 子类 抽象类* 抽象类定义格式: 123public abstract class 类名 &#123; &#125; * 抽象方法定义格式: 1public abstract 返回值类型 方法名(参数); 抽象方法,没有方法体; * 使用: * 定义类，继承抽象类，并重写抽象方法 * 创建子类对象，通过子类对象调用成员 * 特点: * 抽象类,抽象方法被abstract修饰,抽象方法只能出现在抽象类或接口中 * 抽象类不能创建对象 * 一个普通类继承抽象类,一定要重写父类所有方法 * 抽象类中可以有抽象方法,也可以有普通方法 * 不能和private,final,static一起用 接口* 概念 接口是功能的集合,同样可看做是一种数据类型,是比抽象类更为抽象的”类”,一般把接口当作功能扩展. 接口只有抽象方法定义,并没有具体实现。 * 接口定义格式 12345public interface 接口名 &#123; 抽象方法1; 抽象方法2; 抽象方法3;&#125; * 抽象方法定义格式 1public abstract 返回值类型 方法名(参数列表); * 类实现接口 * 类与接口之间为实现关系,不是继承 * 定义实现类,实现接口,并重写接口中所有抽象方法 * 类实现接口的格式： class 类名 implements 接口名 { 重写接口中所有抽象方法 } * 注意: 接口不能new, 实现类可以new * 实现类的特点: 重写接口中所有抽象方法,除非该实现类也是抽象类,则不能new * 接口中成员特点 * (1)成员变量的特点:(其实是常量,接口中没有变量) * 固定格式: 1public static final 数据类型 变量名 = 值; public : 公共权限 static : 静态,可以被 类名．（接口名．）直接调用 final : 最终,固定变量的值. 所以再有赋值操作,都会报错 注意: public static final,可以不写或选择性写.但默认还是被这三个修饰 * (2)成员方法的特点: * 固定格式: 1public abstract 返回值类型 方法名(参数列表); 注意: public abstract,可以不写或选择性写.但默认还是被这两个修饰 * (3)实现类必须覆盖掉接口中所有的抽象方法后，实现类才可以实例化。否则实现类还是一个抽象类。 * 接口的多实现 * 接口最重要的体现：解决多继承的弊端 类如果多继承，多个父类有相同功能时，子类调用会产生不确定性， 因为父类中方法有主体，调用运行时，不确定运行哪个主体内容。 * 接口并没有这种安全隐患,因为接口中全是抽象方法,并没有方法体 * 格式: 123public class C implements A,B&#123; 重写A,B中所有抽象方法,否则不能被实例化&#125; 注意: 如果A,B中有同名方法,但返回值不同,实现类中重写方法会报错 * 类在继承类的同时,可以实现多个接口(先写继承,再写接口实现) 123public class D extends C implements A,B&#123;&#125; * 接口的多继承 1234567891011121314 public interface A&#123; public abstract void a();&#125;public interface B&#123; public abstract void b();&#125;public interface C extends A,B&#123; public abstract void c();&#125;public class D implements C&#123; public void a()&#123;&#125; public void b()&#123;&#125; public void c()&#123;&#125;&#125; //D实现接口C, 需要重写C接口的全部抽象方法, //而且C继承A,B, 所以D实现类要重写ABC中所有抽象方法 注意: 由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性 * 接口与接口之间是继承关系,用extends * Java支持接口之间的多继承,一个接口可以同时继承多个接口 * 问: Java中有多继承吗? 类不支持多继承, 接口支持多继承 * 接口与抽象类的区别 1. 成员: 接口中全是抽象方法,抽象类中可以有抽象方法,也可以有非抽象方法 接口中成员变量只能是常量,抽象类中可以有变量 2. 继承关系: 接口可以多实现,多继承 抽象类只能单继承,多层继承 3. 设计理念: 接口是这个事物中的额外内容 抽象类是这个事物中应该具备的内容 多态* 概念: 一种事物有多种形态 如Student类继承了Person类，一个Student的对象便既是Student，又是Person。 * 格式: 父类类型或接口类型 变量名 = new 子类的对象(); 共有三种表现形式: 1.普通类作为父类引用指向子类对象 2.抽象类作为父类引用指向子类对象 3.接口做为父类,指向实现类对象 注意:(1)父类引用可以指向子类对象 (2)多态调用方法,方法必须运行子类的重写方法 * 好处: 1. 提高了代码扩展性(多态来保证) 2. 提高了代码维护性(继承来保证) * 坏处: 1. 无法调用子类特有的属性 * 多态前提: 1. 要有继承(实现)关系 2. 要有方法重写(否则多态没有意义) 3. 父类引用指向子类对象 * 多中成员特点: (1)成员变量(编译,运行看父类) 编译时,参考父类中有无这个变量,有则编译成功,没有则失败 运行时,运行的是父类中的变量值 (2)非静态成员方法(编译看父类,运行看子类) 编译时,参考父类中有无这个方法,有则编译成功,没有则失败 运行时,运行的是子类中的重写方法 (3)静态成员方法(编译,运行看父类) * instanceof关键字: 比较引用数据类型 * 格式: 引用变量 instanceof 类名 p instanceof Student 比较p是不是Student类型的对象,是则返回true * 转型 (1)向上转型(自动转换) 父类引用指向子类对象 Person p = new Student(); (2)向下转型(强制转换): 父类类型转为子类,可以调用子类中特有方法 格式: 子类类型 变量名 ＝（子类类型）父类类型的变量； Student s = (Student) p ; 构造方法* 作用: 在创建对象的同时,为成员变量初始化 * 快捷键: ALT+Shift+S (Generate Constructor using Firlds) * 格式: 权限 方法名（参数列表）{ 方法体； } * 注意: １.方法名与类名完全一致 ２.不允许写返回值类型 ３.构造方法在创建对象的时候执行，每个对象只执行一次 ４.每一个类都有一个构造方法，如果我们没给，编译器会自动添加一个空参数的构造方法 特别注意: 1.构造方法弹栈退出后,对象才算是创建结束 2.一个类中,如果不写构造方法,默认会有一个空参构造,但是如果写了一个,就没有默认的构造方法了 3.构造方法中可以有return * 重载 类中的构造方法可以有无限个, 区别就是参数列表不同 * 构造方法和普通方法区别 * 定义格式不同: 构造方法: 没有返回值,且方法名和类名一致 普通方法: 有返回值,方法名字随意 * 执行: 构造方法: 在对象创建时自动执行，而且只执行一次 普通方法: 对象创建后,需要手动调用,且可以执行多次 * this * 代表本类对象的引用, 由谁调用,this就代表谁 作用: 1. 区分成员变量和局部变量的同名情况 2. 在本类中调用其他构造方法 格式: this(参数列表); 调用其他构造方法时,this()必须定义在构造方法的第一行，原因是初始化动作要最先执行。 12345678910111213public Person()&#123; this("geekhoon",25);//写在方法体的第一行 &#125;public Person(String name,int age)&#123; this.name = name; this.age = age;&#125;测试类的main方法: main()&#123; Person p = new Person(); syso(p.getName());//geekhoom syso(p.getAge());//25 &#125; * super 作用: 调用父类的构造方法和成员变量 格式: 调用父类中的空参数构造方法 super(); 调用父类中的有参数构造方法 super(实参列表); 注意: * 只要是构造方法默认(隐式)第一行都是super(); * 如果父类中有多个重载构造器,子类任意调用一个即可 * super()和this()调用构造方法时,不能放在同一个代码块中,因为都要放在第一行 * 无论如何,子类所有的构造方法,都要直接,间接调用父类构造方法 * 当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句，指定要访问的父类有参数构造方法。 * 子类默认会调用父类的无参构造， 但如果父类没有无参构造(即父类自定义了一个有参构造)，子类的构造方法继续调用父类的无参构造就会报错。 final* final就是固定, 不可变 * 可修饰 类,方法,成员变量,局部变量 1.修饰类: 不可以被继承, 但是可以继承别的类 String类就是final修饰的 2.修饰方法: 不可以被子类重写, 但是可以被子类继承使用 3.修饰局部变量: (1)修饰基本数据类型: 称为常量,只能被赋值一次,终身不可改变 (2)修饰引用数据类型: 变量存储的地址不可改变 但被final修饰的引用类型的变量指向的对象的属性是可以发生改变的 4.修饰成员变量: * final固定的是成员变量的手动赋值,不是默认值 * 一次赋值，终身不可改变 * 需要在创建对象前赋值，否则报错,即不能用set赋值 * 为成员变量赋值的两种实现方式: (1)直接赋值,定义时用&quot;=&quot;赋值 final int age = 1; (2)使用构造器进行赋值: 1234final int age;public Demo(int age)&#123; this.age = age;&#125; 这两种赋值方式它不可以一起使用 static* 特点: 被static修饰的成员属于类, 被该类的所有对象共享。被static修饰的成员可以通过类名直接调用 多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改， 其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量 * 可修饰 方法, 成员变量 * 注意: 1. 被satic修饰的方法不能被重写, 但是可以重载 2. 静态不能直接访问非静态(因为生命周期不同,静态优先于非静态存在于内存中,即静态先进入内存) 3. 不允许写this/super(因为它们是代表本类对象和父类对象) * 内存中位置: 1.被static修饰的成员存在于方法区 2.静态优先于非静态存在 3.随着类的加载而加载,随着类的消亡而消亡 * 应用场景: 1. 什么时候使用static修饰成员变量？ 这个成员变量需要被这个类的所有对象共享 2. 什么时候使用static修饰成员方法？ 静态的方法只能访问静态的成员,如果成员方法中没有调用非静态成员,可以加static * 定义静态常量: * 格式: public static final 数据类型 变量名 = 值; * 变量名全部大写，多个单词使用下划线连接 * 记住: 静态和对象没有关系, 静态是属于类的 匿名对象* 指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。 * 特点: * 只能使用一次 * 可以作为方法接收的参数、方法返回值使用 内部类* 当一个类定义在一个类的内部，这个类就是一个内部类 * 包括: (1)成员内部类: 1234567public class Outer &#123; 修饰符 class 内部类名 &#123; public void function() &#123; &#125; &#125;&#125; 注意: 成员内部类可以使用外部类成员,包括私有. 外部类要使用内部类成员,必须建立内部类对象 外部类调用内部成员访问方式: 外部类名.内部类名 变量名 = new 外部类对象().new 内部类对象(); 变量名.内部类方法(); (2) 局部内部类: 把一个类定义到另一个类的方法中 匿名内部类* 实质: 父类类型的子类对象, 或接口的实现类对象 * 格式: new 接口或父类(){ 重写接口或者父类中的方法;(注意: 不是只重写抽象方法) }; * 注意: 匿名方法只能在方法中或构造代码块,局部代码块中使用 * 优点: 减少代码量 * 缺点: 可读性差 包* 概念: 实质上就是文件夹，可以对java代码进行分类管理 * 声明包格式: package 包名; * 导入包的格式: import 要导入的包名; * 注意: java.lang包下的类是不需要导包也可以使用的 * 包的命名规范: 全部小写，一般是域名的倒叙。 权限修饰符 从大到小 * public: 公共的，在任何包中都可使用 * protected: 受保护的，跨包子类中，本包中也可以使用 * default: 默认的，本包中可以使用。注意，默认的是什么都不写 * private: 私有的，只能在本类中使用 注意: 1. 修饰类只能使用public、默认的、final、abstract关键字 2. abstract不能和private,static,final一起用 代码块代码块中不能创建方法 * 局部代码块：在方法中的 {} : 限定局部变量的生命周期 * 构造代码块：在类的成员位置的 {} 构造代码块在创建对象的时候执行，每创建一次，就执行一次。构造代码块优先于构造方法执行 * 静态代码块: 在类的成员位置 格式: static { } 静态代码块在类加载的时候执行，并且只会执行一次，优先于构造代码块执行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组操作之遍历、逆序、排序及查找]]></title>
      <url>%2F2017%2F01%2F26%2F11-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E4%B9%8B%E9%81%8D%E5%8E%86%E3%80%81%E9%80%86%E5%BA%8F%E3%80%81%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%9F%A5%E6%89%BE%2F</url>
      <content type="text"><![CDATA[数组遍历12345678910111213141516//打印结果为[11, 33, 44, 22, 55]public static void main(String[] args) &#123; int[] arr = &#123;11, 33, 44, 22, 55&#125;; printArr(arr);&#125;private static void printArr(int[] arr) &#123; System.out.print("["); for (int i = 0; i &lt; arr.length; i++) &#123; if(i == arr.length - 1)&#123; System.out.print(arr[i]); &#125;else&#123; System.out.print(arr[i]+","); &#125; &#125; System.out.print("]");&#125; 逆序12345for(int start = 0,end = arr.length-1;start &lt; end;start++,end--)&#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp;&#125; 原理如图: 选择排序123456789101112131415private static void selectSort(int[] arr) &#123;//外层比较了arr.length-1次for (int i = 0; i &lt; arr.length - 1; i++) &#123;//i=0时,arr[0]和arr[1]先比,再与arr[2],arr[3]比//i=1时,arr[1]和arr[2]先比,再与arr[3]比//i=2时,arr[2]和arr[3]比//所以令j=i+1,内层循环次数递减 for(int j = i + 1;j &lt; arr.length;j++)&#123; if (arr[i] &gt; arr[j]) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125;&#125; 原理如图: 冒泡排序12345678910111213private static void bubbleSort(int[] arr) &#123; //外层循环与选择排序一样,循环arr.length-1次 for (int i = 0; i &lt; arr.length-1; i++) &#123; //内层循环,索引每次从0开始, 每圈次数递减,若是j &lt; arr.length-i,会报索引越界异常 for (int j = 0; j &lt; arr.length-i-1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125;&#125; 原理如图: 折半查找12345678910111213141516171819private static int binarySearch(int[] arr, int key) &#123; int min = 0; int max = arr.length - 1; int mid = 0; //当min&gt;max,证明未找到,返回-1 while(min &lt;= max)&#123; mid = (min + max)/2; ////让查找元素和中间索引元素进行比较 if (key &gt; arr[mid]) &#123; min = mid + 1; &#125;else if (key &lt; arr[mid]) &#123; max = mid - 1; &#125;else&#123; //找到元素,返回元素索引 return mid; &#125; &#125; return -1;&#125; 原理如图:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集合]]></title>
      <url>%2F2017%2F01%2F15%2F10-%E9%9B%86%E5%90%88%2F</url>
      <content type="text"><![CDATA[ArrayList创建变量的步骤* 导入包 java.util包中 * 创建引用类型的变量 数据类型&lt; 集合存储的数据类型&gt; 变量名 = new 数据类型&lt;集合存储的数据类型&gt;(); 创建集合引用变量的时候,必须先指定好存储的数据类型 * 变量名.方法 注意: 集合只存储引用数据类型,不存储基本类型 8个基本类型要对应8个引用类型 集合和数组区别 集合 数组 长度: 可变 | 固定 数据类型: 只能引用 | 既可以基本既可以引用 ArrayList的常见方法* add(参数) 向集合中添加元素 * get(int index) 取出集合中的元素,get方法的参数,写入索引 * size() 返回集合的长度, 集合存储元素的个数 * add(int 索引,存储的元素) 将元素添加到指定的索引上 * set(int 索引,修改后的元素) 将指定索引的元素,进行修改 * remove(int 索引) 删除指定索引上的元素 * clear() 清空集合中的所有元素,对象不会删 ArrayList集合的遍历概述* 区别:遍历时,集合存储(Integer类型)与(类),调用get()得到的值是有区别的,分别是值与地址 * 但是类中如果重写了Object的toString()方法,可以打印出内容 四种遍历方式:1. System.out.println(集合变量名);(这个其实不算遍历,只是打印而已) 这种方式适用于String类型和基本数据类型对应的引用类型如Integer做泛型的情况,如果是自定义类,需要重写toString() 2. 普通for循环遍历 3. 增强for循环 4. 迭代器 123456789101112131415161718Integer类型:import java.util.ArrayList;public class ArrayListDemo_2&#123; public static void main(String[] args)&#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(121); array.add(125); array.add(123); array.add(120); array.add(128); //对集合进行遍历 //使用方法 size+get组合进行遍历 for(int i = 0 ; i &lt; array.size(); i++)&#123; System.out.println( array.get(i) ); &#125; &#125;&#125; 12345678910类://遍历集合,打印所有学生信息public static void printArray(ArrayList&lt;Student&gt; array) &#123; for(int i = 0; i &lt; array.size();i++)&#123; //array.get(i)返回的是Student对象,用s接收 Student s = array.get(i); //直接打印s ,是地址值,除非重写了toString() System.out.println("姓名是"+s.name+",年龄是"+s.age); &#125;&#125; 集合中存储类对象 内存图 集合继承关系图* ArrayList类继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。 * Collection接口为最顶层集合接口了。Collection接口中的方法,是集合中所有实现类必须拥有的方法 * 源代码: interface List extends Collection { } public class ArrayList extends AbstractList implements List{ } * Collection下都为单列集合 * Collecton接口常用的子接口有：List接口、Set接口 * List接口常用的子类有：ArrayList类、LinkedList类 * Set接口常用的子类有：HashSet类、LinkedHashSet类 * List: 存取有序,有索引,可以重复 * ArrayList : 底层依赖的是数组, 查询快, 增删慢 * LinkedList : 底层依赖的是链表, 查询慢, 增删快 * Vector : 线程安全,效率低(过时了) * Set : 存取无序,无索引,不能重复 * HashSet : 顶层使用的是hash算法 * LinkedHashSet : 可以保证存取有序 * 关系图 Collection 接口 | ---------------------------------------------------------------- | | List接口 Set接口 | | ---------------- ------------- | | | ArrayList类 LinkedList类 HashSet类 | LinkedHashSet类 Collection接口概述* 是一个接口 * 区别与Collections, Collections是一个集合工具类,里面有操作List集合的排序,查找等静态方法 可以Collections.sort(list)使用 常用方法* add() * clear() : 清空集合中的所有元素, 集合容器本身依然存在,还可以继续添加 * size() * boolean contains(Object o) : 判断任意类型数据是否存在于集合中 ,存在返回true * Object[] toArray() : 集合中的元素,转成一个数组中的元素,集合转成数组 注意返回值类型,要写成Object数组 集合转数组的意义: IO中获取文件夹下的文件 * boolean remove(Object o) : 移除集合中指定的元素(若重复,删掉第一个) Java中三种长度表现形式* 数组.length 属性 返回值 int * 字符串.length() 方法,返回值int * 集合.size()方法, 返回值int 代码1234567891011121314151617//接口多态的方式调用Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();coll.add("abc");coll.add("bcd");coll.add("abc");coll.add("abc");coll.add("bcd");coll.add("cde");System.out.println(coll);coll.clear();System.out.println(coll);Object[] objs = coll.toArray();for(int i = 0; i &lt; objs.length;i++)&#123; System.out.println(objs[i]);&#125; 123456789101112131415161718//ArrayList中remove(int 索引) : 删除指定索引上的元素ArrayList&lt;String&gt; coll = new ArrayList&lt;String&gt;();coll.add("aaa1");//1处coll.add("aaa4");//2处coll.add("aaa1");//3处coll.add("aaa1");coll.add("aaa4");coll.add("aaa5");//get(索引)获取元素,只是ArrayList中的方法,Collection中没有,使用多态要向下转型for (int i = 0; i &lt; coll.size(); i++) &#123; if ("aaa1".equals(coll.get(i))) &#123;//注意ArrayList中remove的小细节,1处有"aaa1"删除后,i=1,//假如2处也为"aaa1",因为删完后2处索引为0,而此时i=1,2处的"aaa1"就不会被删除//将如1 2 3处如上所示,则没有影响,第二个出现的"aaa1"也可以被删除 coll.remove(i--);//如果有相邻的重复元素,删除后,索引必须-- &#125;&#125;System.out.println(coll); Iterator迭代器概述* 是一个接口 * 因为每种集合的底层的数据结构不同, 迭代器是一种通用的获取集合中元素的方式 * ArrayList是Iterable的实现类 常用方法* boolean hasNext() : 判断集合中还有没有可以被取出的元素,如果有返回true * next() : 取出集合中的下一个元素,且指针后移 使用迭代器对集合进行遍历的步骤:1. 通过集合获取一个迭代器 Iterator&lt;E&gt; it = list.iterator();//it是Iterator接口的实现类的对象 2. 循环判断迭代器中是否有元素 while(it.hasnext()){ 3. 如果有元素, 取出元素并打印 System.out.println(it.next());//it.next()的返回值类型为泛型E } for循环迭代写法:1234//for循环节约内存(因为迭代期在for里面)for (Iterator&lt;String&gt; it = coll.iterator(); it.hasNext(); ) &#123; System.out.println(it.next());&#125; 集合迭代中的转型* 注意: 1. 集合中存储其实都是对象的地址。 2. 集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。 // 因为出现了基本类型包装类，它提供了自动装箱操作，集合中的元素就是基本数值的包装类对象。 3. 存储时提升了Object。取出时要使用元素的特有内容，必须向下转型 12345678910111213141516171819202122232425Collection coll = new ArrayList();coll.add("abc");coll.add("aabbcc");coll.add("cast");Iterator it = coll.iterator();while (it.hasNext()) &#123; //由于元素被存放进集合后全部被提升为Object类型 //当需要使用子类对象特有方法时，需要向下转型 String str = (String) it.next(); System.out.println(str.length());&#125;//注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。//注意: Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下：Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();coll.add("abc");coll.add("aabbcc");coll.add("cast");Iterator&lt;String&gt; it = coll.iterator();while (it.hasNext()) &#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); // System.out.println(str+"....."+it.next());注意str与it.next()值会不一样,因为指针后移了&#125; 增强for循环概述* 增强for循环是JDK1.5新特性 * JDK1.5版本后,出现新的接口 java.lang.Iterable , Collection开始继承Iterable * Iterable接口的主要作用就是,实现增强for循环 格式* for( 数据类型 变量名 : 数组或者集合 ){ System.out.println(变量名); } 遍历数组* 好处: 代码少了，方便对容器遍历 * 坏处: 没有索引，不能操作容器里面的元素 12345678910111213public static void function()&#123; int[] arr = &#123;1,2,4,5&#125;; for(int i : arr)&#123; System.out.println(i); &#125;&#125;public static void function_1()&#123; //for对于对象数组遍历的时候,可以调用对象的方法 String[] str = &#123;"abc","cde","cdef"&#125;; for(String s : str)&#123; System.out.println(s.length());//可以调用String类的方法 &#125;&#125; 遍历集合12345678910//存储自定义Person类型public static void function_2()&#123; ArrayList&lt;Person&gt; array = new ArrayList&lt;Person&gt;(); array.add(new Person("a",20)); array.add(new Person("b",10)); for(Person p : array)&#123; //可以调用Person类中方法 System.out.println(p);// 调用内容需要重写toString方法 &#125;&#125; 泛型概述* JDK1.5出现新的安全机制,保证程序的安全性 * 指明了集合中存储数据的类型 &lt;数据类型&gt; * 伪泛型 * Java中泛型,是伪泛型 : 编译后class文件中,没有泛型 泛型类* 格式: 修饰符 class 类名&lt;代表泛型的变量&gt; { } 泛型方法* 格式: 修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ } * 如: API中的ArrayList集合中的方法： public &lt;T&gt; T[] toArray(T[] a){ } //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组 这个toArray方法不推荐使用, 将集合转成数组推荐定义一个新数组,然后遍历向里面赋值 泛型接口* 格式: 修饰符 interface 接口名&lt;代表泛型的变量&gt; { } * 方式一(常用): 实现类,先实现接口,不理会泛型: public class ArrayList&lt;E&gt; implements List&lt;E&gt;{ } 调用者 : new ArrayList&lt;String&gt;() 后期创建集合对象的时候,指定数据类型 * 方式二: 实现类,在实现接口的同时,也指定了数据类型 public class 类名 implements List&lt;String&gt;{ } 泛型好处1. 安全性(不指定类型,强转时传入不同类型会异常) 2. 将运行时期的ClassCastException，提前到了编译时期 泛型的通配符* 可以匹配所有的数据类型: ? 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); array.add("123"); array.add("456"); set.add(789); set.add(890); iterator(array); iterator(set);&#125; /* * 定义方法,可以同时迭代2个集合 * 参数:不能写ArrayList,也不能写HashSet,所以可以写它们共同实现的接口 * 数据类型写泛型通配符 ? */public static void iterator(Collection&lt;?&gt; coll)&#123; Iterator&lt;?&gt; it = coll.iterator(); while(it.hasNext())&#123; //it.next(); 注意这里不能强转,因为要匹配多个集合,不能指定单一类型 System.out.println(it.next()); //直接放入打印语句中 &#125;&#125; 泛型限定1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) &#123; //创建3个集合对象 ArrayList&lt;ChuShi&gt; cs = new ArrayList&lt;ChuShi&gt;(); ArrayList&lt;FuWuYuan&gt; fwy = new ArrayList&lt;FuWuYuan&gt;(); ArrayList&lt;JingLi&gt; jl = new ArrayList&lt;JingLi&gt;(); //每个集合存储自己的元素 cs.add(new ChuShi("张三", "后厨001")); cs.add(new ChuShi("李四", "后厨002")); fwy.add(new FuWuYuan("翠花", "服务部001")); fwy.add(new FuWuYuan("酸菜", "服务部002")); jl.add(new JingLi("小名", "董事会001", 123456789.32)); jl.add(new JingLi("小强", "董事会002", 123456789.33)); ArrayList&lt;String&gt; arrayString = new ArrayList&lt;String&gt;();//1处 iterator(jl); iterator(fwy); iterator(cs);&#125;/* * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法 * 强制转换: 只写? ,是Object类型 it.next() = Object o ==&gt; Employee * 写完泛型限定后,1处就会报错,不允许传入String类型 * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象 * 泛型的限定 本案例,父类固定Employee,但是子类可以无限 * ? extends Employee 限制的是父类, 称为上限限定, 可以传递Employee,传递他的子类对象 * ? super Employee 限制的是子类, 称为下限限定, 可以传递Employee,传递他的父类对象 */public static void iterator(ArrayList&lt;? extends Employee&gt; array)&#123; Iterator&lt;? extends Employee&gt; it = array.iterator(); while(it.hasNext())&#123; //获取出的next() 数据类型,是什么Employee Employee e = it.next(); e.work(); &#125;&#125; List接口概述* 特点: 有序,有索引,可以重复 * 它的实现类ArrayList,LinkedList也满足上述特点 * 特有方法 * 注意: 特有方法是带有索引的方法 * 带有索引的操作,防止越界问题(集合中索引越界异常: java.lang.IndexrOutOfBoundException) * ArrayIndexrOutOfBoundException : 数组索引越界异常 * StringIndexrOutOfBoundException :字符串索引越界异常 1. 增: add(int index, E): 将元素插入到列表的指定索引上 2. 删: E remove(int index): 移除指定索引上的元素 , 返回被删除之前的元素 3. 改: E set(int index, E): 修改指定索引上的元素 , 返回被修改之前的元素 4. 查: E get(int index): 获取指定索引处的元素，并返回该元素 * 三种遍历方式 1. 迭代器 2. 普通for 3. 增强for 迭代器的并发修改异常* 迭代器原理: 通过集合获取一个迭代器后,迭代器里面的内容是集合内容的映射 * 迭代器遍历过程中,使用了集合方法修改了集合长度(注意是修改长度,才会出错), 导致迭代器并不知道集合中的变化，容易引发数据的不确定性, 会抛异常:java.util.ConcurrentModificationException * 处理办法: 1. 使用迭代器自身的办法, 有remove(),没add 2. 或者通过ListIterator迭代器操作元素是可以的， ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("aaa1"); list.add("aaa2"); list.add("aaa3"); list.add("aaa4"); list.add("aaa5"); list.add("aaa6"); list.add("aaa7"); int count = 0; Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); if (str.equals("aaa2")) &#123;//0处 //list.add("2222"); //1处 //it.remove("aaa3"); //2处 it.remove(); //3处 count++; //System.out.println("删了"+count+"次"); &#125; //System.out.println(str); //4处 &#125; System.out.println(list);//5处&#125;//0处判断,当前字符串是不是"aaa2",如果是,若运行1处,则会抛迭代器的并发修改异常//2处是错的,因为迭代器的remove方法,没有参数//执行3处后,"aaa2"被删除, 当然count是1,因为只有一个"aaa2"//执行4处, 全部字符串都会打印//执行5处, 除了"aaa2"都会打印注意这里有一个结论:并不会报错 !!如果是if(str.equals("aaa6")),即判断是倒数第二个,可以用集合的remove方法删除任何一个,比如list.remove("aaa1");如果是if(str.equals("aaa5")),即判断是倒数第三个,可以用集合的remove方法删除任何两个,比如list.remove("aaa1");list.remove("aaa2");...//迭代器没有add方法,但是要求用迭代器遍历,且如果集合中存在"aaa2",添加"AAA2"//则可以定义一个标记, 如:Iterator&lt;String&gt; it = list.iterator();boolean b = false;while(it.hasNext())&#123; String str = it.next(); if (str.equals("aaa2")) &#123; b = true; &#125;&#125;if(b)&#123; list.add("AAA2");&#125; List集合存储数据的结构* 常用数据存储结构: 栈,队列,数组,链表 * 栈: 先进后出(手枪弹夹) * 队列: 先进先出(火车安检) * 数组: 1. 查询快:通过索引快速找到元素 2. 增删慢:每次增删都需要开辟新的数组,将老数组中的元素拷贝到新数组中,开辟新数组耗费资源 * 链表: 1. 查询慢:每次都需要从链头或者链尾找起 2. 增删快:只需要修改元素记录的下个元素的地址值即可不需要移动大量元素 ArrayList集合* 底层采用的是**数组**结构, 查询快,增删慢, 主要用来查询,遍历数据 ArrayList al=new ArrayList();//创建了一个长度为0的Object类型数组 al.add(&quot;abc&quot;);//底层会创建一个长度为10的Object数组 Object[] obj=new Object[10] //obj[0]=&quot;abc&quot; //如果添加的元素的超过10个,底层会开辟一个1.5*10的长度的新数组 //把原数组中的元素拷贝到新数组,再把最后一个元素添加到新数组中 原数组: a b c d e f g h k l 添加m: a b c d e f g h k l m null null null null 注意: 打印集合长度,还是根据集合中存入数据的个数,而不是开辟空间的长度,即存入一个数据,打印长度为1 LinkedList集合* 自身特点: 1. 底层是**链表**实现, 查询慢,增删快 2. LinkedList的索引决定是从链头开始找还是从链尾开始找 如果该元素小于元素长度一半,从链头开始找起,如果大于元素长度的一半,则从链尾找起 * 特有功能: (子类的特有功能,不能多态调用) 1. addFirst(E): 添加到链表开头 2. addLast(E) : 添加到链表结尾 3. E getFirst(): 获取链表开头 4. E getLast() : 获取链表结尾 3和4在获取时,要判断是否元素,否则报错 if(list.size() != 0 ) 5. E removeFirst() : 移除并返回链表开头 6. E removeLast() : 移除并返回链表结尾 5. isEmpty() : 判空 //这个不是特有,是Collection的方法 Vector集合* Vector集合数据存储的结构是**数组**结构，为JDK中最早提供的集合,它是线程同步的 * 过时了,了解, 被ArrayList取代 * 弱点: 运行速度慢 Set接口概述* 特点: 无序, 无索引,不存储重复元素 * 元素取出方式: 1. 迭代器 2. 增强for ,因为没有索引, 所以不能用普通for * 方法与Collection接口一模一样 HashSet集合* Set接口的实现类 * HashSet代码的编写,和ArrayList一致 * 自身特点: 1. 底层数据结构是**哈希表** 2. 存取比较快 3. 线程不安全,运行速度快 * 注意: 取出顺序和存储顺序不同,但不管取出多少次,元素打乱取出的顺序是不变的,即遍历几次结果是一样的 Set集合存储和迭代123456789101112131415161718192021//HashSet代码的编写,和ArrayList一致public class HashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add("11"); set.add("22"); set.add("33"); set.add("java"); set.add("55"); Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; System.out.println("=============="); for(String s : set)&#123; System.out.println(s); &#125; &#125;&#125; 哈希表Hashtable数据结构* 数组链表结合 * 初始容量指的是数组的长度,默认长度是16 * 加载因子: 表中填入的记录数/哈希表的长度, 默认0.75 ,决定扩容时机 * 数组扩容: 当插入元素的个数 &gt; (当前数组长度 * 加载因子),会扩容 底层会开辟一个长度为原长度2倍的数组,把老元素拷贝到新数组中,再把新元素添加数组中 对象的哈希值* 一个普通的十进制整数 * 父类Object中有一个方法int hashcode() : 返回对象的哈希值,返回值int类型,结果不唯一 * 子类中可以重写hashcode(),自定义哈希值 * 哈希值是存储到HashSet的依据 * String类继承Object类,重写了hashcode()方法, **只要字符串相同,则返回结果唯一**,和对象地址相同无关 123456public static void main(String[] args) &#123; String s = "123"; String s1 = new String("123"); //s和s1地址不同, 但哈希值只考虑字符串是否相等 System.out.println(s.hashCode());//48690 System.out.println(s1.hashCode());//48690 结果一样,参考String类重写的hashcode()&#125; 哈希表的存储结构* 可以解释HashSet存储元素不重复的原因 * 存取原理: 每存入一个新的元素都要走以下三步: 1. 调用对象的hashCode()方法算出哈希值h 2. 集合在容器中找是否与新元素哈希值相同的老元素, 如果没有,直接存入 如果有,转到第三步 3. 集合会让新元素调用它的equals方法,若结果为true,集合判定元素重复,不再存入 若为false,集合判定对象没有重复,采用&quot;桶&quot;的存储方式存入 重复上述操作..... * 哈希表存储对象的依据是: **对象的哈希值和equals方法** 哈希表存储过程 哈希表存储自定义对象* 自定义类重写hashCode()和equals()的条件是: **需要写入哈希表** * 自定义对象重写hashCode()和equals(), 要尽量降低出现相同哈希值的概率 * 重写目的: 让对象中的属性值相同时,得到相同的哈希值 12345678910111213141516171819202122232425262728293031323334//如果自定义类没有重写hashCode()和equals():public static void main(String[] args) &#123; HashSet&lt;Person&gt; list = new HashSet&lt;Person&gt;(); list.add(new Person("a", 11)); list.add(new Person("a", 11)); list.add(new Person("b", 10)); list.add(new Person("b", 10)); list.add(new Person("c", 13)); list.add(new Person("d", 12)); System.out.println(list);//全部都会乱序打印出来 &#125;//没有重写的话,会调用Object类中的hashCode()方法,属性值相同的对象也会哈希值不同//自定义对象重写hashCode()和equals():public int hashCode()&#123; return name.hashCode() + age * 2;&#125;public boolean equals(Object obj)&#123; if (this == obj) &#123; //如果传的就是本对象,返回true return true; &#125; if (obj == null) &#123; //如果传空对象,返回false return false; &#125; if (obj instanceof Person) &#123; //如果传的是Person类型,则进行强转 Person p = (Person) obj; return name.equals(p.name) &amp;&amp; age == p.age; &#125; //如果传的不是Person类型对象,则返回false return false;&#125; LinkedHashSet集合* 继承HashSet * 自身特点: 1. 具有可预知顺序的集合(怎么存,怎么取,**有序**) 2. 基于链表的哈希表实现, 线程不安全集合, 运行速度快 3. 双向链表 * 链表采用对象地址记录 123456789101112Set&lt;String&gt; list = new LinkedHashSet&lt;String&gt;();list.add("1");list.add("2");list.add("3");list.add("4");list.add("5");list.add("6");list.add("7");list.add("8");System.out.println(list);//打印结果为[1, 2, 3, 4, 5, 6, 7, 8],顺序与存储时一致 判断集合元素唯一的原理* Arraylist集合, 判断元素是否唯一调用contains方法 contains方法底层依赖于equals方法 * HashSet集合的add()方法和contains方法(),底层都依赖于hashCode()和equals() * 8中基本数据类型的包装类和String类都重写了hashCode()和equals() * **特别注意**: 使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法， 则判断重复时，使用的是地址值， 如果想通过内容比较元素是否相同，需要重写该元素类的hashcode与equals方法。 面试题1. 如果两个对象的哈希值相同 p1.hashCode()==p2.hashCode() 两个对象的equals一定返回true吗 p1.equals(p2) 一定是true吗 正确答案:不一定 public int hashCode(){ return 0; } public boolean equals(Object obj){ return false; }//方法写死 2. 如果两个对象的equals方法返回true,p1.equals(p2)==true 两个对象的哈希值一定相同吗 正确答案: 一定 //hashCode()相同才会调用equals() //而且官方API中规定了根据equals(),如果两个对象相等,则这两个对象中的每个对象调用的hashCode()必须生成相同的结果 Map集合概述* 接口 Map&lt;K , V&gt; ,K:键, V:值 * Map中的集合是双列集合, Map是双列集合顶层接口 * Map中是映射关系的键值对,键不可以重复,值可以重复 * 常用集合(Map的实现类): 1. HashMap: hash算法 ,针对的是键 ,无序 2. LinkedHashMap : HashMap的子类, 可以保证有序 常用方法* V put(K,V): 将键值对存储到集合中, K:键的对象,V:值的对象 ,返回值是值的类型 存储重复键时,会将原有的值覆盖,不会出现重键的情况 方法的返回值一般情况下, 会返回null 当存储重复键的时候, 返回被覆盖之前的值, 如果不出现键重复的情况, 返回值是null * V get(K): 通过键对象, 获取值对象 ,V是值的类型 * 若集合中没有这个键, 返回null * V remove(K): 移除集合中的键值对 ,返回被移除以前的值 * 若集合中没有这个键, 返回null * putAll(Map) * values() * contaionsValue * contaionsKey 遍历方式* 迭代器和增强for不能直接遍历Map 方式一: 利用键获取值* Set&lt;&gt; keySet() : 得到Map集合中所有的键,装入Set集合 * 步骤: 1. map集合调用keySet, 所有键存入Set集合 2. 遍历Set集合, 获取Set集合中所有的元素(Map中的键) 3. 调用map集合中的get方法, 通过键获取到值 123456789101112131415161718/* * 遍历方式一 , 利用键获取值 * 注意: 遍历的是Set集合 */Set&lt;Integer&gt; set = map.keySet();//迭代器Iterator&lt;Integer&gt; it = set.iterator();while(it.hasNext())&#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+"..."+value);&#125;System.out.println("-----------分割线-------------");//增强forfor(Integer key : set)&#123; String value = map.get(key); System.out.println(key+"..."+value);&#125; 方式二: entrySet方法* Entry键值对对象 * 键值对映射关系 * Entry接口是Map接口的一个静态嵌套接口,可以通过Map.Entry调用 * 步骤: 1. map集合调用entrySet()将集合的映射关系对象,存储到Set集合, 返回值Set&lt; Entry&lt;K,V&gt; &gt; , 出现了泛型的嵌套 2. 迭代Set集合 3. 获取出的Set集合的元素, 是映射关系的对象 Map.Entry&lt;K,V&gt; 4. 通过映射关系对象的方法, getKey,getValue获取键值对 1234567891011121314151617181920212223242526/* * 遍历方式二, entrySet() *///1.map集合调用entrySet()方法, 将映射关系对象存储到Set集合Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set2 = map.entrySet();//迭代器-------------------//2.迭代Set集合Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it1 = set2.iterator();while(it1.hasNext())&#123; //3.获取set集合中的元素, 是映射关系对象 Map.Entry&lt;Integer, String&gt; entry = it1.next(); //4.通过映射关系对象的getKey,getValue,获取键值 Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"..."+value); &#125;System.out.println("-----------分割线-------------");//注意: 增强for不能遍历Map, 因为只有Iterable接口的实现类才可以用增强for,//Map接口,并不继承Iterable接口, 增强for可以遍历Set//增强forfor(Map.Entry&lt;Integer,String&gt; entry : set2)&#123; //set2可以直接写成map.entrySet() Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"..."+value);&#125; HashMap存储和遍历* 使用HashMap存储自定义对象 * 自定义类对象可以作为键, 也可以作为值 12345678910111213141516171819202122/* * 自定义对象 作为键,为了保证键的唯一性,需要重写hashCode()和equals() * 自定义对象 作为值,不需要保证唯一性, 因为值可以重复 * Person类中也重写了toString(), 以保证打印出来的是对象的内容, 而不是地址 */HashMap&lt;Person, String&gt; map = new HashMap&lt;Person,String&gt;();map.put(new Person("张三", 11) , "山东");map.put(new Person("张三", 11) , "山东");map.put(new Person("张三3", 11) , "北京");map.put(new Person("张三4", 11) , "上海");//keySet() 增强forfor(Person key : map.keySet())&#123; String value = map.get(key); System.out.println(key+"..."+value);&#125;System.out.println("-------分割线----------");//entrySet() 增强forfor(Map.Entry&lt;Person, String&gt; entry : map.entrySet())&#123; Person key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"..."+value);&#125; LinkedHashMap* 继承自HashMap * 保证了迭代的顺序, 存取有序 * 都属于线程不安全集合 Hashtable的特点* Map接口的实现类 * 底层数据结构也是哈希表, 特点和HashMap一样 * JDk1.2后, 被HashMap取代 * HashMap和Hashtable的区别: * 共同点: 1. 底层都是哈希算法 2. 都是双列集合 * 区别一: 1. HashMap JDk1.2出现, 线程不安全集合, 效率较高 2. Hashtable JDk1.0出现, 线程安全集合, 效率较低 * 区别二: 1. HashMap 允许存储null键,null值 2. Hashtable 不允许存储null键,null值 * Hashtable的子类 Properties, 用于IO流 静态导入(了解)* JDk1.5新特性 * 作用: 减少开发的代码量 * 实际用处一般 * 如import static java.lang.System.out; 方法的可变参数* JDK1.5新特性 * 前提: 方法参数数据类型确定, 参数个数任意 * 参数列表格式: (数据类型...变量名) * 可变参数的本质: 数组 * 一个参数不传, 打印变量名,得到是地址值 * 注意事项: 1. 如果要传递多个参数,需要把可变参数放在最后 2. 一个方法里,只能有一个可变参数, 数据类型不同也不行 如: public static int getSum(int b, int...a){ } ，写成(int...a,int b)就接收不到b 12345678//计算多个数的和public static int getSum(int...a)&#123; int sum = 0; for(int i : a)&#123; sum += i; &#125; return sum;&#125; Collections集合工具类* 由静态方法组成 常用方法(静态)1. sort(List&lt;&gt; list) : 对于List集合,进行升序排列 2. T binarySearch(List&lt;T&gt; list, Tkey) : 对应List集合进行二分查找, 传递List集合和被查找到元素 找不到返回 (-插入点-1) 3. shuffle(List&lt;&gt; list) : 对List集合中的元素, 进行随机排列 Map集合的嵌套* Map里面嵌套Map 方式一: keySet()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//创建班级集合, 键是学号 , 值是姓名HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;();HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;();//向javase班添加学生信息javase.put("001", "张三");javase.put("002", "李四");//向javaee班添加学生信息javaee.put("001", "王五");javaee.put("002", "赵六");//创建传智播客集合, 键是班级名, 值是班级HashMap&lt;String, HashMap&lt;String, String&gt;&gt; czbk = new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();//向传智播客添加班级信息czbk.put("基础班", javase);czbk.put("就业班", javaee);/* * KeySet() *///增强forfor(String className : czbk.keySet())&#123; HashMap&lt;String, String&gt; classMap = czbk.get(className); for(String id : classMap.keySet())&#123; String name = classMap.get(id); System.out.println(className+ "..." + id+"..."+name); &#125;&#125;System.out.println("-----------分割线-----------");//迭代器//1.通过czbk的KeySet(), 把所有键即班级名存入classNameSet集合Set&lt;String&gt; classNameSet = czbk.keySet();//2.遍历Set集合: 通过Set集合classNameSet,获取一个迭代器Iterator&lt;String&gt; classit = classNameSet.iterator();//迭代器中是czbk集合的所有键while(classit.hasNext())&#123; //classit.next()中就是班级名键 String classNameKey = classit.next(); //3.通过czbk的get方法, 获取czbk集合的值, 即班级集合 HashMap&lt;String,String&gt; classMap = czbk.get(classNameKey); //4.通过班级集合classMap的keySet(),把所有键即学生ID存入stuSet集合 Set&lt;String&gt; stuSet = classMap.keySet(); //5.遍历Set集合: stuSet集合调用iterator(),获取一个迭代器 Iterator&lt;String&gt; stuit = stuSet.iterator(); //迭代器中存的是班级集合中的键,即学生id while(stuit.hasNext())&#123; String stuIdKey = stuit.next(); //6.通过班级集合的get方法, 获取班级集合classMap的值, 即学生名 String stuName = classMap.get(stuIdKey); //7.打印 System.out.println(classNameKey+".."+stuIdKey+".."+stuName); &#125;&#125; 方式二: entrySet()123456789101112131415161718192021222324252627282930/* * entrySet() *///增强forfor(Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt; classEntry : czbk.entrySet())&#123; String className = classEntry.getKey(); HashMap&lt;String, String&gt; classMap = classEntry.getValue(); for(Map.Entry&lt;String, String&gt; stuEntry : classMap.entrySet())&#123; String id = stuEntry.getKey(); String name = stuEntry.getValue(); System.out.println(className+"..."+id+"..."+name); &#125;&#125;System.out.println("-----------分割线-----------");//迭代器Set&lt;Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt;&gt; classEntry = czbk.entrySet();Iterator&lt;Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt;&gt; classIt = classEntry.iterator();while(classIt.hasNext())&#123; Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt; classMap = classIt.next(); String className = classMap.getKey(); HashMap&lt;String, String&gt; stuMap = classMap.getValue(); Set&lt;Map.Entry&lt;String, String&gt;&gt; stuEntry = stuMap.entrySet(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; stuIt = stuEntry.iterator(); while(stuIt.hasNext())&#123; Map.Entry&lt;String, String&gt; stu = stuIt.next(); String id = stu.getKey(); String name = stu.getValue(); System.out.println(className+"..."+id+"..."+name); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义类]]></title>
      <url>%2F2017%2F01%2F15%2F09-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[类* 分两种,一种是JAVA提供的,一种是自定义类 * 类是用于描述事物的. * 事物的特征叫属性 * 事物的功能叫方法 自定义类的格式* 使用类的形式,对现实中的事物进行描述。 * 格式 123456789public class 类名&#123; 属性定义(成员变量) 修饰符 数据类型 变量名 = 值 方法定义(成员方法) 修饰符 返回值类型 方法名(参数列表)&#123; &#125;&#125; 自定义类的内存图 注意一点: new一个对象后,类中的成员变量,一并进入堆内存,并被赋予默认值new出来对象的属性,存在堆里面根据内存图,可知,即使没被赋值,打印 类名.属性 ,也会有默认值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[方法]]></title>
      <url>%2F2017%2F01%2F13%2F08-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[方法的概述* 提高代码的复用性 * 完成特定功能的代码块。 方法的定义格式* 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } * 方法的格式说明 * 参数： * 实际参数：就是实际参与运算的,调用方法时传递 * 形式参数；就是方法定义上的，用于接收实际参数 * return： * 将返回值返回给调用者 * 结束方法 * 两个明确： 返回值类型：结果的数据类型 参数列表：参数的个数及对应的数据类型 调用方法执行流程* 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。 * 方法的执行，是把实参传递给形参，从而来执行的。 * 方法只有被调用才会执行。 方法调用的内存图: 注意事项* 方法不调用不执行 * 方法之间是平级关系，不能嵌套定义 * 方法返回值是void,方法中可以省略return 不写 return 下面不能有代码 * 如果方法有明确的返回值类型，就必须有return语句返回。 * 方法在调用的时候，不用再传递数据类型 * 调用方法的时候,返回值是void, 不能写在输出语句中 * 不能重复定义(指的是方法名,参数列表都相同的不能在同一类中定义) 方法的重载* 在同一个类中，方法名相同，参数列表不同。 * 参数列表不同： * 个数不同 * 类型不同 * 顺序不同(算重载) 方法重载注意事项* 参数列表必须不同 * 重载和参数变量名无关 * 重载和返回值类型无关 * 重载和修饰符无关 * 技巧: 重载看方法名和参数列表 方法参数* 方法参数是基本数据类型时，传递的是值。 * 方法参数是引用数据类型时，传递的是内存地址值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组]]></title>
      <url>%2F2017%2F01%2F11%2F07-%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[一维数组1. 数组概述* 存储同一种数据类型的多个元素的容器。 * 特点: (1)元素数据类型必须一致。 (2)长度固定 2. 数组的定义* 格式: 数据类型[] 数组名 = new 数据类型[元素个数或数组长度]; 数据类型 数组名[] = new 数据类型[元素个数或数组长度];//也对 * 举例: int[] x = new int[100]; * 索引(index) 每个元素都有自己的自动编号,叫作索引(index), 下标, 角标 数组的最小索引是0, 最大索引数组.length-1 * 初始化默认值 byte,short,int,long 0 float,double 0.0 char &apos;\u0000&apos; boolean false 引用类型 null 3. 数组初始化* 动态初始化 : 只给长度，系统给出默认值 类型[] 数组名 = new 类型[长度]; int[] arr = new int[4]; * 静态初始化 : 给出值，系统决定长度 (1) 类型[] 数组名 = new 类型[]{元素1，元素2，……}; int[] arr = new int[]{1,2,3,4}; //new int[],这个中括号中不能有任何内容,不要指明数组长度 可以改写成: 数组的声明: int[] arr; 数组的赋值: arr = new int[]{1,2,3,4}; (2) 类型[] 数组名 = {元素1，元素2，元素3，……}; int[] arr = { 1, 2, 3, 4 }; //这种形式不能改成声明+赋值分开写的形式 4. JVM内存划分* JVM对自己的内存划分为5个区域 * 寄存器:内存和CPU之间 * 本地方法区: JVM调用了系统中的功能 * 方法区(方法和数据共享区): 运行时期class文件进入的地方 * 方法栈:所有的方法运行的时候进入内存,进入的就是栈内存 * main方法,压栈运行,第一个进栈,在栈最底部,最后释放 * 存储局部变量 * 堆内存:存储的是容器和对象,存储所有new出来的 注意： a:局部变量 在方法定义中或者方法声明上定义的变量。 b:栈内存和堆内存的区别 栈：数据使用完毕，就消失。 堆：每一个new出来的东西都有地址 数据使用完毕后，在垃圾回收器空闲的时候回收。 5. 数组的内存* int[] x; // 声明一个int[]类型的变量 * x = new int[100]; // 创建一个长度为100的数组 * arr引用类型,保存的不是数据,是内存的地址,通常是十六进制保存.每次分配的内存地址不一定一样 * [:一维数组 * I:数据类型 int * @:分隔符 * 60e218:十六进制地址 数组在创建过程中内存的分配情况: 1.程序运行时,.class文件进入方法区 2.找到程序入口main方法,进入方法栈,main方法压栈运行 3.执行int[] arr = new int[3];在堆内存中,开辟一段连续空间,长度为3. 4.arr中保存开辟空间的首地址 6. 遍历数组* 依次访问数组中的每个元素 * 举例 123456789public class ArrayDemo04 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; // 定义数组 // 使用for循环遍历数组的元素 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); // 通过索引访问元素 &#125; &#125;&#125; 7. 逆序(反转)12345678方式1： public static void reverse(int[] arr) &#123; for(int x=0; x&lt;arr.length/2; x++) &#123; int temp = arr[x]; arr[x] = arr[arr.length-1-x]; arr[arr.length-1-x] = temp; &#125; &#125; 12345678方式2： public static void reverse(int[] arr) &#123; for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) &#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125; 8. 数组中常见的异常* 数组操作中,常见的两个异常 数组的索引越界异常(ArrayIndexOutOfBoundsException) 空指针异常(NullPointerException) * 练习 12345678910111213141516171819public class ArrayDemo_4&#123; public static void main(String[] args)&#123; //(1)数组的索引越界异常: 访问了数组中不存在的元素 //int[] arr = &#123;5,2,1&#125;; //数组中3个元素,索引 0,1,2 //System.out.println(arr[3]); //编译不报错,运行出错 //java.lang.ArrayIndexOutOfBoundsException: 3 //(2)空指针异常 int[] arr2 = &#123;1,5,8&#125;; System.out.println(arr2[2]); arr2 = null; // arr2 不在保存数组的地址了 System.out.println(arr2[2]); //编译不报错,运行出错 //java.lang.NullPointerException &#125;&#125; 9. 数组获取最值代码实现* 数组获取最值的原理思想 * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素 * 为什么选择数组中的一个元素作为最大值,因为如果自己定义的一个数据比数组所有数据都大,那比较完,得不出数组最大值 * 代码实现 12345678910111213public class ArrayDemo05 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 4, 1, 6, 3, 9, 8 &#125;; // 定义一个数组 int max = arr[0]; // 定义变量max用于记住最大数，首先假设第一个元素为最大值 // 下面通过一个for循环遍历数组中的元素 for (int x = 1; x &lt; arr.length; x++) &#123; if (arr[x] &gt; max) &#123; // 比较 arr[x]的值是否大于max max = arr[x]; // 条件成立，将arr[x]的值赋给max &#125; &#125; System.out.println("max=" + max); // 打印最大值 &#125;&#125; 二维数组1. 二维数组的定义* 作用 * 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？ * 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。 * 格式 * 第一种定义格式: * int[][] arr = new int[3][4]; * 上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组 * 第二种定义格式 * int[][] arr = new int[3][]; * 第二种方式和第一种类似，只是一维数组中每个元素的长度不确定 * 第三种定义格式 * int[][] arr = {{1,2},{3,4,5,6},{7,8,9}}; * 每个一维数组用大括号,不是小括号,别忽视了 * 二维数组中定义了三个元素，这三个元素都是数组，分别为{1,2}、{3,4,5,6}、{7,8,9} 2. 二维数组元素的访问* 案例: 12345678910111213141516171819202122232425262728293031class ArrayDemo08 &#123; public static void main(String[] args)&#123; //定义二维数组的方式 int[][] arr = new int[3][4]; System.out.println( arr ); System.out.println("二维数组的长度: " + arr.length); //获取二维数组的3个元素 System.out.println( arr[0] ); System.out.println( arr[1] ); System.out.println( arr[2] ); System.out.println("打印第一个一维数组的元素值"); System.out.println( arr[0][0] ); System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素 System.out.println( arr[0][2] ); System.out.println( arr[0][3] ); System.out.println("打印第二个一维数组的元素值"); System.out.println( arr[1][0] ); System.out.println( arr[1][1] ); System.out.println( arr[1][2] ); System.out.println( arr[1][3] ); System.out.println("打印第三个一维数组的元素值"); System.out.println( arr[2][0] ); System.out.println( arr[2][1] ); System.out.println( arr[2][2] ); System.out.println( arr[2][3] ); &#125;&#125; 3. 二维数组内存图* 举例:int[][] arr = new int[3][2]; * 外层数组在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值 * 每一个大内存空间里又开辟连续的两个小的内存空间. 4. 二维数组的定义和访问* 定义 * 格式1: int[][] arr = new int[3][]; 不推荐 * 格式2 int[][] arr = {{1,2,4},{4,7},{0,9,3}}; * 访问 举例:int[][] arr = {{1,2,4},{5,8,7},{0,9,3}}; 想要打印数组中7这个元素需要先找到大的元素索引{5,8,7} 索引为1 ,在找7在{5,8,7}中的索引2 那么结果为 arr[1][2] [1]代表大数组中{5,8,7}这个元素索引,[2]代表{5,8,7}中7元素的索引 5. 二维数组的遍历* 二维数组遍历 int[][] arr = {{1,2,4},{4,7},{0,9,3}}; 先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组 在外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素 * 举例 123456789101112131415public class ArrayArrayDemo_2&#123; public static void main(String[] args)&#123; int[][] arr = &#123; &#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;,&#123;0&#125; &#125;; //外循环,遍历二维数组 for(int i = 0 ; i &lt; arr.length ;i++)&#123; //内循环,遍历每个一维数组 arr[0] arr[1] arr[i] //注意内层for的条件是,j&lt; 每个一维数组的长度 for(int j = 0 ; j &lt; arr[i].length; j++)&#123; System.out.print(arr[i][j]); &#125; System.out.println(); &#125; &#125;&#125; * 累加求和 12345678910111213class ArrayDemo09 &#123; public static void main(String[] args)&#123; int[][] arr2 = &#123; &#123;1,2&#125;,&#123;3,4,5&#125;,&#123;6,7,8,9,10&#125; &#125;; int sum2 = 0; for (int i=0; i&lt;arr2.length; i++) &#123; for (int j=0; j&lt;arr2[i].length; j++) &#123; //System.out.println(arr2[i][j]) sum2 += arr2[i][j]; &#125; &#125; System.out.println("sum2= "+ sum2); &#125;&#125; 6. 二维数组的求和练习* 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示 * 第一小组销售额为{11, 12}万元 * 第二小组销售额为{21, 22, 23}万元 * 第三小组销售额为{31, 32, 33, 34}万元。 * 代码实现 123456789101112131415161718public class ArrayDemo10 &#123; public static void main(String[] args) &#123; int[][] arr = new int[3][]; // 定义一个长度为3的二维数组 arr[0] = new int[] &#123; 11, 12 &#125;; // 为数组的元素赋值 arr[1] = new int[] &#123; 21, 22, 23 &#125;; arr[2] = new int[] &#123; 31, 32, 33, 34 &#125;; int sum = 0; // 定义变量记录总销售额 for (int i = 0; i &lt; arr.length; i++) &#123; // 遍历数组元素 int groupSum = 0; // 定义变量记录小组销售总额 for (int j = 0; j &lt; arr[i].length; j++) &#123; // 遍历小组内每个人的销售额 groupSum = groupSum + arr[i][j]; &#125; sum = sum + groupSum; // 累加小组销售额 System.out.println("第" + (i + 1) + "小组销售额为：" + groupSum + " 万元"); &#125; System.out.println("总销售额为: " + sum + " 万元"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[流程控制语句]]></title>
      <url>%2F2017%2F01%2F10%2F06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
      <content type="text"><![CDATA[选择结构if1. if语句* 书写格式 if(比较表达式) { 语句体; } * 执行流程 * 先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体； * 如果是false，就不执行语句体； * 注意:如果写成这样: if(比较表达式); { 语句体; } 加上分号&quot;;&quot; ,则代表if语句已经结束,大括号内的内容不管if的比较表达式true或false都会执行 2. if…else语句* 书写格式 if(比较表达式) { 语句体1; }else { 语句体2; } * 执行流程 * 首先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体1； * 如果是false，就执行语句体2； 3. if…else if…else语句* 适合在程序中,实现多条件的判断 * 书写格式 if(比较表达式1) { 语句体1; }else if(比较表达式2) { 语句体2; }else if(比较表达式3) { 语句体3; } ... else { 语句体n+1; } * 执行流程 * 首先计算比较表达式1看其返回值是true还是false， * 如果是true，就执行语句体1，if语句结束。 * 如果是false，接着计算比较表达式2看其返回值是true还是false， * 如果是true，就执行语句体2，if语句结束。 * 如果是false，接着计算比较表达式3看其返回值是true还是false， * 如果都是false，就执行语句体n+1。 * 案例代码 123456789101112131415161718public class IfElseIfDemo&#123; public static void main(String[] args)&#123; //成绩判断要求 ,成绩&gt;80 成绩&gt;70 成绩&gt;60 不及格 //定义变量,保存成绩 int grade = 75; //使用if else if 语句对成绩判断 if( grade &gt; 80 )&#123; System.out.println(grade+" 成绩是优"); &#125;else if ( grade &gt; 70)&#123; System.out.println(grade+" 成绩是良"); &#125;else if ( grade &gt; 60)&#123; System.out.println(grade+" 成绩是中"); &#125;else&#123; System.out.println(grade+" 成绩是差"); &#125; &#125;&#125; * 注意: 只要有1个if的条件是true,其他的代码,不再执行 4. if语句和三元运算符的互换* 使用if语句还是三元表达式 * 判断条件多,使用if * 三元,必须有结果的, if 可以没有结果的 * 三元运算符可以转换为if,但if不一定能转换为三元 * 案例代码 12345678910111213141516public class IfElseDemo_1&#123; public static void main(String[] args)&#123; int i = 15; int j = 6; //使用if语句,判断出最大值 if(i&gt;j)&#123; System.out.println(i+" 是最大值"); &#125;else&#123; System.out.println(j+" 是最大值"); &#125; //使用三元运算实现 int k = i&gt;j ? i : j; System.out.println(k+" 是最大值"); &#125;&#125; 循环结构1. while循环* 使用格式 初始化表达式； while(条件){ 循环体 } * 执行顺序 当条件是true,就执行循环体,执行完循环体后 程序再次执行while中的条件,如果条件还是true,继续执行循环体 直到条件是false的时候,循环就结束 2. for循环* 使用格式 for(初始化表达式 ; 条件表达式 ; 循环后操作表达式){ 循环体; } * 执行流程 for（① ; ② ; ③）{ ④ } 第一步，执行①,①终身只执行一次 第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步 第三步，执行④ 第四步，执行③，然后重复执行第二步 第五步，退出循环 * for与while循环: 1.for与while循环可以相互转换,但不建议转换 2.for循环中的初始化表达式中变量的作用范围只在for语句中有效 3.while初始化表达式是在while循环上边定义,作用范围大 3. do_while循环* 使用格式 do{ 循环体; }while(条件);//别丢了这个分号 * 执行顺序 先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体， 如果条件为false，循环结束。 * 特点 无条件先执行一次 4. 死循环* 概述 * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环 * 格式 * while(true){} * for(;;){} * for(;true;){} * 注意:无限循环语句后面不允许再写代码,会编译失败. * 但不是没有机会执行,当程序满足一定条件(break),可以控制,让死循环停止,执行后面的代码 5. 嵌套for循环* 概述 * 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。 * while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套 * 嵌套循环的格式 for(初始化表达式; 循环条件; 操作表达式) { ……… for(初始化表达式; 循环条件; 操作表达式) { 执行语句 ……… } ……… } * 执行顺序: 1.外循环执行一次, 2.内循环全部执行完, 3.回到外循环,外循环继续执行一次 4.内循环再全部执行完 5.再回到外循环,重复1到5,直到外循环结束 * 各模块解释 * 总的循环次数 = 内循环次数 * 外循环的次数 * 内循环,是外循环的循环体 * 外循环,控制的是行数 * 内循环,控制的是每行的个数 * 案例 * 打印正三角形 12345678910public class ForForDemo&#123; public static void main(String[] args)&#123; for(int i = 0 ; i &lt; 9 ; i++)&#123; for(int j = 0; j &lt; i+1 ;j++)&#123; //++i System.out.print("* "); &#125; System.out.println(); &#125; &#125;&#125; 6. break语句* 作用 * 跳出当前所在的循环体 * 应用环境 * 只能应用在循环语句和switch语句中 * 注意 * 如果写在循环嵌套的内循环,结束的是内循环.除非在外循环前面加上循环标号,然后break 循环标号; * 举例 123456789&#123; for(int i=0; i&lt;10; i++) &#123; if(i&gt;5) &#123; break; &#125; System.out.println(“我爱Java”+i); &#125;&#125;//会从0-5输出6次“我爱Java” * break详细解释 * a: 作用 * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中， 可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码， 这些关键字一旦出现就可以跳转语句执行顺序。 * b: 使用方式 * 无法单独使用，必须将break关键字置于switch或循环语句中 * c: 运行规律 * 不需要判断任何条件，只要遇到break便直接跳出执行后续代码。会完全跳出选择或者循环结构 * 只能跳出最近的代码块，不能跨越多级代码块 * 循环标号 * a: 为什么使用循环标号 * 当在双层循环或者循环内有switch选择语句时，我们发现 使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了. * b: 使用方式 * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。 使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可 * c: 运行规律 * 当外层循环外定义了标号 内层使用break，终止内外双层循环。 内层使用continue，终止内层循环，继续外层循环。 7. continue语句* 作用 * 提前结束本次循环，继续进行下次循环 * 应用环境 * 无法单独使用，只能应用于循环中 * 运行规律 * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环 * 案例代码 1234567891011public class ContinueDemo&#123; public static void main(String[] args)&#123; for(int i = 0 ; i &lt; 10 ; i++)&#123; if(i%2==0)&#123; continue; &#125; System.out.println(i); &#125; &#125;&#125;//会把0-9之间所有的奇数打印到控制台上 8. switch语句* switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。 * 格式: 1234567891011121314151617swtich(表达式)&#123; case 常量1 : 要执行的语句; break; case 常量2 : 要执行的语句; break; case 常量3 : 要执行的语句; break; default: 要执行的语句; break;&#125; * 执行流程: 表达式和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序, 遇到break,就全结束.若都不匹配,执行default * 关键字: switch case default break * 特别注意: 1. case后,必须是常量 2. 常量后,有冒号 3. 要执行的语句可以是多条语句,包括循环都可以写 9. switch语句接收的数据类型* switch语句中的表达式的数据类型,是有要求的 JDK1.0 - 1.4 数据类型接受 byte short int char JDK1.5 数据类型接受 byte short int char enum(枚举) JDK1.7 数据类型接受 byte short int char enum(枚举), String 10. case穿透* case穿透 * 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，只需写一次。 * 举例: 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args)&#123; int week = 2; switch(week)&#123; case 1: case 2: case 3: case 4: case 5: System.out.println("工作日"); break; //(1) case 6: case 7: System.out.println("休息日"); break; &#125;&#125;//因为week=2,从case 2开始穿透,直到碰到break或switch的右大括号,//如果(1)处没有break,继续穿透//穿透期间,不会再判断case后面的值,还会执行case中的执行语句,即使default在中间,只要没有break,就继续穿透 *int x = 2; int y = 3; switch(x)&#123; default: y++; break; case 3: y++; case 4: y++; &#125; System.out.println("y="+y);//执行顺序: x=2先到case 3,不成立,到case 4,不成立,到了default,执行y++,break结束,输出y=4//把default中的break删掉,执行顺序:case 3不成立,case 4不成立,default,执行y++,y=4了,穿透case3,执行y++,又穿透case 4,执行y++//最后y=6 * 注意: 1. default中一定要有break吗? //不一定,程序只要遇到break或者switch的右大括号,都结束 2. 多个case后的常量可否相同? //不可以 3. default一定要放在case之后吗? //不一定.不管放在哪,switch执行次序不变,都是从第一个case开始]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[引用数据类型]]></title>
      <url>%2F2017%2F01%2F10%2F05-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[创建引用类型变量公式* 引用数据类型的定义格式: 数据类型 变量名 = new 数据类型(); * 引用数据类型的使用: * 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。 * 变量名.方法名(); Scanner类的使用* 作用: 在命令行中,接收键盘的输入 * 使用: (1) 导包 import java.util.Scanner; (2) 创建Scanner对象的变量 Scanner sc = new Scanner(System.in); (3) 读取键盘录入的一个整数 int enterNumber = sc.nextInt(); (4) 读取键盘录入的字符串,注意字符串不能有空格或tab String enterString = sc.next(); * 案例代码 12345678910111213import java.util.Scanner;//特别注意:后面有分号,别丢掉public class Demo05Scanner&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int enterNumber = sc.nextInt(); System.out.println("用户输入的整数为"+enterNumber); String enterString = sc.next(); System.out.println("用户输入的字符串为"+enterString); &#125;&#125; Random随机数类的使用* 作用: 生成随机数 * 使用: (1) import导包：所属包java.util. Random (2) 创建Random对象的变量：Random random = new Random (); (3) 调用方法: * nextInt(int maxValue) 产生[0,maxValue)范围的随机数,包含0不包含maxValue * nextDouble() //产生0.0-1.0之间的数(包括0.0不包括1.0) 如： 12Random random = new Random ();int myNumber = random.nextInt(100);//结果为0-99的一个数 * 随机数,也叫伪随机数,它是JVM根据人写好的算法,生成的 * 案例代码 1234567891011import java.util.Random;public class RandomDemo&#123; public static void main(String[] args)&#123; Random ran = new Random(); // Random类中的,产生随机数的功能 int i = ran.nextInt(100); System.out.println(i); //问题? 产生随机数,范围 1-100之间 // nextInt(100) 0-99 + 1 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基础题目答案]]></title>
      <url>%2F2017%2F01%2F09%2F%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE%E7%AD%94%E6%A1%88%2F</url>
      <content type="text"><![CDATA[数据类型1. JAVA语言中的字符char可以存储一个中文汉字吗?原因? *可以.因为Java中字符占两个字节.一个中文汉字也占两个字节 *Java采用的是Unicode编码 运算符1.请写出该输出语句的结果 * hello98 * 因为括号的优先级,(&apos;a&apos;+1)中的&quot;+&quot;依然执行加法,所以字符型根据Ascii转成97,第一个&quot;+&quot;为连接 * 若本题改成System.out.println(&quot;hello&quot;+&apos;a&apos;+1); * 输出helloa1,两个+都是连接,有误区会输出hello&apos;a&apos;1,这是不对的,因为单引号只是证明a为字符型,输出还是要输出字符的值 2.请分别计算出a,b,c的值?16 16 15 3.分析以下需求，并用代码实现：123456789public class Test&#123; public static void main(String[] args)&#123; int num = 123; int ge = num % 10; int shi = num / 10 % 10; int bai = num / 100 % 10; System.out.println("数字"+num+"的个位数是 "+ge+",十位数是 "+shi+",百位数是 "+bai); &#125; &#125; 流程控制语句1.(1)质数解法一:1234567891011121314151617181920212223242526public class Prime&#123; public static void main(String[] args)&#123; //定义一个计数变量 int count = 0; //遍历1-100之间的整数 for(int i = 1;i &lt;= 100;i++)&#123; //分别让i % (2-----i-1),如果==0,就不是质数 int j = 2; for( ;j &lt; i;j++)&#123; if(i % j == 0)&#123; //当%j == 0,立刻跳出循环,判断j的值,如果i==j的值,说明i是质数 //如果不等,说明i % (比i小的数)== 0,则i不是质数 break; &#125; &#125; if(i == j)&#123; System.out.print(i+" "); count++; if(count % 5 == 0)&#123; System.out.println(); &#125; &#125; &#125; System.out.println("质数总数是: "+count); &#125;&#125; 1.(2)质数解法二:12345678910111213141516171819202122232425262728293031public class Prime&#123; public static void main(String[] args)&#123; //定义一个计数变量 int count = 0; //遍历2-100之间的整数,不从1遍历的原因是定义flag为true,默认都是质数,1不经过内层for,所以依然被认为是质数,所以要从2开始 for(int i = 2;i &lt;= 100;i++)&#123; //默认都是质数 //思考?把boolean flag = true;放在for外边,会怎样? boolean flag = true; for(int j = 2;j &lt; i;j++)&#123; if(i % j == 0)&#123; //不满足质数条件,break //会有疑问?为什解法一在判断i==j,这里i==j,i % j==0,不就把质数整成false //其实,当j==i时,内层for条件已经不成立了,直接执行if(flag)了 flag = false; break; &#125; &#125; //flag为true,就是质数 if(flag)&#123; System.out.print(i+" "); count++; if(count % 5 == 0)&#123; System.out.println(); &#125; &#125; &#125; System.out.println("质数总数是: "+count); &#125;&#125; 2.珠峰 123456789101112public class ZhuFeng&#123; public static void main(String[] args)&#123; int high = 8848; double hou = 0.01; int count = 0; while(hou &lt; high)&#123; hou *= 2; count++; &#125; System.out.println("折叠"+count+"次"); &#125; &#125; 3.打印非9 做法一:123456789101112131415public class DaYin9&#123; public static void main(String[] args)&#123; int count = 0; for(int i = 1;i &lt;= 100;i++)&#123; if(i/10==9 || i%10==9)&#123; continue; &#125; System.out.print(i+" "); count++; if(count % 5==0)&#123; System.out.println(); &#125; &#125; &#125;&#125; 做法二:12345678910111213141516171819202122public class Test3&#123; public static void main(String[] args)&#123; // 1. 定义四个变量 int ge, shi, bai, count=0; // 2.获取数据1-100 for循环 for(int num=1; num&lt;=100; num++)&#123; // 3. 获取数据中的所有位数(个位、十位、百位) ge = num % 10; shi = num / 10 % 10; bai = num / 100 % 10; // 判断每个位数上边的数字是否与7相等 if(ge==7 || shi==7 || bai==7)&#123; continue; &#125; count++; System.out.print(num + " "); if(count % 5 == 0)&#123; System.out.println(); &#125; &#125; &#125;&#125; 4.九九乘法表1234567891011public class JiuJiu&#123; public static void main(String[] args)&#123; for(int i = 1;i &lt;= 9;i++)&#123; for(int j = 1;j &lt;= i;j++)&#123; int ji = j * i; System.out.print(j+"*"+i+"="+ji+" "); &#125; System.out.println(); &#125; &#125;&#125; 数组1.1234567891011121314151617181920212223242526272829303132public class Change&#123; public static void main(String[] args)&#123; int[] arr = &#123;6,2,9,15,1,5,20,7,18&#125;; //本题的关键是找到最大,最小元素的索引位置,而不是找到最大最小值,只要知道位置了,就可以进行交换了 //定义max,min,记录最大元素和最小元素的索引位置 int max = 0,min = 0; for(int i = 0;i &lt; arr.length;i++)&#123; if(arr[max] &lt; arr[i])&#123; max = i; &#125; if(arr[min] &gt; arr[i])&#123; min = i; &#125; &#125; for(int i = 0; i &lt;arr.length;i++)&#123; System.out.print(arr[i]+" "); &#125; System.out.println(); //通过arr[max]和arr[min]可以取到了最大,最小值,定义一个第三方变量,用于交换 int temp = arr[max]; arr[max] = arr[arr.length-1]; arr[arr.length-1] = temp; // temp = arr[min]; arr[min] = arr[0]; arr[0] = temp; // for(int i = 0; i &lt;arr.length;i++)&#123; System.out.print(arr[i]+" "); &#125; &#125; &#125; 2.1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class Test01&#123; public static void main(String[] args)&#123; //1.利用一个for循环,录入用户输入的6个数据,置于数组中 Scanner sc = new Scanner(System.in); int[] arr = new int[6]; for(int i = 0;i &lt; 6;i++)&#123; System.out.println("请输入第"+(i+1)+"个整数:"); arr[i] = sc.nextInt() ; &#125; //2.实现反转 for(int start = 0,end = arr.length-1;start &lt; end;start++,end--)&#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; //3.将翻转后的数组角标为奇数的互相交换 1和3换, 3和5换,以此类推 for(int i = 1,j =3;i &lt; arr.length &amp;&amp; j &lt; arr.length;i+=2,j+=2)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //4.最后将数组最后一个角标为奇数的元素 和数组中第一个角标为奇数的元素交换 //判断最后一个角标为奇数,需要先知道数组长度,根据数组长度的奇偶性,最后一个角标为奇数的索引不同 int lastIndex = (arr.length % 2 == 0 ? arr.length-1 : arr.length-2); int temp = arr[1]; arr[1] = arr[lastIndex]; arr[lastIndex] = temp; // for(int i = 0;i &lt; arr.length;i++ )&#123; System.out.print(arr[i]+" "); &#125; System.out.println(); &#125;&#125; ASCII编码及char类型的存储123456789101112131415//法一: char i,j; for (i = 65; i &lt;= 90; i++) &#123; j = (char) (i + 32); System.out.print("大写: "+i+" 小写: "+j); System.out.println(); &#125;//法二:char daXie = 'A'; char xiaoXie = 'a'; for (int i = 0; i &lt; 26; i++) &#123; System.out.println("大写: "+daXie+" 小写: "+xiaoXie); daXie++; xiaoXie++; &#125; 面向对象1.1234567891011121314151617181920212223242526272829public class Student &#123; //私有空参构造方法 private Student()&#123; &#125; //设置静态Student类型共享变量 stu //能用static的原因是此时并没有创建对象,只是定义一个Student类型的成员变量 private static Student stu; public static Student getStudent()&#123; //第一次调用该方法,stu为引用变量,存的默认值null if (stu == null) &#123; return new Student(); &#125; return stu; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //静态方法,直接用类名.调用 Student stu = Student.getStudent(); System.out.println(stu); System.out.println(stu); System.out.println(stu); System.out.println(stu); System.out.println(stu); &#125;&#125;//打印的地址值一模一样,说明Student对象只被new了一次 2.12345678910111213141516171819202122232425262728293031323334353637383940414243//Phone类public abstract class Phone &#123; public abstract void call(); public abstract void sendMessage();&#125;//接口public interface IGame &#123; public abstract void playGame();&#125;//NewPhonepublic class NewPhone extends Phone implements IGame &#123; @Override public void playGame() &#123; System.out.println("打游戏"); &#125; @Override public void call() &#123; &#125; @Override public void sendMessage() &#123; &#125; &#125;//OldPhonepublic class OldPhone extends Phone&#123; @Override public void call() &#123; &#125; @Override public void sendMessage() &#123; &#125;&#125;//Testpublic class Test &#123; public static void main(String[] args) &#123; //采用匿名内部类, 其实创建的是NewPhone的子类 //NewPhone的子类直接调用NewPhone的playGame() new NewPhone()&#123; &#125;.playGame(); &#125;&#125; 3.12345678910111213141516171819202122232425public class Outer&#123; public void function()&#123; //局部变量i , 生命周期是随着方法弹栈而消亡 //function弹栈后, Inner类并没有被回收 //要想访问i,需要将i设为常量,进入常量池中,局部内部类就可以访问到 fianl int i = 10; //局部内部类在方法内 class Inner &#123; int j = i; //不加final,会报错 public void method()&#123; syso(j); &#125; &#125; //创建内部类对象,调用method方法 //如果不创建,没法执行method方法 new Inner().method(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.function(); &#125;&#125; 4.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Person &#123; //私有成员内部类 private class Heart&#123; public void h()&#123; System.out.println("私有成员内部类"); &#125; &#125; //为私有成员内部类创建public方法 public Heart getHeart()&#123; return new Heart(); &#125; public void getHeartMethod(Heart h)&#123; h.h(); &#125; //静态成员内部类 public static class Shen&#123; public void s()&#123; System.out.println("静态成员内部类"); &#125; &#125; //默认成员内部类 class Fei&#123; public void f()&#123; System.out.println("默认成员内部类"); &#125; &#125; //局部内部类 public void method()&#123; class Gan&#123; public void g()&#123; System.out.println("局部内部类"); &#125; &#125; new Gan().g(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //调用默认成员内部类 Person.Fei f = new Person().new Fei(); f.f(); //调用静态成员内部类 new Person.Shen().s(); //调用私有成员内部类 new Person().getHeartMethod(new Person().getHeart()); //调用局部内部类 new Person().method(); &#125;&#125;//结果://默认成员内部类//静态成员内部类//私有成员内部类//局部内部类 API1. 做法一:(我的第一遍做法)123456789101112131415161718192021public static void main(String[] args) &#123; String[] str = &#123; "010", "3223", "666", "7890987", "123123","5233425" &#125;; System.out.println("对称字符串的个数: " + getCount(str));&#125;public static int getCount(String[] str) &#123; int count = 0; for (int i = 0; i &lt; str.length; i++) &#123; int j = 0; for (; j &lt; str[i].length(); j++) &#123; if (str[i].charAt(j) != str[i].charAt(str[i].length() - j - 1)) &#123; break; &#125; &#125; if (j == str[i].length()) &#123; count++; &#125; &#125; return count;&#125; 做法二:判断是否对称,定义为方法1234567891011121314151617181920212223public static void main(String[] args) &#123; String[] str = &#123; "010", "3223", "666", "7890987", "123123", "523325" &#125;; System.out.println("对称字符串的个数: " + getCount(str));&#125;public static boolean isDuiCheng(String str) &#123; char[] cArr = str.toCharArray(); for (int i = 0; i &lt; cArr.length; i++) &#123; if (cArr[i] != cArr[cArr.length - i - 1]) &#123; return false; &#125; &#125; return true;&#125;public static int getCount(String[] str) &#123; int count = 0; for (int i = 0; i &lt; str.length; i++) &#123; if (isDuiCheng(str[i])) &#123; count++; &#125; &#125; return count;&#125; 做法三:用StringBuffer1234567891011121314151617public static void main(String[] args) &#123; String[] str = &#123; "010", "3223", "666", "7890987", "123123", "523325" &#125;; System.out.println("对称字符串的个数: " + getCount(str));&#125;public static int getCount(String[] str)&#123; int count = 0; StringBuffer sb ; for (int i = 0; i &lt; str.length; i++) &#123; //每次要new一个StringBuffer对象,确保每次只有一个元素被反转 sb = new StringBuffer(); //sb.append(str[i]).reverse()每次添加一个元素进行反转 if (sb.append(str[i]).reverse().toString().equals(str[i])) &#123; count++; &#125; &#125; return count;&#125; 2. 做法一:(我的第一遍做法)123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println("请输入一个字符串,结束请输入end"); String str = sc.next(); if (str.equals("end")) &#123; break; &#125; //注意,只有char类型的数组可以直接打印 System.out.println(change(str)); &#125; System.out.println("结束"); &#125; private static char[] change(String str) &#123; int count = 0; char[] cArr = str.toCharArray(); for (int i = 0; i &lt; cArr.length; i++) &#123; if (cArr[i] &gt;= 'A' &amp;&amp; cArr[i] &lt;= 'Z') &#123; cArr[i] = (char) (cArr[i] + 32); count++; &#125;else if (cArr[i] &gt;= 'a' &amp;&amp; cArr[i] &lt;= 'z') &#123; cArr[i] = (char) (cArr[i] - 32); count++; &#125;else&#123; cArr[i] = '*'; &#125; &#125; System.out.println("字母的个数: "+count); return cArr; &#125; 做法二: 使用StringBuilder12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(true)&#123; System.out.println("请输入一个字符串,结束请输入end"); String str = sc.next(); if (str.equals("end")) &#123; break; &#125; change(str); &#125; &#125; private static void change(String str) &#123; int count = 0; char[] cArr = str.toCharArray(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; cArr.length; i++) &#123; char c = cArr[i]; if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') &#123; sb.append((char) (c + 32)); count++; &#125;else if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; sb.append((char) (c - 32)); count++; &#125;else&#123; sb.append('*'); &#125; &#125; System.out.println("转换后："+sb); System.out.println("总共"+count+"个字母"); &#125; 3. 做法一:(我的第一遍做法)123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(true)&#123; System.out.println("请输入字符串str1,结束请输入end"); String str1 = sc.next(); if (str1.equals("end")) &#123; break; &#125; System.out.println("请输入字符串str2,结束请输入end"); String str2 = sc.next(); if (str2.equals("end")) &#123; break; &#125; Object[] o = deleteSubString(str1,str2); System.out.println("最终的字符串: "+o[0]); System.out.println("删除的str2的个数: "+o[1]); &#125; System.out.println("结束!");&#125;private static Object[] deleteSubString(String str1, String str2) &#123; int count = 0; String str = str1; //while循环的作用是统计str2的个数 while(str1.contains(str2))&#123;//先拿到str2开始的索引,加上str2的长度,开始截取//注意截取完,一定将新字符串赋值给str1 str1 = str1.substring(str1.indexOf(str2)+str2.length()); count++; &#125; Object[] o = new Object[2]; //将原字符的全部str2删除,返回值是String o[0] = str.replace(str2, ""); o[1] = count; return o;&#125; 做法二: 使用String类的replaceFirst方法1234567891011121314151617181920212223242526272829303132333435注意: 做法一二略有区别:假如str1为abbcca,str2为bc做法一得到的最终结果为abca做法二得到的最终结果为aapublic static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(true)&#123; System.out.println("请输入字符串str1,结束请输入end"); String str1 = sc.next(); if (str1.equals("end")) &#123; break; &#125; System.out.println("请输入字符串str2,结束请输入end"); String str2 = sc.next(); if (str2.equals("end")) &#123; break; &#125; Object[] o = deleteSubString(str1,str2); System.out.println("最终的字符串: "+o[0]); System.out.println("删除的str2的个数: "+o[1]); &#125; System.out.println("结束!");&#125;private static Object[] deleteSubString(String str1, String str2) &#123; int count = 0; while(str1.contains(str2))&#123; str1 = str1.replaceFirst(str2, ""); count++; &#125; Object[] o = new Object[2]; o[0] = str1; o[1] = count; return o;&#125; 5.123456789101112public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入月份: "); int month = sc.nextInt(); List&lt;BigInteger&gt; list = new ArrayList&lt;BigInteger&gt;(); list.add(0,new BigInteger("1")); list.add(1,new BigInteger("1")); for (int i = 2; i &lt;= month; i++) &#123; list.add(i,list.get(i-2).add(list.get(i-1))); &#125; System.out.println("第"+month+"个月繁殖"+list.get(month).toString()+"对兔子");&#125; 6.做法一:(我的第一遍做法)1234567891011public static String getSingleString(String str)&#123; String newStr =""; for (int i = 0; i &lt; str.length() ; ) &#123; char c = str.charAt(0); newStr = newStr + c; str = str.substring(i+1); String c1 = c+""; str = str.replaceAll(c1, ""); &#125; return newStr;&#125; 做法二:12345678910public static String getSingleString(String str)&#123; char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(); for(int i = 0;i&lt;chars.length;i++) &#123; if(!sb.toString().contains(chars[i]+"")) &#123; sb.append(chars[i]); &#125; &#125; return sb.toString();&#125; 做法三:12345678910private static String getSingle(String str) &#123; String newStr = ""; char[] arr = str.toCharArray(); for (int i = 0; i &lt; arr.length; i++) &#123; if (!newStr.contains(arr[i]+"")) &#123; newStr += arr[i]; &#125; &#125; return newStr;&#125; 做法四:123456789101112private static String getSingle(String str) &#123; HashSet&lt;Character&gt; list = new HashSet&lt;Character&gt;(); char[] arr = str.toCharArray(); for (int i = 0; i &lt; arr.length; i++) &#123; list.add(arr[i]); &#125; String s = ""; for (char c : list) &#123; s += c; &#125; return s;&#125; 集合1.做法一:(我的第一遍做法)1234567891011121314Random ran = new Random();List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();int ranNum = 0;for (int i = 0; i &lt; 10; i++) &#123; ranNum = ran.nextInt(10)+1; list.add(i, ranNum); for (int j = 0; j &lt; i; j++) &#123; if (list.get(j) == ranNum) &#123; list.remove(i); i--; &#125; &#125;&#125;System.out.println(list); 做法二:1234567891011public static void main(String[] args) &#123; Random ran = new Random(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while(list.size()&lt;10)&#123; int num = ran.nextInt(100)+1; if (!list.contains(num)) &#123; list.add(num); &#125; &#125; System.out.println(list); &#125; 2.做法一:(我的第一遍做法)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); print(list);&#125;private static void print(ArrayList&lt;Integer&gt; list) &#123; Scanner sc = new Scanner(System.in); System.out.println("要输入几位数: "); int num = sc.nextInt(); for (int i = 0; i &lt; num; i++) &#123; System.out.println("请输入一个0-9之间的数字:"); int inputNum = sc.nextInt(); if (inputNum &gt;= 0 &amp;&amp; inputNum &lt;= 9) &#123; list.add(i, inputNum); for (int j = 0; j &lt; i; j++) &#123; if (list.get(i) == list.get(j)) &#123; System.out.println("输入重复,请重新输入"); list.remove(i); i--; continue; &#125; &#125; if (i == num - 1) &#123; System.out.println("输入正确,输入结束"); &#125; &#125; else &#123; System.out.println("输入错误,重新输入"); i--; continue; &#125; &#125; sort(list); StringBuilder sb = new StringBuilder(); int count = 0; for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i) == 0) &#123; continue; &#125; s: for (int j = 0; j &lt; list.size(); j++) &#123; if (j == i) &#123; continue; &#125; for (int k = 0; k &lt; list.size(); k++) &#123; if (k == i || k == j) &#123; continue; &#125; sb.append(list.get(i)).append(list.get(j)).append(list.get(k)); count++; continue s; &#125; &#125; &#125; char[] cArr = sb.toString().toCharArray(); System.out.println("总共" + count + "种"); for (int i = 0; i &lt; cArr.length; i++) &#123; System.out.print(cArr[i] + ""); if ((i + 1) % 3 == 0) &#123; System.out.print(" "); &#125; &#125;&#125;private static void sort(List&lt;Integer&gt; list) &#123; for (int i = 0; i &lt; list.size() - 1; i++) &#123; for (int j = 0; j &lt; list.size() - i - 1; j++) &#123; if (list.get(j) &gt; list.get(j + 1)) &#123; int temp = list.get(j); list.set(j, list.get(j + 1)); list.set(j + 1, temp); &#125; &#125; &#125;&#125; 做法二:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public static void main(String[] args) &#123; //1、定义一个方法，从控制台获取用户输入的3个任意0-9之间的数字(3个数字不重复) Scanner sc = new Scanner(System.in); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; newList = new ArrayList&lt;Integer&gt;(); //存放每种组合的集合 saveList(sc,list); System.out.println(list); //2、并将其拼接为完全不重复的三位数。 printZuHe(list,newList); //3、对newList集合进行排序 sortList(newList); for(int i = 0 ; i &lt; newList.size(); i++) &#123; int num = newList.get(i); //拿到每一个数字 if(num &lt; 100) &#123; System.out.print("0" + num + " "); &#125;else &#123; System.out.print(num + " "); &#125; &#125; &#125; /* * 对集合进行排序 */ private static void sortList(ArrayList&lt;Integer&gt; newList) &#123; for(int i = 0 ; i &lt; newList.size(); i++) &#123; for(int j = 0; j &lt; newList.size()-1-i; j++) &#123; int num1 = newList.get(j); int num2 = newList.get(j+1); if(num1 &gt; num2) &#123; //交换位置 newList.set(j, num2); newList.set(j+1, num1); &#125; &#125; &#125; &#125; /* * 获取三个数字不重复的组合 * 先将数字拆分成：个位、十位、百位 遍历集合，拿到每一个数字。先对个位数进行赋值 遍历集合，拿到每一个数字。再对十位数进行赋值(在赋值之前，先判断获取到的数字和个位数不相同) 遍历集合，拿到每一个数字。再对百位数进行赋值(在赋值之前，先判断获取到的数字和个位、十位数都不相同) */ private static void printZuHe(ArrayList&lt;Integer&gt; list,ArrayList&lt;Integer&gt; newList) &#123; int ge = 0; int shi = 0; int bai = 0; int count = 0; for(int i = 0 ; i &lt; list.size(); i++) &#123; ge = list.get(i); //对个位数进行赋值 for(int j = 0 ; j &lt; list.size(); j++) &#123; //如果获取到的数字，和个位数的数字不相同。赋值 if(list.get(j) != ge) &#123; shi = list.get(j); //对十位数进行赋值 for(int k = 0 ; k &lt; list.size(); k++) &#123; //先判断获取到的数字和个位、十位数都不相同 if(list.get(k) != ge &amp;&amp; list.get(k) != shi) &#123; bai = list.get(k); //对百位数进行赋值 //System.out.println(""+ge + shi + bai); String strNum = "" + ge + shi + bai; newList.add(Integer.parseInt(strNum)); count++; &#125; &#125; &#125; &#125; &#125; System.out.println("组合一共有：" + count + "种"); &#125; /* * 键盘录入三个数字。不能重复。存入集合 */ private static void saveList(Scanner sc, ArrayList&lt;Integer&gt; list) &#123; System.out.println("请录入3个任意0-9之间的数字："); //如果集合的长度不等于3个 while(list.size() != 3) &#123; //一直存入 int num = sc.nextInt(); //接收键盘录入的数字 if(list.contains(num)) &#123; System.out.println("集合中已经包含此数字,请继续输入！"); &#125;else &#123; //可以存入 list.add(num); &#125; &#125; &#125; 3.1234567891011121314private static void sort(ArrayList&lt;String&gt; list) &#123; //使用选择排序思想，对集合进行排序 for(int i = 0 ; i &lt; list.size(); i++) &#123; for(int j = i+1;j &lt; list.size();j++) &#123; String str1 = list.get(i); //获取第一个字符串 String str2 = list.get(j); //获取第二个字符串 if(str1.compareTo(str2) &gt; 0) &#123; //compareTo 如果返回的是正整数(升序) 返回的是负整数(降序) 返回0(相等) //交换位置 list.set(i, str2); list.set(j, str1); &#125; &#125; &#125;&#125; 4.123456789101112131415161718192021222324252627Scanner sc = new Scanner(System.in);List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();for (int i = 0; i &lt; 4; i++) &#123; System.out.println("请输入第"+(i+1)+"个的姓名:"); String name = sc.next(); System.out.println("请输入第"+(i+1)+"个的年龄:"); int age = sc.nextInt(); list.add(new Person(name, age));&#125;Set&lt;Person&gt; list1 = new LinkedHashSet&lt;Person&gt;();list1.addAll(list);list.clear();list.addAll(list1);for (int i = 0; i &lt; list.size() - 1; i++) &#123; for (int j = i+1; j &lt; list.size(); j++) &#123; Person p1 = list.get(i); Person p2 = list.get(j); if (p1.getAge() &lt; p2.getAge()) &#123; list.set(i, p2); list.set(j, p1); &#125; &#125;&#125;System.out.println(list); 5.做法一:(我的第一遍做法)1234567891011private static String replaceStr(String str) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == 'z') &#123; sb.append('a'); continue; &#125; sb.append((char)(str.charAt(i)+1)); &#125; return sb.toString();&#125; 做法二:123456789101112char[] arr = str.toCharArray();//遍历字符数组for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == 'z') &#123; //如果当前字符是z //将当前字符赋值为a arr[i] = 'a'; &#125;else &#123; //将每个字符+1即可 arr[i] = (char) (arr[i]+1); &#125; &#125; 6.1234567891011121314public static void saveList(ArrayList&lt;Integer&gt; list) &#123; //创建随机数对象 Random r = new Random(); //只要集合长度小于8个，那么就一直生成随机数进行存储 while(list.size() != 8) &#123; //生成一个随机数 int num = r.nextInt(100)+1; //如果这个随机数是奇数 if(num % 2 == 1) &#123; //存入集合 list.add(num); &#125; &#125;&#125; 7.12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("f"); list.add("b"); list.add("b"); list.add("b"); list.add("b"); list.add("b"); list.add("c"); list.add("a"); list.add("d"); //利用HashSet对list集合去重(最终结果:list中没有重复元素) HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(); hs.addAll(list); //将list集合中的内容全部添加到HashSet集合中 list.clear(); //将list集合清空 list.addAll(hs); //将去重后的集合全部添加到list集合中 /*ArrayList&lt;String&gt; newList = new ArrayList&lt;String&gt;(); for(int i = 0 ; i &lt; list.size(); i++) &#123; //如果新集合中不包含此元素，则存入 if(!newList.contains(list.get(i))) &#123; newList.add(list.get(i)); &#125; &#125;*/ System.out.println(list);&#125; 8.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * ArrayList嵌套ArrayList */public static void main(String[] args) &#123; //创建一个学科集合 ArrayList&lt;ArrayList&lt;Student&gt;&gt; classRoom = new ArrayList&lt;&gt;(); //创建基础班集合 ArrayList&lt;Student&gt; javase = new ArrayList&lt;Student&gt;(); javase.add(new Student("张三", 23)); javase.add(new Student("李四", 24)); //创建就业班集合 ArrayList&lt;Student&gt; javaee = new ArrayList&lt;Student&gt;(); javaee.add(new Student("王五", 25)); javaee.add(new Student("赵六", 26)); //将基础班集合和就业班集合添加到学科集合中 classRoom.add(javase); classRoom.add(javaee); //使用迭代器遍历集合 print1(classRoom); //使用增强for遍历集合 print2(classRoom);&#125;private static void print2(ArrayList&lt;ArrayList&lt;Student&gt;&gt; classRoom) &#123; //第一层循环，获取的是班级集合 for(ArrayList&lt;Student&gt; list : classRoom) &#123; //第二层循环，获取的是学生对象 for(Student stu : list) &#123; System.out.println(stu); &#125; &#125;&#125;private static void print1(ArrayList&lt;ArrayList&lt;Student&gt;&gt; classRoom) &#123; //获取学科迭代器 Iterator&lt;ArrayList&lt;Student&gt;&gt; it = classRoom.iterator(); while(it.hasNext()) &#123; //获取到每个班级集合 ArrayList&lt;Student&gt; list = it.next(); //通过班级集合获取迭代器 Iterator&lt;Student&gt; it2 = list.iterator(); while(it2.hasNext()) &#123; //获取每一个学生对象 Student stu = it2.next(); //打印学生对象 System.out.println(stu); &#125; &#125;&#125; 9.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void main(String[] args) &#123; //将A-Z,a-z,0-9这些字符存入一个List中 List&lt;Character&gt; list = getList(); //System.out.println(list); //获得生成字符串集合 HashSet&lt;String&gt; stringSet= getSet(list); //遍历输出 for(String s : stringSet)&#123; System.out.println(s); &#125;&#125;private static HashSet&lt;String&gt; getSet(List&lt;Character&gt; list) &#123; //创建两个HashSet集合,第一个用来存10个不重复的字符串,第二个用来存10个字符不重复的字符 HashSet&lt;String&gt; stringSet = new LinkedHashSet&lt;String&gt;(); HashSet&lt;Character&gt; charSet = new LinkedHashSet&lt;Character&gt;(); //定义随机数对象, 来获取随机数 Random ran = new Random(); //当字符串集合长度&lt;10 while(stringSet.size()&lt;10)&#123; //当字符集合长度&lt;10 while(charSet.size()&lt;10)&#123; //生成0-61的随机数 int ranNum = ran.nextInt(list.size()); //获取List集合中该元素 char c = list.get(ranNum); //向charSet集合中添加 charSet.add(c); &#125; //此时获得的charSet是一个长度为10的字符集合 //要向stringSet里添加,需要先转成字符串 //遍历charSet String str = ""; for(char c : charSet)&#123; str+=c; &#125; //此时获得了一个长度为10的字符串,添加至stringSet stringSet.add(str); //将charSet清空,否则再次执行,charSet长度为10,不再进内层while charSet.clear(); &#125; return stringSet;&#125;private static List&lt;Character&gt; getList() &#123; ArrayList&lt;Character&gt; list = new ArrayList&lt;Character&gt;(); for (char i = 'A'; i &lt;= 'Z'; i++) &#123; list.add(i); &#125; for (char i = 'a'; i &lt;= 'z'; i++) &#123; list.add(i); &#125; for (char i = '0'; i &lt;= '9'; i++) &#123; list.add(i); &#125; return list;&#125; 10.1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) &#123; //创建一个List集合,存储字符串元素 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //创建一盒Map集合, 键存字符, 值存字符个数, 使用双列集合的原因是 键不重复, 添加相同键时, 会被覆盖掉 //定一个LinkedHashMap,而不是HashMap的原因是 : 输出格式中, 按照存储顺序进行打印,所以使用存取有序的LinkedHashMap LinkedHashMap&lt;Character,Integer&gt; map = new LinkedHashMap&lt;Character, Integer&gt;(); //list集合添加元素 list.add("abc"); list.add("bcd"); //遍历list集合,拿出每一个元素 for (int i = 0; i &lt; list.size(); i++) &#123; String str = list.get(i); //将字符串str传成char数组 char[] arr = str.toCharArray(); //遍历char数组,判断map集合中是否存在当前的键 for (int j = 0; j &lt; arr.length; j++) &#123; //如果不存在, 添加字符,值为1 if (!map.containsKey(arr[j])) &#123; map.put(arr[j], 1); &#125;else&#123; //如果存在,根据键获取当前字符的值, 即个数 ,进行加1操作, 再添加 map.put(arr[j], map.get(arr[j])+1); &#125; &#125; &#125; //按照指定格式,遍历打印map //keySet增强for Set&lt;Character&gt; charSet = map.keySet(); for(char key : charSet)&#123; int value = map.get(key); System.out.println(key+" = "+value); &#125; System.out.println("--------分割线----------"); //entrySet增强for Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet(); for(Map.Entry&lt;Character, Integer&gt; entry : entrySet)&#123; char key = entry.getKey(); int value = entry.getValue(); System.out.println(key+" = "+value); &#125;&#125; 11.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) &#123; //定义List集合存商品名 ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add("苹果"); list1.add("香蕉"); list1.add("西瓜"); list1.add("橘子"); //定义List集合存商品号 //备注: 惯性思维, 存储不重复的元素, 定义HashSet //但这里定义成ArrayList的原因是: //因为要把商品号添加至双列集合,HashSet没有索引,要想双列集合添加, //还要新建一个List集合存HashSet里面的商品号,再用List集合往双列集合填,比较麻烦 //直接定义成List集合,然后加一个contains判断, 也可达到HashSet去重的目的 ArrayList&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Random ran = new Random(); while(list2.size()&lt;4)&#123; String num = ""; while(num.length()!=8)&#123; num += ran.nextInt(10); &#125; //判断商品号集合中是否包含此号, 不含则添加 if (!list2.contains(num)) &#123; list2.add(num); &#125; &#125; //将商品号,与商品信息添加值双列集合 LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); //遍历List集合,向map中添加商品信息 for (int i = 0; i &lt; list1.size(); i++) &#123; map.put(list2.get(i), list1.get(i)); &#125; //遍历双列集合,显示商品信息 Set&lt;String&gt; keySet = map.keySet(); for(String key : keySet)&#123; String value = map.get(key); System.out.println("商品号:" + key+" | 商品: "+value); &#125; //提示用户输入商品 Scanner sc = new Scanner(System.in); System.out.println("请输入商品号进行查询: "); String str = sc.next(); if (map.containsKey(str)) &#123; System.out.println("根据商品号："+str+"，查询到对应的商品为："+map.get(str)); &#125;else&#123; System.out.println("查无此商品"); &#125;&#125; 异常1.12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; //键盘录入一个整数 Scanner sc = new Scanner(System.in); System.out.println("请输入一个整数: "); //求二进制 while(true)&#123; String num = sc.nextLine(); try&#123; //合适整数则进行求二进制运算,并打印 String binaryNum = Integer.toBinaryString(Integer.parseInt(num)); System.out.println(binaryNum); break; &#125;catch(Exception ex)&#123; try &#123; //如果可以将这个数存入BigInteger中,说明整数过大 new BigInteger(num); //提醒用户重新录入 System.out.println("录入的整数过大请重新录入一个整数"); &#125; catch (Exception e) &#123; try &#123; //如果可以将这个数存入BigDecimal中.说明为小数 new BigDecimal(num); //提醒用户重新录入 System.out.println("录入的是小数,请重新录入一个整数"); &#125; catch (Exception e1) &#123; //不是大整数, 不是小数, 判定为其他字符,提示用户 System.out.println("录入的是非法字符,请重新录入一个整数"); &#125; &#125; &#125; &#125; &#125; IO流1.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void main(String[] args) &#123; //获得一个File型路径 File file = getDir(); //获得文件夹大小 long length = getDirLength(file); System.out.println("文件夹大小是"+length);&#125;/* * 统计文件夹大小 */private static long getDirLength(File file) &#123; //定义大小变量 long length = 0; //拿到file文件夹下的所有路径,存入File数组 File[] subFiles = file.listFiles(); //遍历前必加的判断 if (subFiles != null) &#123; //遍历 for(File subFile : subFiles)&#123; if (subFile.isFile()) &#123; //如果是文件 //length加上文件的大小 length += subFile.length(); &#125;else if(subFile.isDirectory())&#123; //如果是文件夹 //递归调用统计大小的方法。将统计好的字节数和之前方法统计好的进行累加 //这步很容易忽视length+= ,切记 //其他计数问题, 道理类似时, 别忽视这个点 length += getDirLength(subFile); &#125; &#125; &#125; return length;&#125;/* * 获得一个文件夹路径 */private static File getDir() &#123; //创建输入对象 Scanner sc = new Scanner(System.in); //直到录入正确为止,设置死循环,当录入正确时, 跳出循环 System.out.println("请输入一个文件夹路径: "); while(true)&#123; String path = sc.next(); //将一个String类型的路径封装成File型 File file = new File(path); //判断File路径是否存在 if (!file.exists()) &#123; System.out.println("您录入的路径不存在,请重新录入: "); &#125;else if (file.isFile()) &#123; System.out.println("你录入的路径是文件路径,请重新录入: "); &#125;else&#123; return file; &#125; &#125;&#125; 2.123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; File file = new File("D:\\demo1"); int count = getHiddenCount(file); System.out.println(count); &#125;/* * 统计D盘下有多少个隐藏的文件夹(包括子文件夹) */private static int getHiddenCount(File file) &#123; int count = 0; //拿出路径下所有文件 存入File型数组中 File[] subFiles = file.listFiles(); //遍历 if (subFiles != null) &#123; for(File subFile : subFiles)&#123; //思路一: //如果是文件夹且是隐藏的,计数器+1,然后进入隐藏文件夹继续统计 //别忘记要count+= ,之前统计好的要加上 if (subFile.isDirectory() &amp;&amp; subFile.isHidden()) &#123; count++; count += getHiddenCount(subFile); //如果不是隐藏的,但却是文件夹,也要进行统计,也是别忽视了count+= &#125;else if (subFile.isDirectory()) &#123; count += getHiddenCount(subFile); &#125; /*思路二: //如果当前内容是文件夹的话 if(subFile.isDirectory()) &#123; //递归调用 count += getHiddenCount(subFile); //如果是文件夹、并且是隐藏的 if(subFile.isDirectory() &amp;&amp; subFile.isHidden()) &#123; //计数器自增 count++; &#125; &#125; */ &#125; &#125; return count;&#125; 3.做法一:(我的第一遍做法)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static void main(String[] args) throws IOException &#123; //获得两个文件夹路径 File file1 = getDirPath(); File file2 = getDirPath(); if(file1.equals(file2))&#123; System.out.println("源文件夹是目标文件的子文件夹！无法复制。"); &#125;else&#123; //一个文件夹中(包含内容)拷贝到另一个文件夹中 copyDirToOther(file1,file2); System.out.println("拷贝完成!"); &#125;&#125;/* * 一个文件夹中(包含内容)拷贝到另一个文件夹中 */private static void copyDirToOther(File file1, File file2) throws IOException &#123; //将file1文件夹内所有内容封装到File类型数组中 File[] subFiles = file1.listFiles(); //遍历files文件夹 if (subFiles != null) &#123; for(File subFile : subFiles)&#123; if (subFile.isFile()) &#123;//如果是文件 String path = file2.toString()+ "\\"+ subFile.getName(); File file = new File(path); file.createNewFile(); //创建字节流对象 FileInputStream fis = new FileInputStream(subFile); FileOutputStream fos = new FileOutputStream(new File(path)); //创建字节数组作为缓冲 byte[] bytes = new byte[1024]; //定义变量接收read返回值 int len = 0; while((len = fis.read(bytes)) != -1)&#123; fos.write(bytes, 0, len); &#125; //释放资源 fis.close(); fos.close(); &#125;else if (subFile.isDirectory()) &#123; //如果是文件夹 String path = file2.toString()+ "\\"+ subFile.getName(); File file = new File(path); file.mkdirs(); copyDirToOther(subFile,new File(path)); &#125; &#125; &#125;&#125;/* * 返回一个文件夹路径 */private static File getDirPath() &#123; System.out.println("请输入一个文件夹路径:"); Scanner sc = new Scanner(System.in); String dir = ""; while(true)&#123; dir = sc.next(); File file = new File(dir); if (!file.exists()) &#123; System.out.println("传入的路径不存在,请重新输入一个文件夹路径:"); &#125;else if (file.isFile()) &#123; System.out.println("传入的路径是文件路径,请输入一个文件夹路径:"); &#125;else&#123; return file; &#125; &#125;&#125; 做法二: 使用小数组缓冲12345678910111213141516171819202122232425262728293031323334private static void copyDirToOther(File file1, File file2) throws IOException &#123; //将file1文件夹内所有内容封装到File类型数组中 File[] subFiles = file1.listFiles(); //遍历files文件夹 if (subFiles != null) &#123; for(File subFile : subFiles)&#123; if (subFile.isFile()) &#123;//如果是文件 //创建字节流对象 FileInputStream fis = new FileInputStream(subFile);//这里注意一下,FileOutputStream构造方法FileOutputStream(File file)中,如果传一个File型文件路径,如果文件不存在,会自动创建//File构造方法File(File parent, String child) ,传递File型父路径,String型子路径,可以实现自动拼接为完整File类型路径 FileOutputStream fos = new FileOutputStream(new File(file2, subFile.getName())); //创建字节数组作为缓冲 byte[] bytes = new byte[1024]; //定义变量接收read返回值 int len = 0; while((len = fis.read(bytes)) != -1)&#123; fos.write(bytes, 0, len); &#125; //释放资源 fis.close(); fos.close(); &#125;else if (subFile.isDirectory()) &#123; //如果是文件夹 //File构造方法中,有传递父路径与子路径参数的方法,返回值就是将路径封装成File类型 File file = new File(file2, subFile.getName()); //创建文件夹 file.mkdirs(); //递归调用copy方法 copyDirToOther(subFile,file); &#125; &#125; &#125;&#125; 做法三: 使用字节缓冲流+小数组12345678910111213141516171819202122232425262728293031private static void copyDirToOther(File file1, File file2) throws IOException &#123; //将file1文件夹内所有内容封装到File类型数组中 File[] subFiles = file1.listFiles(); //遍历files文件夹 if (subFiles != null) &#123; for(File subFile : subFiles)&#123; if (subFile.isFile()) &#123;//如果是文件 //创建字节缓冲流对象 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(subFile)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File(file2,subFile.getName()))); //创建字节数组作为缓冲 byte[] bytes = new byte[1024]; //使用缓冲流+小数组的形式, 1024时速度最佳 //定义变量接收read返回值 int len = 0; while((len = bis.read(bytes)) != -1)&#123; bos.write(bytes, 0, len); &#125; //释放资源 bis.close(); bos.close(); &#125;else if (subFile.isDirectory()) &#123; //如果是文件夹 //File构造方法中,有传递父路径与子路径参数的方法,返回值就是将路径封装成File类型 File file = new File(file2, subFile.getName()); //创建文件夹 file.mkdirs(); //递归调用copy方法 copyDirToOther(subFile,file); &#125; &#125; &#125;&#125; 4.做法一:使用字符输出流,因为可以写字符串123456789private static void writeToFile(int[] arr, File file) throws IOException &#123; //创建输出流对象 FileWriter fw = new FileWriter(file); for (int i = 0; i &lt; arr.length; i++) &#123; fw.write(arr[i]+" "); &#125; //关闭流 fw.close();&#125; 做法二:使用字节输出流,但要使用getBytes()12345678910private static void writeToFile(int[] arr, File file) throws IOException &#123; //创建输出流对象 FileOutputStream fos = new FileOutputStream(file); for (int i = 0; i &lt; arr.length; i++) &#123; //getBytes()可以将字符串先编码,再解码,比如写入78,文件中查看也是78 fos.write((arr[i]+" ").getBytes()); &#125; //关闭流 fos.close();&#125; 5.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public static void main(String[] args) throws IOException &#123; System.out.println("请输入源文件夹:"); File src = getDir(); System.out.println("请输入目的文件夹:"); File desc = getDir(); copyJava(src,desc); System.out.println("复制成功");&#125;/* * 使用缓冲流将第一个文件夹中的所有.java文件复制到第二个文件夹中 */private static void copyJava(File src, File dest) throws IOException &#123; /* * 分析:操作的是文本文件,使用字符缓冲流 */ //1.将数据源下的所有内容,封装到File数组中 File[] subFiles = src.listFiles(); if (subFiles != null) &#123; //遍历: for (File subFile : subFiles) &#123; if (subFile.isFile() &amp;&amp; subFile.getName().toLowerCase().endsWith(".java")) &#123; //创建字符缓冲流 BufferedReader bfr = new BufferedReader(new FileReader(subFile)); BufferedWriter bfw = new BufferedWriter(new FileWriter(new File(dest, subFile.getName()))); String line = null; while((line = bfr.readLine()) != null)&#123; bfw.write(line); bfw.newLine(); bfw.flush(); &#125; bfw.close(); &#125;else if (subFile.isDirectory()) &#123; //如果文件夹内没有java文件,则不创建该文件夹 //返回true,代表有java文件 if (myCompare(subFile)) &#123; File newDir = new File(dest, subFile.getName()); newDir.mkdirs(); copyJava(subFile,newDir); &#125; &#125; &#125; &#125;&#125;/* * 判断当前文件夹下有无java文件 */private static boolean myCompare(File subFile) &#123; //1.获取传入文件夹下所有的内容 File[] subFiles = subFile.listFiles(); if (subFiles != null) &#123; //2.遍历文件数组，拿到每一个元素(有可能是文件、有可能文件夹) for (File file : subFiles) &#123; //3.如果当前元素是文件、并且是符合条件的文件 那么直接返回true if (file.isFile() &amp;&amp; file.getName().toLowerCase().endsWith(".java")) &#123; return true; &#125;else if (file.isDirectory()) &#123; //4.如果当前元素是文件夹、继续递归调用myCompare方法 boolean b = myCompare(file); if (b == false) &#123; //当前文件夹没有java文件的话,继续遍历subFiles的其他文件 continue; &#125;else&#123; return true; &#125; &#125; &#125; &#125; return false;&#125;/* * 返回一个文件夹路径 */private static File getDir() &#123; Scanner sc = new Scanner(System.in); while(true)&#123; File file = new File(sc.next()); if (!file.exists()) &#123; System.out.println("您输入的路径不存在,请重新输入"); &#125;else if (file.isFile()) &#123; System.out.println("您输入的路径是文件路径,请重新输入"); &#125;else&#123; return file; &#125; &#125;&#125; 6.12345678910111213141516171819202122232425262728//1.创建字符输出缓冲流BufferedWriter bfw = new BufferedWriter(new FileWriter("D:\\count.txt"));//定义字符串String str = "If you want to change your fate I think you must come here to learn java";//2.将字符串切割,将元素装入一个字符串数组String[] strArr = str.split(" +");//3.创建双列集合,数组元素做键,个数做值,保证键的不重复HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();//4.遍历字符串数组,判断双列集合中是否含该键,有的话,当前个数加1,没有的话,个数为1for (int i = 0; i &lt; strArr.length; i++) &#123; if (map.containsKey(strArr[i])) &#123; map.put(strArr[i],map.get(strArr[i])+1); &#125;else&#123; map.put(strArr[i],1); &#125;&#125; //遍历双列集合Set&lt;String&gt; mapSet = map.keySet();for (String string : mapSet) &#123; int count = map.get(string); bfw.write(string+"="+count); //换行 bfw.newLine(); //刷新 bfw.flush();&#125;//关闭流对象bfw.close(); 多线程1.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SubRunnable implements Runnable &#123; private int allCount = 100; //定义实体店售卖个数 private int count1 = 0; //定义官网售卖个数 private int count2 = 0; @Override public void run() &#123; //循环打印,设置死循环 while(true)&#123; //同步代码块包住共享数据allCount synchronized(this)&#123; //个数为0,break; if (allCount &lt;= 0) &#123;//0处 break; &#125; //个数大于0 try &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+"卖出第"+(100-allCount+1)+"个,总共剩余"+--allCount+"个"); if (Thread.currentThread().getName().equals("实体店")) &#123; count1++; this.notify();//唤醒官网线程 this.wait();//实体店线程等待, 注意最后一次,如果是实体点卖出最后一个包,当前allCount为0 //执行这一步后,实体店线程进入等待,唤醒了官网,官网线程执行1处,打印总共卖的个数 //当前实体店线程还在等待,程序并未停止,所以要唤醒所有线程 //allCount--的原因:唤醒实体店线程后,实体店线程从等待处唤醒并开始执行,即本句 //并没有运行0处,并没有break,所以如果allCount没有减减,allCount还等于0,还会执行1处 //打印一遍总共售卖信息,所以--后,allCOunt = -1,就不执行1处了,只打印一遍 &#125;else if (Thread.currentThread().getName().equals("官网")) &#123; count2++; this.notify(); this.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (allCount == 0) &#123;//1处 System.out.println("实体店总共卖了"+count1+"个"); System.out.println("官网总共卖了"+count2+"个"); this.notifyAll(); allCount--; &#125; &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; SubRunnable sr = new SubRunnable(); new Thread(sr, "实体店").start(); new Thread(sr, "官网").start(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基础题目]]></title>
      <url>%2F2017%2F01%2F09%2F%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[数据类型1. JAVA语言中的字符char可以存储一个中文汉字吗?原因? 运算符1. 请写出该输出语句的结果 System.out.println(&quot;hello&quot;+(&apos;a&apos;+1)); 2. 请分别计算出a,b,c的值? 12345678int a = 15;int b = 15;int c = 15;a = ++b; c = a--; b = ++a; a = c--; 3. 分析以下需求，并用代码实现： (1)已知一个三位数，请分别获取该三位数上每一位的数值 (2)例如：123的个位、十位、百位，分别是3、2、1 (3)打印格式&quot;数字123的个位是 3, 十位是 2, 百位是 1&quot; 流程控制语句1. 计算1-100之间的质数有多少个？将质数以及质数总数打印在控制台。每5个数换行 2. 我国最高山峰是珠穆朗玛峰，8848米。现在我有一张足够大的纸，它的厚度是0.01米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度。 3. 分析以下需求，并用代码实现： 打印1到100之内的整数，但数字中包含9的要跳过 每行输出5个满足条件的数，之间用空格分隔。如：1 2 3 4 5 4. 利用嵌套循环，在控制台打印九九乘法表 数组1. 分析以下需求，并用代码实现： (1)定义一个int类型的一维数组，内容为{6,2,9,15,1,5,20,7,18} (2)将数组最大元素与最后一位元素进行交换,最小元素与第一位元素进行交换，并打印数组 2. 分析以下需求，并用代码实现： (1)键盘录入6个int类型的数据存数数组arr中 (2)将arr数组中的内容反转(逆序) (3)将翻转后的数组角标为奇数的互相交换 1和3换, 3和5换,以此类推 (4)最后将数组最后一个角标为奇数的元素 和数组中第一个角标为奇数的元素交换 (5)打印最终的数组(实现了1-4步之后的数组) (6)如：用户输入的6个int数字为[1,2,3,4,5,6],最后输出的结果为[6, 5, 4, 1, 2, 3] ASCII编码及char类型的存储* American Standard Code for Information Interchange，美国标准信息交换代码 ASCII编码，统一规定了常用符号用哪些二进制数来表示。 数字0-9对应ASCII编码十进制为48-57 字母A-Z对应ASCII编码十进制为65-90 字母a-z对应ASCII编码十进制为97-122 * 取值范围 * short:占两个字节,是有符号数据,取值范围-32768-32767 * char: 占两个字节,是无符号数据,取值范围0-65535 * 题目: 输出所有英文字母 面向对象1. Student类中有一个私有化空参构造方法, 写一个方法来new一个Student对象,且只能被创建一次 2. 请编写一个抽象类Phone,两个抽象方法,call() sendMessage() 两个子类OldPhone 和 NewPhone , 其中NewPhone想添加一个玩游戏的功能. 请根据接口的思想实现,并用匿名内部类的方式调用玩游戏的功能. 3. 局部内部类访问局部变量, 该局部变量必须使用哪个关键子修饰,为什么 4. 内部类完整测试,包括各种内部类类型,及使用public,默认类型,private,访问内部类方式 API1.分析以下需求，并用代码实现： (1)定义数字字符串数组{&quot;010&quot;,&quot;3223&quot;,&quot;666&quot;,&quot;7890987&quot;,&quot;123123&quot;} (2)判断该数字字符串数组中的数字字符串是否是对称(第一个数字和最后一个数字相等，第二个数字和倒数第二个数字是相等的，依次类推)的，并逐个输出 (3)如：010 是对称的，3223 是对称的，123123 不是对称的 (4)最终打印该数组中对称字符串的个数 提示：循环获取字符串的每一个字符，依次比较第一个和最后一个，第二个和倒数第二个。。。 2.分析以下需求，并用代码实现： (1)从键盘循环录入录入一个字符串,输入&quot;end&quot;表示结束 (2)将字符串中大写字母变成小写字母，小写字母变成大写字母，其它字符用&quot;*&quot;代替,并统计字母的个数 举例: 键盘录入：Hello12345World 输出结果：hELLO*****wORLD 总共10个字母 3.分析以下需求，并用代码实现： (1)从键盘循环录入录入一个字符串,输入&quot;end&quot;表示结束 (2)定义一个方法 public Object[] deleteSubString(String str1,String str2) { } (3)方法功能描述:从str1中删除所有的str2,并返回删除后的结果,返回结果为Object[]数组 * 该数组的第一个元素为删除所有的str2后的最终的字符串 * 该数组的第二个元素为删除的str2的个数 4.关于String类的练习题，分析运行结果？ public class Test01 { public static void main(String[] args) { //demo1(); //demo2(); //demo3(); //demo4(); demo5(); } private static void demo5() { String s1 = &quot;ab&quot;; String s2 = &quot;abc&quot;; String s3 = s1 + &quot;c&quot;; //只要是变量+ 字符串 ,就会创建一个新对象 System.out.println(s3 == s2); //flase System.out.println(s3.equals(s2)); // } private static void demo4() { //byte b = 3 + 4; //在编译时就变成7,把7赋值给b,常量优化机制 String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;//java中有常量优化机制,在编译时期就能确定s2的值为&quot;abc&quot;,所以编译时期,在常量池中创建&quot;abc&quot; String s2 = &quot;abc&quot;;//执行到这里时常量池中已经有了&quot;abc&quot;,所以就不再创建,所以s1和s2指向的是常量池中同一个字符串常量&quot;abc&quot; System.out.println(s1 == s2); //java中有常量优化机制 System.out.println(s1.equals(s2)); // } private static void demo3() {//==比较的是地址值 String s1 = new String(&quot;abc&quot;); //录的是堆内存对象的地址值 String s2 = &quot;abc&quot;; //记录的是常量池中的地址值 System.out.println(s1 == s2); // System.out.println(s1.equals(s2)); // } private static void demo2() { //创建几个对象 //创建两个对象,一个在常量池中,一个在堆内存中 String s1 = new String(&quot;abc&quot;); System.out.println(s1); } private static void demo1() { //常量池中没有这个字符串对象,就创建一个,如果有直接用即可 String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); //==号比较的是地址值 System.out.println(s1.equals(s2)); //比较的是字符串的内容: } } 5.用循环实现不死神兔 故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。 在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔， 再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡， 问：一对刚出生的兔子，第100个月繁殖多少对兔子?(利用BigInteger完成) 1 1 2 3 5 8 13 21 0 1 2 3 4 5 6 7 6.去除给定的参数字符串中的重复字符（重复字符只保留一个），将新的字符串返回 集合1.生成10个1至100之间的随机整数(不能重复)，存入一个List集合 2.定义一个方法，从控制台获取用户输入的3个任意0-9之间的数字(3个数字不重复),并将其拼接为完全不重复的三位数。 统计一共多少种组合、并且将每种组合进行排序输出。 3.有如下代码： public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;b&quot;); list.add(&quot;f&quot;); list.add(&quot;e&quot;); list.add(&quot;c&quot;); list.add(&quot;a&quot;); list.add(&quot;d&quot;); 定义sort方法。对集合内容排序 sort(list); System.out.println(list); // a, b, c, d, e, f 4.完成如下需求： 1、创建一个Person类。属性：姓名、年龄 生成对应的方法 2、创建一个测试类，在测试类中创建四个Person对象。姓名和年龄要求通过键盘录入(至少录入一个相同的姓名和年龄)。 3、将四个Person对象存储到一个List集合中，并打印集合 4、要求通过Set集合对List集合进行去除重复。打印去重后的List集合(按照年龄从大到小的顺序打印) 5.一个小写的字符串,替换字符串中字母，然后输出 a 替换成 b b 替换成 c ..... z 替换成 a 6.随机生成8个1-100之间的奇数，存放到合适的集合中 7.有如下代码： public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;f&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;a&quot;); list.add(&quot;d&quot;); } 利用HashSet对list集合去重(最终结果:list中没有重复元素) 8.ArrayList嵌套ArrayList 9.按需求完成指定功能，题目如下： 产生10个长度为10的字符串，并遍历打印输出 要求： 1.每个字符串中只能包含大写字母或者小写字母或者0-9的数字 2.每个字符串中的10个字符不能重复 3.10个字符串也不能重复 10.按需求完成指定功能，题目如下： 定义一个List集合,泛型为String类型。统计整个集合中所有字符（注意，不是字符串）的个数。例如： 集合中有”abc”、”bcd”两个元素 程序最终输出结果为: a = 1 b = 2 c = 2 d = 1 11.按需求完成指定功能，题目如下： 有四种水果(苹果，香蕉，西瓜，橘子) 1、给每种水果设定一个商品号，商品号是8个0-9的随机数，商品号码不能重复 2、根据商品号查询对应的商品。 如果查不到输出：“查无此商品” 如果能查到打印：”根据商品号：12345678，查询到对应的商品为：西瓜” 异常1.键盘录入一个int类型的整数,对其求二进制表现形式 要求使用捕获异常的方式对录入的数据进行判断 * 如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数 * 如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数 * 如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数 IO流1.从键盘接收一个文件夹路径(录入的有可能是文件路径或者文件夹路径不存在，要进行判断)。 直到录入正确为止,统计该文件夹大小。 2.统计D盘下有多少个隐藏的文件夹(包括子文件夹) 3.从键盘接收两个文件夹路径,把其中一个文件夹中(包含内容)拷贝到另一个文件夹中 4.该int数组中的数字写入到本地文件number.txt中 5.从键盘录入两个文件夹路径，要判断是否符合是文件夹路径 使用缓冲流将第一个文件夹中的所有.java文件复制到第二个文件夹中 如果其中的某个文件夹内没有java文件,则不创建这个文件夹 6.用代码实现以下需求 (1)有如下字符串&quot;If you want to change your fate I think you must come here to learn java&quot;(用空格间隔) (2)打印格式： to=3 think=1 you=2 //........ (3)按照上面的打印格式将内容写入到D:\\count.txt文件中(要求用高效流) 多线程1.有100个限量版的包包，但是只能通过实体店和官网才能进行购买 (1)请用线程进行模拟并设置线程名称用来代表售出途径，再将信息打印出来。 比如（实体店卖出第1个，总共剩余n个..）,要求交替打印 (2)并且分别统计卖了多少个。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用快捷键]]></title>
      <url>%2F2017%2F01%2F09%2F%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[1.Dos* Shift + 右键 : 当前文件夹下打开dos * Tab : 注意dos下,&quot;Tab键&quot;的使用,可方便输入 * 标记 + 右键/回车 : dos下复制 * &quot;↑&quot;和&quot;↓&quot; : dos未关闭前提下,使用之前的命令 * 复制路径后,dos下右键,可以粘贴 * Ctrl + c :强行停止命令行 2.notepad++* Ctrl + D : 复制该行 * Ctrl + Shift + ↑/↓ :移动该行 * Ctrl + L : 删除该行 * shift + Tab :选中部分整体左移 * tab :选中部分整体右移 * Ctrl + Q : 注释/取消 单行注释 3.xmind* Tab : 新建分支 * F4 : 添加备注 4.eclipse* Ctrl + / :单行注释 * Ctrl + Shift + / :多行注释 * Ctrl + Shift + \ :取消多行注释 * Alt + / :自动补全 * Ctrl + 1 :快速修复 * Ctrl + D :删掉当前行 * Ctrl+Alt+↓ :复制当前行到下一行(复制增加) * Ctrl+Alt+↑ :复制当前行到上一行(复制增加) * Alt+↓ :当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) * Alt+↑ :当前行和上面一行交互位置(同上) * Ctrl+T :选择一个类, 显示当前类的继承结构 * Ctrl+Shift+F :格式化当前代码 * Ctrl+点击 / F3 :查看源码 * Ctrl+Shift+S :生成构造方法,get/set * Ctrl+Shift+O :导包 * Ctrl+2(松手) 再L :写完方法后,自动接收返回值 * Alt+Shift+R :统一修改同名变量名 * Alt+Shift+M :选择一段代码封装成方法 * Alt+Shift+Z :选择一段代码添加try/catch * Alt+Shift+ ←/→ :快速选中一行 * Ctrl + F11 :运行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运算符]]></title>
      <url>%2F2017%2F01%2F08%2F04-%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[算数运算符* 注意事项 1.&quot;+&quot;在连接字符串时要注意，只有直接与字符串相加才会转成字符串. 字符串后面的&quot;+&quot;为&quot;连接&quot;,字符串前面的&quot;+&quot;还是加法 如: System.out.println(5+5+&quot;=&quot;+5+5);这个输出的是10=55 2.&quot;/&quot;除法运算符,整数与整数除,结果为整数;整数与小数除,结果是小数类型 3.&quot;%&quot;取模,取余运算符 -5 % 5 = 0; -10 % 5 = 0; -7 % 5 = -2; 10 % 5 = 0; 2 % 5 = 2; -2 % 5 = -2; 结论: (1)正负符号位取得是左边,与右边无关 (2)如果左边的绝对值是右边绝对值的整数倍,结果为0 (3)如果左边的绝对值大于右边的绝对值,结果为余数(正常取余就行,注意正负号) (4)如果左边的绝对值小于右边的绝对值,结果为左边 (5)任何一个整数%2,结果不是0就是1,可以用来当作切换条件 * ++和--放前放后区别: *符号放前放后,在变量自己独立计算时,没有区别 *在与其他运算符同时计算时会有区别 1234567如： int i = 5; int j = i++; System.out.println(i); System.out.println(j); //结果为i=6,j=5. //因为int j = i++;相当于(1)int j = i;(2)i++; 1234567如： int m = 5; int n = ++m; System.out.println(m); System.out.println(n); //结果为m=6,n=6. //因为int n = ++m;相当于(1)++m;(2)int n = m; 12345678910如： public class Test1 &#123; public static void main(String[] args) &#123; int x = 4; int y = (--x)+(x--)+(x*10); System.out.println("x = " + x + ",y = " + y); &#125; &#125;//思维误区:不要以为(--x)+(x--)+(x*10),都有各自括号,就互不影响//执行完(--x),x为3,再执行(x--)后,x为2,(x*10)为20,所以输出x为2,但是y=3+3+20=26,第二个3是因为先赋值,再自减 12345678910111213如： public class Test2&#123; public static void main(String[] args)&#123; int a = 1; if(a++ &gt; 1)&#123; System.out.println("用2在判断"); &#125;else&#123; System.out.println("用1在判断"); &#125; System.out.println("a="+a); &#125; &#125;//本题证明了(a++ &gt; 1)是用a=1与1做大小判断,而不是2,说明a先比较,再自增.但最终输出a的大小都是2 赋值运算符* 有 = += -= *= /= %= * 注意: 如： 12345 byte b = 1; //(1) b = b + 1; //(2) System.out.println(b); //(3)//编译会报错,因为(1)中b为byte型,占1个字节,(2)中1为int类型,占4个字节,它们相加之后,是4字节.然后赋值给1字节大小的b,会损失精度.//将(2)改成b =(byte) (b + 1);或者b += 1;都对.这两句等价 比较运算符* 也叫关系运算符 * 有 == != &gt; &lt; &gt;= &lt;= * 注意: 如： 12345 int i = 3; int j = 4; System.out.println(i=j); System.out.println(i==j);//结果分别为4和true,因为程序自上而下执行,第一句输出语句执行完之后,i变为4.别忽视了输出语句中,赋值语句对变量在整个作用区间内也起作用. 逻辑运算符* 对两个布尔数据进行计算,结果也是布尔类型 * 有 &amp;与 |或 !非 ^异或 &amp;&amp;短路与 ||短路或 *^异或: 两边相同为false,不同为true 如： true^flase 为 true true^true 为 false *&amp;&amp;短路与: 左边结果为false,右边不执行 如： 123456 int i = 3; int j = 4; System.out.println(i == j &amp;&amp; ++i &gt; 3); System.out.println(i); System.out.println(j);//结果为3和4. i == j 为flase, 所以++i &gt; 3并没有执行 *||短路或: 左边结果为true,右边不执行 * 短路与 和 短路或 可以提高程序运行效率 三元(目)运算符* 公式: 布尔表达式 ? 结果1 : 结果2 *注意:这里的结果1和2,不能是输出语句,必须是确定的结果 运算符优先级优先级 描述 运算符 1 括号 ()、[] 2 正负号 +、- 3 自增自减，非 ++、--、! 4 乘除，取余 *、/、% 5 加减 +、- 6 移位运算 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 7 大小关系 &gt;、&gt;=、&lt;、&lt;= 8 相等关系 ==、!= 9 按位与 &amp; 10 按位异或 ^ 11 按位或 | 12 逻辑与 &amp;&amp; 13 逻辑或 || 14 条件运算 ?: 15 赋值运算 =、+=、-=、*=、/=、%= 16 位赋值运算 &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据]]></title>
      <url>%2F2017%2F01%2F08%2F03-%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[数据1.数据类型* 程序=数据+逻辑 * 数据类型包括 * 1.基本数据类型:整数、小数、字符、布尔 * 2.引用数据类型:数组、类、接口 2.常量* 程序在运行过程中,其值不会发生变化的量 * 整数类型 * 十进制 * 二进制:以0b(0B)开头,只有0和1 * 十六进制:以0x(0X)开头,0-9和A-F,F表示15 * 八进制:以0开头,最大数为7 * 小数类型(浮点类型) * 布尔类型:true和flase为关键字 * 字符类型:单引号中仅能包含一个字符,不能不写字符,可以用一个空格 * 字符串类型:可以写0-n个字符 变量1.变量概述* 什么是变量? * 变量是内存中装载数据的小盒子，你只能用它来存数据和取数据 * 在程序运行过程中,其值可以发生改变的量 2.计算机存储单元* 计算机中最小信息单元是? * 位(bit),也叫比特位.用b表示 * 8个位,表示一个数据 * 计算机中储存和运算的最小单位是? * 一个字节,也就是一个byte.用B表示 * 常用储存单位 *1B（字节） = 8bit *1KB = 1024B *1MB = 1024KB *1GB = 1024MB *1TB = 1024GB *1PB = 1024TB 3.Java中数据类型四类八种* 数据类型四类八种 * 四类 八种 字节数 数据表示范围 * 整型 byte 1 -128～127 short 2 int 4 long 8 * 浮点型 float 4 double 8 * 字符型 char 2 表示一个字符，如(&apos;a&apos;，&apos;A&apos;，&apos;0&apos;，&apos;家&apos;) * 布尔型 boolean 1/8个字节 只有两个值true与false,默认是false 4.常量和数据类型* 常量 * 常量是程序在运行过程中,其值不会发生改变的量 * 整型常量默认是int类型. * 定义长整型数据如果值超过int取值范围后面要+&quot;L&quot;,凡添加了&quot;L&quot;,都是long类型 * 浮点常量默认是double类型,没有后缀或以&quot;D&quot;为后缀,都是double型 * 定义float类型的数据后面要+&quot;F&quot; 否则默认是double * 写法: * long l = 1000; 对 * long l = 12345678901; 错 * long l = 12345678901L; 对 * float f = 1.0; 错 * float f = 1.0F; 对 * float f = 10; 对 5.定义变量* 语法格式： 数据类型 变量名 = 变量值; int a = 100; * 代码: 123456789public class Variable &#123; public static void main(String[] args) &#123; int a = 10; double b = 3.14; char c = 'z'; String s = "i love java"; System.out.println(a); &#125;&#125; * 注意: a.字符串String属于引用类型(类),不属于基本类型, b.变量定义后,不赋值,能编译通过,但运行时会报错.不赋值不能使用。 c.变量使用时有作用域的限制。(所在的大括号范围内) d.变量不允许重复定义 如： 123456789(1)public class Variable &#123; public static void main(String[] args) &#123; &#123; int j = 10; &#125; int j = 10;&#125;//这是对的,因为第一个j声明的作用区间为它所在的大括号,第二个j再声明,和它就不冲突 123456789(2)public class Variable &#123; public static void main(String[] args) &#123; int j = 10; &#123; int j = 10; &#125; &#125;//这是错的,因为第一个j声明的作用区间为它所在的大括号,即整个main方法,第二个j再在main方法中声明,就产生了冲突 6.数据类型转换* 自动类型转换：(也叫自动类型提升,或叫隐式转换) *取值范围小的与取值范围大的数据数据类型做运算时,取值范围小的类型会自动提升为取值范围大的数据类型 *表示范围小的数据类型转换成范围大的数据类型,如byte转成int *自动类型转换格式： 范围大的数据类型 变量 = 范围小的数据类型值； 如： double d = 1000; 或 int i = 100; double d2 = i; * 强制类型转换： * 表示范围大的数据类型转换成范围小的数据类型 *强制类型转换格式： 范围小的数据类型 变量 = (范围小的数据类型) 范围大的数据类型值; 如： int i = (int)6.718; //i的值为6 或 double d = 3.14; int i2 = (int)d; //i2的值为3 * 注意： *布尔类型不参与类型转换 *byte &lt; short &lt; int &lt; long &lt; float &lt; double * 12byte b = (byte)200;System.out.println(b);//注意输出结果不是127,因为会损失精度 * byte b = 10;这是对的.不要以为10为int类型,赋值给byte就需要强制转换. 只要需要赋值的数据值,在byte范围(-128-127)内,就是对的,不需要强制转换.因为java中常量优化机制,只要在范围内自己转换 * 12byte b1=3,b2=4; byte b = b1+b2;// 错 因为b1和b2都是byte类型变量,在参加运算时要先转成int类型,所以b1+b2的结果为int类型,把int类型的数据赋值给byte类型的b,就会损失精度,导致编译报错 byte b = 3+4;//对 解释一:3和4都是int类型的常量,java虚拟机有常量优化机制,编译时就能确实3+4的结果为7,然后把7赋值给byte类型的b,7正好在byte数据范围内,会有一个隐式类型转换,可以赋值成功 解释二:给出了固定值,和不超过范围.由java底层常量优化机制,即可自动转换.如果是byte b = 300+4;那就错了 * char c = 98;这是对的,不要以为没加&apos;&apos;,就不是字符.由Ascii码表,只要数字范围i在(0-65535),就可以Ascii为单个字符 * long可以自动类型变换至float的原因: (1)它们底层的存储结构不同 (2)遵循IEEE-754格式标准,float类型的指数可从-126到128.float表示的数据范围比long型的范围要大]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[注释、关键字、标识符]]></title>
      <url>%2F2017%2F01%2F08%2F02-%E6%B3%A8%E9%87%8A%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[注释* 编译时,编译器会忽略注释 * 包含 * 单行注释:// * 多行注释:/*....*/ * 文档注释:/**...*/ * 多行注释不能嵌套多行注释 关键字* 被JAVA赋予特殊含义,具有专门用途的单词 * JAVA中关键字均为小写 * main不是关键字 标识符* JAVA中,程序员自己定义的内容 * 规则: * 1.组成:字母52个(a-z,A-Z)、数字(0-9)、下划线_、美元符$ * 2.注意:不能以数字开头、不能是关键字、标识符不能有空格、严格区分大小写 * 3.类的名字:首字母大写,第二个单词开始首字母大写 * 4.方法名字与变量名一样:首字母小写,第二个单词开始首字母大写]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA开发概述及HelloWorld]]></title>
      <url>%2F2017%2F01%2F08%2F01-JAVA%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0%E5%8F%8AHelloWorld%2F</url>
      <content type="text"><![CDATA[JAVA环境搭建1.概述* 创始团队:詹姆斯-高斯林 * sun开发,已被oracle收购. * 版本(平台) * JAVASE(标准版):开发简单桌面应用,不能开发大型项目.也叫J2SE * JAVAEE(企业版或Web版):可做电商、企业级应用(如ERP、CRM、BOS、OA等)，也叫J2EE * JAVAME（嵌入式开发）：也叫J2ME 2.常用DOS命令* 清屏：cls(clear screen) * 切换盘符：盘符: * 进入指定目录：cd（change directory） * 返回上一级目录：cd.. * 返回盘符根目录：cd\ * 进入其他盘符文件夹：cd 盘符:\文件夹名 * 显示当前目录下的文件和子目录信息：dir 3.开发环境* JDK(JAVA Development Kit):java开发工具包 * JDK包含 * JRE(JAVA Runtime Environment):JAVA运行环境 * JAVA开发工具 4.跨平台特性* 平台指操作系统(Windows/Linux/mac) * 一次编写,到处运行 * 跨平台特性依赖于JVM(JAVA Virtual Machine) * JRE包含 * JVM * 类库 HelloWorld* 源文件: .java * 编译(编译器): .java → .class(字节码文件) * 运行(解释器): 运行.class 12345 public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("HelloWorld"); &#125;&#125; 注意:1.class前加上public,类名(HelloWorld)要与文件名(HelloWorld.java)一致,不加public,类名可换成其他2.主方法是程序的入口,被虚拟机调用,它能保证程序的独立运行编译:javac HelloWorld.java编译时HelloWorld.java可以写成helloworld.java,因为对源文件来说HellWorld.java和helloworld.java所指的源文件是唯一的运行:java HelloWorld运行时HelloWorld是类名,不能写成helloworld]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA基础题]]></title>
      <url>%2F2017%2F01%2F05%2FJAVA%E5%9F%BA%E7%A1%80%E9%A2%98%2F</url>
      <content type="text"><![CDATA[1.Java注释有3种，单行注释、多行注释和文档注释，下列有关注释的说法，不正确的是（） A. 注释指的是用来对程序的某个功能或者某行代码进行解释说明B. 注释只在Java源文件中有效C. 在多行注释中，能够嵌套多行注释D. 注释不会被编译到class字节码文2.下面哪种类型的文件可以在Java虚拟机中运行？（） A. .javaB. .jreC. .exeD. .class 3.下列关于变量和常量的说法正确的是（） A. 常量表示不能被改变的值，例如1、2、“abc”都是常量B. 常量表示常见的变量C. int x = 0;代码中，x表示常量，0表示变量D. 在同一个大括号｛｝内，定义的变量不能够重名 4.下列定义变量格式，错误的是（） A. float x,y=0;B. float f = 1999.99F;C. String str = 字符串;D. char x = ‘0’; 5.下列各种符号的定义格式，那种在java语言中是错误的变量定义（） A. int myVal =1;B. char $myVal =1;C. byte _myVal =1;D.float 3.14myVal=1; 6.Java语言中的int及char数据类型的长度分别为（） A. 16位和8位B. 8位和16位C. 32位和16位D. 32位和8位 7.语句System.out.println(1+2+”java”+3+4)输出的结果是（） A. 3java34B. 12java34C. 3java7D. 12java7 8.下列关于Java函数的说法不正确的是（） A.函数也叫方法，函数就是定义在类中，具有特定功能的一段小程序B.方法体中不能有任何代码（抽象函数除外）C.函数必须先定义，才能被调用D.函数（构造函数除外）要有返回值类型 9.以下关于函数重载的说法正确的有（） A. 方法名必须一样B. 与返回值类型无关C. 参数个数或者顺序不一样D. 参数类型不一样 10.关于数组的说法，正确的是（） A. 数组里面存放的是相同类型的数据B. 获取数组的长度使用length属性C. 获取数组的大小使用size方法D. 数组的长度是可变的 11.想要结果输出为0，则可以做哪些修改？（） int [] arr = new int[1]; arr[0] = 3; System.out.println( arr[1] ) A. 2修改为arr[3] = 0;B. 3修改为System.out.println(0)C. 1修改为int [ ] arr = new int[2];D. 不用修改了，结果就是0会报错 12.下列二维数组定义错误的是（） A.int[][] arr = new int[3][2]; B.int arr[][] = new int[3][]; C.int[][] arr = {{1,2,3},{4,5},{6,7,8,9}}; D.int arr[][] ={{2,3},{6},9}; 13.下面代码的运行结果是（） public static void main(String[] args){ int x = 80; x ++; switch(x){ case 80: System.out.println(80); case 81: System.out.println(81); default: System.out.println(82); } } A. 80B. 80 81C. 81D. 81 82 14.下面程序运行的结果是（） public static void main(String[] args){ int a = 1; if(a++&gt;1){ System.out.println(a); }else{ System.out.println(a); } } A.1B.2C.0D.编译报错 答案:1~5:C,D,AD,C,D 6~10:C,A,B,ABCD,AB 11~14:BC,D,D,B]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[致自己]]></title>
      <url>%2F2017%2F01%2F01%2F%E8%87%B4%E8%87%AA%E5%B7%B1%2F</url>
      <content type="text"><![CDATA[做一件事,如果过程中你就怕了,退缩了,那不论结果成功还是失败,你都已经输了。]]></content>
    </entry>

    
  
  
</search>
